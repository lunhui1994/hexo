{"meta":{"title":"Eighteen Blog","subtitle":"Eighteen Blog","description":"好学力行，明德任责。一起分享芝士。","author":"赵十八","url":"http://www.zsfmyz.top","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-03-27T09:56:43.174Z","updated":"2020-03-27T09:56:43.174Z","comments":true,"path":"404.html","permalink":"http://www.zsfmyz.top/404.html","excerpt":"","text":"404 Not Found 很抱歉，您访问的页面不存在 QQ：562032497"},{"title":"About","date":"2020-03-27T09:38:13.000Z","updated":"2020-04-15T07:40:23.891Z","comments":true,"path":"about/index.html","permalink":"http://www.zsfmyz.top/about/index.html","excerpt":"","text":"好学力行，明德任责 目前正慢慢从CSDN迁移过来一些。 一个萝卜一个坑儿。 目前在寻找新的工作机会地点：北京有缺小伙伴儿的请微信联系我哦LH_ZSF 联系方式： email：zsfqfb@163.com QQ：562032497 微信："},{"title":"所有分类","date":"2020-03-27T09:56:43.175Z","updated":"2020-03-27T09:56:43.175Z","comments":true,"path":"categories/index.html","permalink":"http://www.zsfmyz.top/categories/index.html","excerpt":"","text":""},{"title":"Demo演示列表","date":"2019-08-27T09:38:13.000Z","updated":"2020-03-27T09:56:43.197Z","comments":true,"path":"demo/index.html","permalink":"http://www.zsfmyz.top/demo/index.html","excerpt":"","text":"Video截图功能实现 font-family字体对照表效果 局部马赛克效果"},{"title":"我的朋友们","date":"2020-03-27T09:56:43.197Z","updated":"2020-03-27T09:56:43.197Z","comments":true,"path":"friends/index.html","permalink":"http://www.zsfmyz.top/friends/index.html","excerpt":"","text":""},{"title":"","date":"2020-03-27T09:56:43.200Z","updated":"2020-03-27T09:56:43.200Z","comments":true,"path":"mylist/index.html","permalink":"http://www.zsfmyz.top/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-03-27T09:56:43.200Z","updated":"2020-03-27T09:56:43.200Z","comments":true,"path":"tags/index.html","permalink":"http://www.zsfmyz.top/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-03-27T09:56:43.175Z","updated":"2020-03-27T09:56:43.175Z","comments":true,"path":"demo/1/index.html","permalink":"http://www.zsfmyz.top/demo/1/index.html","excerpt":"","text":"Title Capture (function() { \"use strict\"; var video, $output; var scale = 0.25; var initialize = function() { $output = $(\"#output\"); video = $(\"#video\").get(0); $(\"#capture\").click(captureImage); }; var captureImage = function() { var canvas = document.createElement(\"canvas\"); canvas.width = video.videoWidth * scale; canvas.height = video.videoHeight * scale; canvas.getContext('2d') .drawImage(video, 0, 0, canvas.width, canvas.height); var img = document.createElement(\"img\"); img.src = canvas.toDataURL('image/png'); $output.prepend(img); }; $(initialize); }());"},{"title":"","date":"2020-03-27T09:56:43.197Z","updated":"2020-03-27T09:56:43.197Z","comments":true,"path":"demo/mosaic/index.html","permalink":"http://www.zsfmyz.top/demo/mosaic/index.html","excerpt":"","text":"Title #css_box { position: relative; touch-action: none; width: 100%; height: 500px; background: url('https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1567844929804&di=75928af77a3db7ff54cd4eab49361bc0&imgtype=0&src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fblog%2F201307%2F19%2F20130719082039_k2NHG.jpeg') no-repeat; background-size: contain; } #css_target { position: absolute; left: 0px; top: 0px; background: inherit; filter: blur(10px); touch-action: none; /* 继承父元素的background属性 */ } mosaic Demo 传送门 X: 0 px Y: 0 px var getCss = function(o, key) { return o.currentStyle ? o.currentStyle[key] : document.defaultView.getComputedStyle(o, false)[key]; }; // 拖拽 var startDrag = function(bar, target, callback) { var down = function(event) { // 兼容分辨率 bar.style.height = (parseInt(getCss(bar, \"width\")) * 636 / 900) + 'px'; target.style.backgroundSize = parseInt(getCss(bar, \"width\")) + 'px ' + (parseInt(getCss(bar, \"width\")) * 636 / 900) + 'px'; params.flag = true; if (!event) { event = window.event; bar.onselectstart = function() { return false; } } var e = event; params.currentX = e.clientX || e.changedTouches[0].clientX; params.currentY = e.clientY || e.changedTouches[0].clientY; }; var up = function() { params.flag = false; if (getCss(target, \"left\") !== \"auto\") { params.left = getCss(target, \"left\"); } if (getCss(target, \"top\") !== \"auto\") { params.top = getCss(target, \"top\"); } }; var move = function(event) { var e = event ? event : window.event; if (params.flag) { var nowX = e.clientX || e.changedTouches[0].clientX, nowY = e.clientY || e.changedTouches[0].clientY; var disX = nowX - params.currentX, disY = nowY - params.currentY; if ((parseInt(params.left) + disX) > maxX) { resX = maxX; } else if ((parseInt(params.left) + disX) < 0) { resX = 0; } else { resX = parseInt(params.left) + disX; } if ((parseInt(params.top) + disY) > maxY) { resY = maxY; } else if ((parseInt(params.top) + disY) < 0) { resY = 0; } else { resY = parseInt(params.top) + disY; } target.style.left = resX + 'px' target.style.top = resY + 'px' if (typeof callback == \"function\") { callback(resX, resY); } if (event.preventDefault) { event.preventDefault(); } return false; } } var resX = 0, resY = 0; var params = { left: 0, top: 0, currentX: 0, currentY: 0, flag: false }; if (getCss(target, \"left\") !== \"auto\") { params.left = getCss(target, \"left\"); } if (getCss(target, \"top\") !== \"auto\") { params.top = getCss(target, \"top\"); } if ((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) { console.log(\"mobile\"); target.style.width = '100px'; target.style.height = '100px'; maxX = parseInt(getCss(bar, \"width\")) - parseInt(getCss(target, \"width\")); maxY = parseInt(getCss(bar, \"height\")) - parseInt(getCss(target, \"height\")); target.ontouchstart = down document.ontouchend = up document.ontouchmove = move } else { console.log(\"pc\"); target.style.width = '150px'; target.style.height = '150px'; maxX = parseInt(getCss(bar, \"width\")) - parseInt(getCss(target, \"width\")); maxY = parseInt(getCss(bar, \"height\")) - parseInt(getCss(target, \"height\")); target.onmousedown = down document.onmouseup = up document.onmousemove = move } }; $(document).ready(function() { var bar = document.getElementById(\"css_box\"); var target = document.getElementById(\"css_target\"); var p_img = document.getElementById(\"position_img\"); // 兼容分辨率 bar.style.height = (parseInt(getCss(bar, \"width\")) * 636 / 900) + 'px'; target.style.backgroundSize = parseInt(getCss(bar, \"width\")) + 'px ' + (parseInt(getCss(bar, \"width\")) * 636 / 900) + 'px'; startDrag(bar, target, function(x, y) { target.style.backgroundPosition = (-1 * x) + \"px \" + (-1 * y) + \"px\"; p_img.innerText = \"X: \" + target.style.left + \" Y: \" + target.style.top; }); })"},{"title":"","date":"2020-03-27T09:56:43.197Z","updated":"2020-03-27T09:56:43.197Z","comments":true,"path":"demo/font/index.html","permalink":"http://www.zsfmyz.top/demo/font/index.html","excerpt":"","text":".demo { max-width: 600px; margin: 10px auto; font-family: sans-serif; } .table { width: 100%; line-height: 21px; table-layout: fixed; border-spacing: 0; border-collapse: collapse; border: 1px solid #ccc; font-size: 16px; } .table thead td, .table th { line-height: 20px; background-color: #f7f9fa; text-align: left; margin: 0; } .table tbody td { background-color: #fff; border-bottom: 1px solid #ededed; } .table td, .table th { padding: 14px 10px!important; } .table tr:last-child td { border-bottom: 0; } .table td p { display: inline-block; margin: 0 5px 0 0!important; } .red { color: red; } input:disabled, input:disabled+label { opacity: 0; } 字体中文名 字体英文名 字体应用 宋体 SimSun 中文名 英文名 浏览器默认 黑体 SimHei 中文名 英文名 浏览器默认 微软雅黑 Microsoft Yahei 中文名 英文名 浏览器默认 微软正黑体 Microsoft JhengHei 中文名 英文名 浏览器默认 楷体 KaiTi 中文名 英文名 浏览器默认 新宋体 NSimSun 中文名 英文名 浏览器默认 仿宋 FangSong 中文名 英文名 浏览器默认 字体中文名 字体英文名 字体应用 苹方 PingFang SC 中文名 英文名 浏览器默认 华文黑体 STHeiti 中文名 英文名 浏览器默认 华文楷体 STKaiti 中文名 英文名 浏览器默认 华文宋体 STSong 中文名 英文名 浏览器默认 华文仿宋 STFangsong 中文名 英文名 浏览器默认 华文中宋 STZhongsong 中文名 英文名 浏览器默认 华文琥珀 STHupo 中文名 英文名 浏览器默认 华文新魏 STXinwei 中文名 英文名 浏览器默认 华文隶书 STLiti 中文名 英文名 浏览器默认 华文行楷 STXingkai 中文名 英文名 浏览器默认 冬青黑体简 Hiragino Sans GB 中文名 英文名 浏览器默认 兰亭黑-简 Lantinghei SC 中文名 英文名 浏览器默认 翩翩体-简 Hanzipen SC 中文名 英文名 浏览器默认 手札体-简 Hannotate SC 中文名 英文名 浏览器默认 宋体-简 Songti SC 中文名 英文名 浏览器默认 娃娃体-简 Wawati SC 中文名 英文名 浏览器默认 魏碑-简 Weibei SC 中文名 英文名 浏览器默认 行楷-简 Xingkai SC 中文名 英文名 浏览器默认 雅痞-简 Yapi SC 中文名 英文名 浏览器默认 圆体-简 Yuanti SC 中文名 英文名 浏览器默认 字体中文名 字体英文名 字体应用 幼圆 YouYuan 中文名 英文名 浏览器默认 隶书 LiSu 中文名 英文名 浏览器默认 华文细黑 STXihei 中文名 英文名 浏览器默认 华文楷体 STKaiti 中文名 英文名 浏览器默认 华文宋体 STSong 中文名 英文名 浏览器默认 华文仿宋 STFangsong 中文名 英文名 浏览器默认 华文中宋 STZhongsong 中文名 英文名 浏览器默认 华文彩云 STCaiyun 中文名 英文名 浏览器默认 华文琥珀 STHupo 中文名 英文名 浏览器默认 华文新魏 STXinwei 中文名 英文名 浏览器默认 华文隶书 STLiti 中文名 英文名 浏览器默认 华文行楷 STXingkai 中文名 英文名 浏览器默认 方正舒体 FZShuTi 中文名 英文名 浏览器默认 方正姚体 FZYaoti 中文名 英文名 浏览器默认 字体中文名 字体英文名 字体应用 思源黑体 Source Han Sans CN 中文名 英文名 浏览器默认 思源宋体 Source Han Serif SC 中文名 英文名 浏览器默认 文泉驿微米黑 WenQuanYi Micro Hei 中文名 英文名 浏览器默认 字体中文名 字体英文名 字体应用 汉仪旗黑 HYQihei 40S 中文名 英文名 浏览器默认 汉仪旗黑 HYQihei 50S 中文名 英文名 浏览器默认 汉仪旗黑 HYQihei 60S 中文名 英文名 浏览器默认 汉仪大宋简 HYDaSongJ 中文名 英文名 浏览器默认 汉仪楷体 HYKaiti 中文名 英文名 浏览器默认 汉仪家书简 HYJiaShuJ 中文名 英文名 浏览器默认 汉仪PP体简 HYPPTiJ 中文名 英文名 浏览器默认 汉仪乐喵体简 HYLeMiaoTi 中文名 英文名 浏览器默认 汉仪小麦体 HYXiaoMaiTiJ 中文名 英文名 浏览器默认 汉仪程行体 HYChengXingJ 中文名 英文名 浏览器默认 汉仪黑荔枝 HYHeiLiZhiTiJ 中文名 英文名 浏览器默认 汉仪雅酷黑W HYYaKuHeiW 中文名 英文名 浏览器默认 汉仪大黑简 HYDaHeiJ 中文名 英文名 浏览器默认 汉仪尚魏手书W HYShangWeiShouShuW 中文名 英文名 浏览器默认 字体中文名 字体英文名 字体应用 方正粗雅宋简体 FZYaSongS-B-GB 中文名 英文名 浏览器默认 方正报宋简体 FZBaoSong-Z04S 中文名 英文名 浏览器默认 方正粗圆简体 FZCuYuan-M03S 中文名 英文名 浏览器默认 方正大标宋简体 FZDaBiaoSong-B06S 中文名 英文名 浏览器默认 方正大黑简体 FZDaHei-B02S 中文名 英文名 浏览器默认 方正仿宋简体 FZFangSong-Z02S 中文名 英文名 浏览器默认 方正黑体简体 FZHei-B01S 中文名 英文名 浏览器默认 方正琥珀简体 FZHuPo-M04S 中文名 英文名 浏览器默认 方正楷体简体 FZKai-Z03S 中文名 英文名 浏览器默认 方正隶变简体 FZLiBian-S02S 中文名 英文名 浏览器默认 方正隶书简体 FZLiShu-S01S 中文名 英文名 浏览器默认 方正美黑简体 FZMeiHei-M07S 中文名 英文名 浏览器默认 方正书宋简体 FZShuSong-Z01S 中文名 英文名 浏览器默认 方正舒体简体 FZShuTi-S05S 中文名 英文名 浏览器默认 方正水柱简体 FZShuiZhu-M08S 中文名 英文名 浏览器默认 方正宋黑简体 FZSongHei-B07S 中文名 英文名 浏览器默认 方正宋三简体 FZSong 中文名 英文名 浏览器默认 方正魏碑简体 FZWeiBei-S03S 中文名 英文名 浏览器默认 方正细等线简体 FZXiDengXian-Z06S 中文名 英文名 浏览器默认 方正细黑一简体 FZXiHei I-Z08S 中文名 英文名 浏览器默认 方正细圆简体 FZXiYuan-M01S 中文名 英文名 浏览器默认 方正小标宋简体 FZXiaoBiaoSong-B05S 中文名 英文名 浏览器默认 方正行楷简体 FZXingKai-S04S 中文名 英文名 浏览器默认 方正姚体简体 FZYaoTi-M06S 中文名 英文名 浏览器默认 方正中等线简体 FZZhongDengXian-Z07S 中文名 英文名 浏览器默认 方正准圆简体 FZZhunYuan-M02S 中文名 英文名 浏览器默认 方正综艺简体 FZZongYi-M05S 中文名 英文名 浏览器默认 方正彩云简体 FZCaiYun-M09S 中文名 英文名 浏览器默认 方正隶二简体 FZLiShu II-S06S 中文名 英文名 浏览器默认 方正康体简体 FZKangTi-S07S 中文名 英文名 浏览器默认 方正超粗黑简体 FZChaoCuHei-M10S 中文名 英文名 浏览器默认 方正新报宋简体 FZNew BaoSong-Z12S 中文名 英文名 浏览器默认 方正新舒体简体 FZNew ShuTi-S08S 中文名 英文名 浏览器默认 方正黄草简体 FZHuangCao-S09S 中文名 英文名 浏览器默认 方正少儿简体 FZShaoEr-M11S 中文名 英文名 浏览器默认 方正稚艺简体 FZZhiYi-M12S 中文名 英文名 浏览器默认 方正细珊瑚简体 FZXiShanHu-M13S 中文名 英文名 浏览器默认 方正粗宋简体 FZCuSong-B09S 中文名 英文名 浏览器默认 方正平和简体 FZPingHe-S11S 中文名 英文名 浏览器默认 方正华隶简体 FZHuaLi-M14S 中文名 英文名 浏览器默认 方正瘦金书简体 FZShouJinShu-S10S 中文名 英文名 浏览器默认 方正细倩简体 FZXiQian-M15S 中文名 英文名 浏览器默认 方正中倩简体 FZZhongQian-M16S 中文名 英文名 浏览器默认 方正粗倩简体 FZCuQian-M17S 中文名 英文名 浏览器默认 方正胖娃简体 FZPangWa-M18S 中文名 英文名 浏览器默认 方正宋一简体 FZSongYi-Z13S 中文名 英文名 浏览器默认 方正剪纸简体 FZJianZhi-M23S 中文名 英文名 浏览器默认 方正流行体简体 FZLiuXingTi-M26S 中文名 英文名 浏览器默认 方正祥隶简体 FZXiangLi-S17S 中文名 英文名 浏览器默认 方正粗活意简体 FZCuHuoYi-M25S 中文名 英文名 浏览器默认 方正胖头鱼简体 FZPangTouYu-M24S 中文名 英文名 浏览器默认 方正卡通简体 FZKaTong-M19S 中文名 英文名 浏览器默认 方正艺黑简体 FZYiHei-M20S 中文名 英文名 浏览器默认 方正水黑简体 FZShuiHei-M21S 中文名 英文名 浏览器默认 方正古隶简体 FZGuLi-S12S 中文名 英文名 浏览器默认 方正幼线简体 FZYouXian-Z09S 中文名 英文名 浏览器默认 方正启体简体 FZQiTi-S14S 中文名 英文名 浏览器默认 方正小篆体 FZXiaoZhuanTi-S13T 中文名 英文名 浏览器默认 方正硬笔楷书简体 FZYingBiKaiShu-S15S 中文名 英文名 浏览器默认 方正毡笔黑简体 FZZhanBiHei-M22S 中文名 英文名 浏览器默认 方正硬笔行书简体 FZYingBiXingShu-S16S 中文名 英文名 浏览器默认 var dataFont = { windows: [{ ch: '宋体', en: 'SimSun' }, { ch: '黑体', en: 'SimHei' }, { ch: '微软雅黑', en: 'Microsoft Yahei' }, { ch: '微软正黑体', en: 'Microsoft JhengHei' }, { ch: '楷体', en: 'KaiTi' }, { ch: '新宋体', en: 'NSimSun' }, { ch: '仿宋', en: 'FangSong' }], 'OS X': [{ ch: '苹方', en: 'PingFang SC' }, { ch: '华文黑体', en: 'STHeiti' }, { ch: '华文楷体', en: 'STKaiti' }, { ch: '华文宋体', en: 'STSong' }, { ch: '华文仿宋', en: 'STFangsong' }, { ch: '华文中宋', en: 'STZhongsong' }, { ch: '华文琥珀', en: 'STHupo' }, { ch: '华文新魏', en: 'STXinwei' }, { ch: '华文隶书', en: 'STLiti' }, { ch: '华文行楷', en: 'STXingkai' }, { ch: '冬青黑体简', en: 'Hiragino Sans GB' }, { ch: '兰亭黑-简', en: 'Lantinghei SC' }, { ch: '翩翩体-简', en: 'Hanzipen SC' }, { ch: '手札体-简', en: 'Hannotate SC' }, { ch: '宋体-简', en: 'Songti SC' }, { ch: '娃娃体-简', en: 'Wawati SC' }, { ch: '魏碑-简', en: 'Weibei SC' }, { ch: '行楷-简', en: 'Xingkai SC' }, { ch: '雅痞-简', en: 'Yapi SC' }, { ch: '圆体-简', en: 'Yuanti SC' }], 'office': [{ ch: '幼圆', en: 'YouYuan' }, { ch: '隶书', en: 'LiSu' }, { ch: '华文细黑', en: 'STXihei' }, { ch: '华文楷体', en: 'STKaiti' }, { ch: '华文宋体', en: 'STSong' }, { ch: '华文仿宋', en: 'STFangsong' }, { ch: '华文中宋', en: 'STZhongsong' }, { ch: '华文彩云', en: 'STCaiyun' }, { ch: '华文琥珀', en: 'STHupo' }, { ch: '华文新魏', en: 'STXinwei' }, { ch: '华文隶书', en: 'STLiti' }, { ch: '华文行楷', en: 'STXingkai' }, { ch: '方正舒体', en: 'FZShuTi' }, { ch: '方正姚体', en: 'FZYaoti' }], 'open': [{ ch: '思源黑体', en: 'Source Han Sans CN' }, { ch: '思源宋体', en: 'Source Han Serif SC' }, { ch: '文泉驿微米黑', en: 'WenQuanYi Micro Hei' }], 'hanyi': [{ ch: '汉仪旗黑', en: 'HYQihei 40S' }, { ch: '汉仪旗黑', en: 'HYQihei 50S' }, { ch: '汉仪旗黑', en: 'HYQihei 60S' }, { ch: '汉仪大宋简', en: 'HYDaSongJ' }, { ch: '汉仪楷体', en: 'HYKaiti' }, { ch: '汉仪家书简', en: 'HYJiaShuJ' }, { ch: '汉仪PP体简', en: 'HYPPTiJ' }, { ch: '汉仪乐喵体简', en: 'HYLeMiaoTi' }, { ch: '汉仪小麦体', en: 'HYXiaoMaiTiJ' }, { ch: '汉仪程行体', en: 'HYChengXingJ' }, { ch: '汉仪黑荔枝', en: 'HYHeiLiZhiTiJ' }, { ch: '汉仪雅酷黑W', en: 'HYYaKuHeiW' }, { ch: '汉仪大黑简', en: 'HYDaHeiJ' }, { ch: '汉仪尚魏手书W', en: 'HYShangWeiShouShuW' }], 'fangzheng': [{ \"ch\": \"方正粗雅宋简体\", \"en\": \"FZYaSongS-B-GB\" }, { \"ch\": \"方正报宋简体\", \"en\": \"FZBaoSong-Z04S\" }, { \"ch\": \"方正粗圆简体\", \"en\": \"FZCuYuan-M03S\" }, { \"ch\": \"方正大标宋简体\", \"en\": \"FZDaBiaoSong-B06S\" }, { \"ch\": \"方正大黑简体\", \"en\": \"FZDaHei-B02S\" }, { \"ch\": \"方正仿宋简体\", \"en\": \"FZFangSong-Z02S\" }, { \"ch\": \"方正黑体简体\", \"en\": \"FZHei-B01S\" }, { \"ch\": \"方正琥珀简体\", \"en\": \"FZHuPo-M04S\" }, { \"ch\": \"方正楷体简体\", \"en\": \"FZKai-Z03S\" }, { \"ch\": \"方正隶变简体\", \"en\": \"FZLiBian-S02S\" }, { \"ch\": \"方正隶书简体\", \"en\": \"FZLiShu-S01S\" }, { \"ch\": \"方正美黑简体\", \"en\": \"FZMeiHei-M07S\" }, { \"ch\": \"方正书宋简体\", \"en\": \"FZShuSong-Z01S\" }, { \"ch\": \"方正舒体简体\", \"en\": \"FZShuTi-S05S\" }, { \"ch\": \"方正水柱简体\", \"en\": \"FZShuiZhu-M08S\" }, { \"ch\": \"方正宋黑简体\", \"en\": \"FZSongHei-B07S\" }, { \"ch\": \"方正宋三简体\", \"en\": \"FZSong\" }, { \"ch\": \"方正魏碑简体\", \"en\": \"FZWeiBei-S03S\" }, { \"ch\": \"方正细等线简体\", \"en\": \"FZXiDengXian-Z06S\" }, { \"ch\": \"方正细黑一简体\", \"en\": \"FZXiHei I-Z08S\" }, { \"ch\": \"方正细圆简体\", \"en\": \"FZXiYuan-M01S\" }, { \"ch\": \"方正小标宋简体\", \"en\": \"FZXiaoBiaoSong-B05S\" }, { \"ch\": \"方正行楷简体\", \"en\": \"FZXingKai-S04S\" }, { \"ch\": \"方正姚体简体\", \"en\": \"FZYaoTi-M06S\" }, { \"ch\": \"方正中等线简体\", \"en\": \"FZZhongDengXian-Z07S\" }, { \"ch\": \"方正准圆简体\", \"en\": \"FZZhunYuan-M02S\" }, { \"ch\": \"方正综艺简体\", \"en\": \"FZZongYi-M05S\" }, { \"ch\": \"方正彩云简体\", \"en\": \"FZCaiYun-M09S\" }, { \"ch\": \"方正隶二简体\", \"en\": \"FZLiShu II-S06S\" }, { \"ch\": \"方正康体简体\", \"en\": \"FZKangTi-S07S\" }, { \"ch\": \"方正超粗黑简体\", \"en\": \"FZChaoCuHei-M10S\" }, { \"ch\": \"方正新报宋简体\", \"en\": \"FZNew BaoSong-Z12S\" }, { \"ch\": \"方正新舒体简体\", \"en\": \"FZNew ShuTi-S08S\" }, { \"ch\": \"方正黄草简体\", \"en\": \"FZHuangCao-S09S\" }, { \"ch\": \"方正少儿简体\", \"en\": \"FZShaoEr-M11S\" }, { \"ch\": \"方正稚艺简体\", \"en\": \"FZZhiYi-M12S\" }, { \"ch\": \"方正细珊瑚简体\", \"en\": \"FZXiShanHu-M13S\" }, { \"ch\": \"方正粗宋简体\", \"en\": \"FZCuSong-B09S\" }, { \"ch\": \"方正平和简体\", \"en\": \"FZPingHe-S11S\" }, { \"ch\": \"方正华隶简体\", \"en\": \"FZHuaLi-M14S\" }, { \"ch\": \"方正瘦金书简体\", \"en\": \"FZShouJinShu-S10S\" }, { \"ch\": \"方正细倩简体\", \"en\": \"FZXiQian-M15S\" }, { \"ch\": \"方正中倩简体\", \"en\": \"FZZhongQian-M16S\" }, { \"ch\": \"方正粗倩简体\", \"en\": \"FZCuQian-M17S\" }, { \"ch\": \"方正胖娃简体\", \"en\": \"FZPangWa-M18S\" }, { \"ch\": \"方正宋一简体\", \"en\": \"FZSongYi-Z13S\" }, { \"ch\": \"方正剪纸简体\", \"en\": \"FZJianZhi-M23S\" }, { \"ch\": \"方正流行体简体\", \"en\": \"FZLiuXingTi-M26S\" }, { \"ch\": \"方正祥隶简体\", \"en\": \"FZXiangLi-S17S\" }, { \"ch\": \"方正粗活意简体\", \"en\": \"FZCuHuoYi-M25S\" }, { \"ch\": \"方正胖头鱼简体\", \"en\": \"FZPangTouYu-M24S\" }, /*{\"ch\":\"方正铁筋隶书简体\",\"en\":\"FZTieJinLiShu-Z14S\"},{\"ch\":\"方正北魏楷书简体\",\"en\":\"FZBeiWeiKaiShu-Z15S\"},*/ { \"ch\": \"方正卡通简体\", \"en\": \"FZKaTong-M19S\" }, { \"ch\": \"方正艺黑简体\", \"en\": \"FZYiHei-M20S\" }, { \"ch\": \"方正水黑简体\", \"en\": \"FZShuiHei-M21S\" }, { \"ch\": \"方正古隶简体\", \"en\": \"FZGuLi-S12S\" }, { \"ch\": \"方正幼线简体\", \"en\": \"FZYouXian-Z09S\" }, { \"ch\": \"方正启体简体\", \"en\": \"FZQiTi-S14S\" }, { \"ch\": \"方正小篆体\", \"en\": \"FZXiaoZhuanTi-S13T\" }, { \"ch\": \"方正硬笔楷书简体\", \"en\": \"FZYingBiKaiShu-S15S\" }, { \"ch\": \"方正毡笔黑简体\", \"en\": \"FZZhanBiHei-M22S\" }, { \"ch\": \"方正硬笔行书简体\", \"en\": \"FZYingBiXingShu-S16S\" }] }; // 系统默认字体 var rootFontFamily = (document.documentElement.currentStyle ? document.documentElement.currentStyle : window.getComputedStyle(document.documentElement)).fontFamily; var eleTables = document.getElementsByTagName('table'); var lenTables = eleTables.length; for (var index = 0; index < lenTables; index++) { var typeFont = eleTables[index].getAttribute('data-type'); var arrDataFont = dataFont[typeFont]; if (arrDataFont && arrDataFont.length) { var html = ''; for (var start = 0; start < arrDataFont.length; start++) { var name = typeFont + start; var fontEn = arrDataFont[start].en, fontCh = arrDataFont[start].ch; // 是否标记为默认字体的处理 var htmlFontEn = fontEn, htmlFontCh = fontCh; if (fontEn.toLowerCase() === rootFontFamily.toLowerCase()) { htmlFontEn += '（浏览器默认）'; } else if (fontCh.toLowerCase() === rootFontFamily.toLowerCase()) { htmlFontCh += '（浏览器默认）'; } html = html + '' + htmlFontCh + '' + htmlFontEn + '' + '中文名' + '英文名' + '浏览器默认' + ''; } eleTables[index].getElementsByTagName('tbody')[0].innerHTML = html; // 复选框事件 eleTables[index].onclick = function(event) { event = event || window.event; var target = event.target; if (target && target.type == 'radio') { target.parentNode.parentNode.parentNode.style.fontFamily = target.value; } }; } } // JavaScript Document"}],"posts":[{"title":"JavaScript：leetcode_974. 和可被 K 整除的子数组（前序和 + 同余定理）","slug":"JavaScript：leetcode_974. 和可被 K 整除的子数组（前序和 + 同余定理）","date":"2020-05-27T14:59:13.000Z","updated":"2020-05-28T01:58:49.148Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_974. 和可被 K 整除的子数组（前序和 + 同余定理）/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_974. 和可被 K 整除的子数组（前序和 + 同余定理）/","excerpt":"题目说明123456789101112131415161718给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。 示例：输入：A = [4,5,0,-2,-3,1], K = 5输出：7解释：有 7 个子数组满足其元素之和可被 K = 5 整除：[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3] 提示：1 &lt;= A.length &lt;= 30000-10000 &lt;= A[i] &lt;= 100002 &lt;= K &lt;= 10000","text":"题目说明123456789101112131415161718给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。 示例：输入：A = [4,5,0,-2,-3,1], K = 5输出：7解释：有 7 个子数组满足其元素之和可被 K = 5 整除：[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3] 提示：1 &lt;= A.length &lt;= 30000-10000 &lt;= A[i] &lt;= 100002 &lt;= K &lt;= 10000 解题思路一(暴力枚举，O（n^3）) 暴力枚举所有的前序和，判断对K取模是否为0，为0则结果+1代码实现一123456789101112131415161718/** * @param &#123;number[]&#125; A * @param &#123;number&#125; K * @return &#123;number&#125; */var subarraysDivByK = function(A, K) &#123; let res = 0; for (let i = 0; i &lt; A.length; i++) &#123; let prev = 0; for (let j = i; j &gt;= 0; j--) &#123; prev += A[j]; if (prev % K === 0) &#123; res++ &#125; &#125; &#125; return res;&#125;; 解题思路二(暴力枚举优化,O（n^2）) 将两层for循环中的求前序和操作，提前求。 那么我们求i之前的所有前序和就变成了，求p[i] - p[j] (j的范围是 0 ~ i-1) 判断p[i] - p[j]对K去模是否为0，为0则结果+1代码实现二1234567891011121314151617181920212223/** * @param &#123;number[]&#125; A * @param &#123;number&#125; K * @return &#123;number&#125; */var subarraysDivByK = function(A, K) &#123; let res = 0; let p = new Array(A.length); for (let i = 0; i &lt; A.length; i++) &#123; p[i] = A.slice(0, i+1).reduce((sum, item, key, arr) =&gt; &#123; return sum += item; &#125;, 0); for( let j = i - 1; j &gt;= 0; j--) &#123; if((p[i] - p[j]) % K === 0) &#123; res++ &#125; &#125; if(p[i] % K === 0) &#123; res++ &#125; &#125; return res;&#125;; 解题思路三(同余定理，O（n）) 先理解一个数学问题， 假设a = 8，b = 13, 同时mod 5，那么 a % 5 == 3，b % 5 == 3，即a % 5 == b % 5则(b - a) % 5 == 0，即对同一数取模相同的两个值，其差值可整除该数。 将两层for循环中的求前序和操作，提前求前序和序列p。 得到所有的前序和p之后，理解说明若 p[i] % K === p[j] % K 则p[i] - p[j] % 5 === 0那么j到i就是我们求的一个目标子序列。 所以我们建立一个hash，用来存储p序列取模之后的值。 hash的键值范围是（0 ~ K -1）因为是对K取余，所以值只可能出现在该范围中。 由于该hash的标记跟数组下标正好对应，所以hash就声明为一个数组。 以示例为例1. 输入：`A = [4,5,0,-2,-3,1], K = 5` 2. p序列为 `[4, 9, 9, 7, 4, 5]` 取模之后的序列为`[4, 4, 4, 2, 4, 0]` 记录到hash中 3. hash = `[1, 0, 1, 0, 4]` 4. 接下来就是排列组合的问题了，将hash列表中 `&gt; 1` 的值进行计算 `n * ( n - 1 ) / 2` 取和 5. 最后再加上`hash[0]`的个数，因为`hash[0]`标记的是取模之后为`0`的值的个数，本身就属于目标子序列。 第五步我们是先求出hash表才计算个数，我们也可以在完善hash的同时计算。 比如p序列为 [4, 9, 9, 7, 4, 5] 去模的过程中统计。 计算第1个取模，模值为4，res += hash[4], hash[4]++,由于4是第1次出现所以目前res+=0 计算第2个取模，模值为4，res += hash[4], hash[4]++,由于4是第2次出现所以目前res+=1，子序列下标范围是[0,1] 计算第3个取模，模值为4，res += hash[4], hash[4]++,由于4是第3次出现所以目前res+=2，子序列下标范围是[0,1,2]，[1,2]因为4出现3次，所以第3个4可以和前两个组合。 依次类推。 代码实现三123456789101112131415161718/** * @param &#123;number[]&#125; A * @param &#123;number&#125; K * @return &#123;number&#125; */var subarraysDivByK = function(A, K) &#123; let hash = new Array(K).fill(0); let sum = 0; let res = 0; for (let i = 0; i &lt; A.length; i++) &#123; sum += A[i]; let key = sum % K; key = key &lt; 0 ? (key + K) : key; //处理负数的情况, (3 - (-2)) % 5 === 0 res += hash[key]; hash[key]++; &#125; return res + hash [0];&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"JavaScript：leetcode_146. LRU缓存机制（vue的keep-Live所使用的缓存机制）","slug":"JavaScript：leetcode_146. LRU缓存机制（vue的keep-live所使用的缓存机制）","date":"2020-05-26T09:59:13.000Z","updated":"2020-05-28T01:59:39.936Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_146. LRU缓存机制（vue的keep-live所使用的缓存机制）/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_146. LRU缓存机制（vue的keep-live所使用的缓存机制）/","excerpt":"题目说明123456789运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。 进阶:你是否可以在 O(1) 时间复杂度内完成这两种操作？","text":"题目说明123456789运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。 进阶:你是否可以在 O(1) 时间复杂度内完成这两种操作？ 解题思路一 LRU缓存机制，可以自行百度一下。 特点1，hash表读取数据 特点2，存在一个keys序列，代表缓存的所有key，顺序按照最近的活跃度来排序，比如你刚刚用过key为1 的值，那么1就会排在keys序列的第一位。当缓存超出的时候，会优先删除keys的末尾。 所以我们主要维护了一个hash，js中就是一个对象，用来存数据。一个序列也就是一个数组存keys。 get：如果将get的key，位置置换到首位。并返回数据。 put：将put设置的值的key，放在keys序列首位，判断是否超出，超出则删除最后一位。代码实现一1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * @param &#123;number&#125; capacity */var LRUCache = function(capacity) &#123; this.obj = &#123;&#125;; this.objKeys = []; this.limit = capacity;&#125;;/** * @param &#123;number&#125; key * @return &#123;number&#125; */LRUCache.prototype.get = function(key) &#123; if (this.obj[key]) &#123; this.objKeys.splice(this.objKeys.indexOf(key), 1); this.objKeys.unshift(key); return this.obj[key]; &#125; else &#123; return -1 &#125;&#125;;/** * @param &#123;number&#125; key * @param &#123;number&#125; value * @return &#123;void&#125; */LRUCache.prototype.put = function(key, value) &#123; this.obj[key] &amp;&amp; this.objKeys.splice(this.objKeys.indexOf(key), 1); this.objKeys.unshift(key); this.obj[key] = value; if (this.objKeys.length &gt; this.limit) &#123; delete this.obj[this.objKeys[this.limit]]; this.objKeys.length -= 1; &#125;&#125;;/** * Your LRUCache object will be instantiated and called as such: * var obj = new LRUCache(capacity) * var param_1 = obj.get(key) * obj.put(key,value) */","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"JavaScript：leetcode_287. 寻找重复数（二分法）","slug":"JavaScript：leetcode_287. 寻找重复数（二分法）","date":"2020-05-26T09:59:13.000Z","updated":"2020-05-28T01:59:10.200Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_287. 寻找重复数（二分法）/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_287. 寻找重复数（二分法）/","excerpt":"题目说明12345678910111213141516给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。示例 1:输入: [1,3,4,2,2]输出: 2示例 2:输入: [3,1,3,4,2]输出: 3说明：不能更改原数组（假设数组是只读的）。只能使用额外的 O(1) 的空间。时间复杂度小于 O(n2) 。数组中只有一个重复的数字，但它可能不止重复出现一次。","text":"题目说明12345678910111213141516给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。示例 1:输入: [1,3,4,2,2]输出: 2示例 2:输入: [3,1,3,4,2]输出: 3说明：不能更改原数组（假设数组是只读的）。只能使用额外的 O(1) 的空间。时间复杂度小于 O(n2) 。数组中只有一个重复的数字，但它可能不止重复出现一次。 解题思路一 先放一种前端比较好理解的。 indexOf会返回数组中该元素出现的第一次的位置 我们利用这个特性，当indexOf的值跟目前的index不一致时，说明之前出现过一次。返回即可代码实现一1234567891011121314/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var findDuplicate = function(nums) &#123; let res = 0; nums.map((item, key, arr) =&gt; &#123; if (arr.indexOf(item) !== key) &#123; res = item; &#125; &#125;); return res;&#125;; 解题思路二（二分法） 首先看题意：数字范围为1 ~ n，那其实就是在1~n的范围内找到哪个元素在nums中重复存在。 so，1 ~ n的序列。是有序的，可以用二分找了，以1~n为基础，以nums为条件判断的元素。 那怎么找呢。比如我们找到中间节点mid，判断nums数组中比mid小的有多少个（prev）， 按正常来讲比如mid为3，那么从1到n &lt;= 3的数量应就是[1,2,3],一共是3个啦。 所以如果重复的元素比3小的话，那么3的prev就变成4以上了，因为[1,2,3]就变成了[1,1,2,3]或者[1,2,2,3],等等， 所以我们就可以通过prev的大小来锁定重复元素的范围是在1 ~ mid还是在mid+1 ~ n； 接下来就很简单了。就是一个二分法了。代码实现一12345678910111213141516171819202122232425262728293031/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var findDuplicate = function(nums) &#123; let res = null; function find(start, end, nums) &#123; if (end == start) &#123; //找到最终目标了 return void ( res = end ); &#125; let mid = start + ((end - start) &gt;&gt; 1); let prev = 0; for (let i = 0; i &lt; nums.length; i++) &#123; if (nums[i] &lt;= mid) &#123; prev++; &#125; &#125; if (prev &gt; mid) &#123; find(start, mid, nums) &#125; else &#123; find(mid + 1, end, nums) &#125; &#125; find(1, nums.length - 1, nums); return res;&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"JavaScript：leetcode_105. 从前序与中序遍历序列构造二叉树（前序找根，中序分左右，递归）","slug":"JavaScript：leetcode_105. 从前序与中序遍历序列构造二叉树（前序找根，中序分左右，递归）","date":"2020-05-22T09:59:13.000Z","updated":"2020-05-28T01:59:50.414Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_105. 从前序与中序遍历序列构造二叉树（前序找根，中序分左右，递归）/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_105. 从前序与中序遍历序列构造二叉树（前序找根，中序分左右，递归）/","excerpt":"题目说明12345678910111213141516根据一棵树的前序遍历与中序遍历构造二叉树。注意:你可以假设树中没有重复的元素。例如，给出前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]返回如下的二叉树： 3 / \\ 9 20 / \\ 15 7","text":"题目说明12345678910111213141516根据一棵树的前序遍历与中序遍历构造二叉树。注意:你可以假设树中没有重复的元素。例如，给出前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]返回如下的二叉树： 3 / \\ 9 20 / \\ 15 7 解题思路一 前序找根，中序分左右，递归即可。 根为前序第一个值。let root = new TreeNode(preorder[0]); 找到根在中序中的位置let rootIndex = inorder.indexOf(root.val); 左右分开。left为左中序，right为右中序，preLeft为左前序，preRight为右 1234let left = inorder.slice(0, rootIndex); let right = inorder.slice(rootIndex + 1, inorder.length); let preLeft = preorder.slice(1, left.length + 1); let preRight = preorder.slice(left.length + 1); 找到左右各自的前中序列。即可递归找根了。 代码实现一123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;number[]&#125; preorder * @param &#123;number[]&#125; inorder * @return &#123;TreeNode&#125; */var buildTree = function buildTree(preorder, inorder) &#123; if (preorder.length == 0) &#123; return null; &#125; let root = new TreeNode(preorder[0]); if (preorder.length == 1) &#123; return root; &#125; let rootIndex = inorder.indexOf(root.val); let left = inorder.slice(0, rootIndex); let right = inorder.slice(rootIndex + 1, inorder.length); let preLeft = preorder.slice(1, left.length + 1); let preRight = preorder.slice(left.length + 1); left.length &amp;&amp; (root.left = buildTree(preLeft, left)); right.length &amp;&amp; (root.right = buildTree(preRight, right)); return root;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"JavaScript：leetcode_5. 最长回文子串","slug":"JavaScript：leetcode_5. 最长回文子串","date":"2020-05-22T09:59:13.000Z","updated":"2020-05-28T02:00:51.494Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_5. 最长回文子串/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_5. 最长回文子串/","excerpt":"题目说明123456789101112给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。示例 1：输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。示例 2：输入: &quot;cbbd&quot;输出: &quot;bb&quot;","text":"题目说明123456789101112给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。示例 1：输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。示例 2：输入: &quot;cbbd&quot;输出: &quot;bb&quot; 解题思路一 遍历字符串，从i开始向左右扩展对比 i--, i++ 是否相同，过程求出最大值。 以上仅检测奇数回文即：&quot;cbabc&quot;而不能检测cbbc 对原字符串进行改造例如&quot;cbbc&quot; =&gt; &quot;c#b#b#c&quot;这样就可以以#为中心对比了。（奇数长度例如&quot;cbabc&quot; =&gt; c#b#a#b#c并不会被#影响，所以不用担心破坏了对比结构。） 对比过程中要注意不要让#b#把b#b这样的情况给顶替了。相同长度时要取末尾为字母的。 代码实现一12345678910111213141516171819202122232425262728/** * @param &#123;string&#125; s * @return &#123;string&#125; */var longestPalindrome = function(s) &#123; s = s.split('').join('#'); let max = 0; let start = 0; let end = 0; for (let i = 0; i &lt; s.length; i++) &#123; let left = i - 1; let right = i + 1; while(left &gt;= 0 &amp;&amp; right &lt; s.length) &#123; if (s.charAt(left) === s.charAt(right)) &#123; if (max &lt; (right - left) &amp;&amp; s.charAt(right) !== '#') &#123; max = right - left; start = left; end = right; &#125; right++; left--; &#125; else &#123; break; &#125; &#125; &#125; return s.slice(start, end + 1).split('#').join('')&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"JavaScript：leecode_1371. 每个元音包含偶数次的最长子字符串（前缀和）","slug":"JavaScript：leecode_1371. 每个元音包含偶数次的最长子字符串（前缀和）","date":"2020-05-21T09:59:13.000Z","updated":"2020-05-28T02:01:03.395Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leecode_1371. 每个元音包含偶数次的最长子字符串（前缀和）/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leecode_1371. 每个元音包含偶数次的最长子字符串（前缀和）/","excerpt":"题目说明12345678910111213141516171819202122232425给你一个字符串 s ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 &apos;a&apos;，&apos;e&apos;，&apos;i&apos;，&apos;o&apos;，&apos;u&apos; ，在子字符串中都恰好出现了偶数次。 示例 1：输入：s = &quot;eleetminicoworoep&quot;输出：13解释：最长子字符串是 &quot;leetminicowor&quot; ，它包含 e，i，o 各 2 个，以及 0 个 a，u 。示例 2：输入：s = &quot;leetcodeisgreat&quot;输出：5解释：最长子字符串是 &quot;leetc&quot; ，其中包含 2 个 e 。示例 3：输入：s = &quot;bcbcbc&quot;输出：6解释：这个示例中，字符串 &quot;bcbcbc&quot; 本身就是最长的，因为所有的元音 a，e，i，o，u 都出现了 0 次。 提示：1 &lt;= s.length &lt;= 5 x 10^5s 只包含小写英文字母。","text":"题目说明12345678910111213141516171819202122232425给你一个字符串 s ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 &apos;a&apos;，&apos;e&apos;，&apos;i&apos;，&apos;o&apos;，&apos;u&apos; ，在子字符串中都恰好出现了偶数次。 示例 1：输入：s = &quot;eleetminicoworoep&quot;输出：13解释：最长子字符串是 &quot;leetminicowor&quot; ，它包含 e，i，o 各 2 个，以及 0 个 a，u 。示例 2：输入：s = &quot;leetcodeisgreat&quot;输出：5解释：最长子字符串是 &quot;leetc&quot; ，其中包含 2 个 e 。示例 3：输入：s = &quot;bcbcbc&quot;输出：6解释：这个示例中，字符串 &quot;bcbcbc&quot; 本身就是最长的，因为所有的元音 a，e，i，o，u 都出现了 0 次。 提示：1 &lt;= s.length &lt;= 5 x 10^5s 只包含小写英文字母。 解题思路一 首先要理解这个题。这道题明显还是跟前缀有关系的东西，毫无疑问肯定又需要用到动态规划保存状态。 我们先来看子字符串中的各元音字母的个数，题目呢，要求的是偶数次，那么我们的a，e，i，o，u的出现次数是不是可以转化为出现次数的奇偶性呢？即 nums % 2 === 1 是奇数次 nums % 2 === 0 是偶数次 那么我们的a，e，i，o，u的各自状态就只有两种情况啦，0 or 1，例如 12345'a': 0,'e': 0,'o': 1,'i': 0,'u': 0 那我们现在用二进制来表示一下它：00100， 那么类似于这样的表示有几种情况呢？ 2 x 2 x 2 x 2 x 2 = 32仅仅只有32种情况，就可以完全表示元音字母的所有状态了。那么我们声明一个长度为32的status数组，值都初始化为-1。 按照正常思维，符合条件的情况有两种子字符串，一是从头开始的，一个是从中间开始的。 从头开始的很容易理解（假设首位下标为0，i），只要从0到i，状态为00000就可以了。代表都是偶数次出现。 从中间开始的话（假设首位下标为j，i），是从j到i这个子字符串的状态为00000 那什么情况下子字符串的状态可以是00000呢？ 那当然是i，j各自的状态一致的时候，因为同状态互减才会为0，例如01000 - 01000 = 00000 so，01000在字串中是会出现多次的，因为2%2 == 0， 4%2===0状态也是会重复的，所以我们想求出这个状态之间的最大间距，就要记录该状态最早出现的下标。 好了，理解了这个状态之后，我们明确了我们要记录的值，记录该位置的状态下的最早下标。 我们是不是可以记录一下，从第1个字母开始到第i个字母之间的各元音状态呢？ 例如：&quot;eleetminicoworoep&quot; 对应的状态数组[01000,01000,00000,01000,01000,01000,01100...] i 为 0，1，3，4，5 的时候状态都一致，那么我们只需要记录status[8] = 0,取最小值即可。 所以status数组记录的是32种状态各自在字符串中最早出现的下标 最后我们遍历字符串，求出每一位的状态key(例如01000) ，根据这个key和下标i，我们去status里面找key的最小下标status[key]，然后用i - status[key]求出距离长度。若status[key]为-1，则将下标i赋值给status[key] = i 代码实现一123456789101112131415161718192021222324252627/** * @param &#123;string&#125; s * @return &#123;number&#125; */var findTheLongestSubstring = function(s) &#123; let hash = &#123; 'a': 0, 'e': 0, 'o': 0, 'i': 0, 'u': 0 &#125; let status = new Array(32).fill(-1); status[0] = 0; let max = 0; for (let i = 0; i &lt; s.length; i++) &#123; let key = 0; hash[s.charAt(i)] !== undefined ? hash[s.charAt(i)] = (hash[s.charAt(i)] + 1) % 2 : ''; key += hash['a'] + (hash['e'] &lt;&lt; 1) + (hash['i'] &lt;&lt; 2) + (hash['o'] &lt;&lt; 3) + (hash['u'] &lt;&lt; 4) if (status[key] === -1) &#123; status[key] = i + 1; &#125; else &#123; max = Math.max(max, i + 1 - status[key]) &#125; &#125; return max;&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"JavaScript：leetcode_680. 验证回文字符串 Ⅱ（双指针）","slug":"JavaScript：leetcode_680. 验证回文字符串 Ⅱ（双指针）","date":"2020-05-19T09:59:13.000Z","updated":"2020-05-28T01:58:52.137Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_680. 验证回文字符串 Ⅱ（双指针）/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_680. 验证回文字符串 Ⅱ（双指针）/","excerpt":"题目说明123456789101112131415给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。示例 1:输入: &quot;aba&quot;输出: True示例 2:输入: &quot;abca&quot;输出: True解释: 你可以删除c字符。注意:字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。","text":"题目说明123456789101112131415给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。示例 1:输入: &quot;aba&quot;输出: True示例 2:输入: &quot;abca&quot;输出: True解释: 你可以删除c字符。注意:字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。 解题思路一 回文字符串，字符串正序反序都一样。同样也是对称的。 正反指针，一个从头，一个从末尾，对比。 找到不同的位置，去掉该位置的值。（可能为i，也可能为length-1-i） 若两种情况中有一种是回文。那就返回true。否则返回false 找不到不同的值当然也返回true 代码实现一123456789101112131415161718192021/** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var validPalindrome = function(s) &#123; let sArr = s.split(''); for (let i = 0; i &lt;= (sArr.length &gt;&gt; 1); i++) &#123; if (sArr[i] !== sArr[sArr.length - i - 1]) &#123; let f = [...sArr]; f.splice(i,1); let f2 = [...sArr]; f2.splice(sArr.length - i - 1,1); if ((f+'') == ([...f].reverse()+'') || (f2 + '') == ([...f2].reverse() + '')) &#123; return true &#125; else &#123; return false &#125; &#125; &#125; return true&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"JavaScript：leetcode_152. 乘积最大子数组（动态规划）","slug":"JavaScript：leetcode_152. 乘积最大子数组（动态规划）","date":"2020-05-18T09:59:13.000Z","updated":"2020-05-28T01:59:36.282Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_152. 乘积最大子数组（动态规划）/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_152. 乘积最大子数组（动态规划）/","excerpt":"题目说明1234567891011给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。示例 1:输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。示例 2:输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。","text":"题目说明1234567891011给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。示例 1:输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。示例 2:输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 解题思路一 该题与之前所写的560.和为K的子数组很相似，解法也都是一样的。 依旧是对前缀进行操作。不同的是，我们这次不需要保留所有的结果，只需要保留本次结果的最大值nowMax 和最小值nowMin 。取min主要是为了复数的情况。 我们依赖于上一次的状态，求出本次的最大最小值。然后传入下一次状态。1. `nowMax = Math.max(res[0] * nums[i], res[1] * nums[i], nums[i]);` 2. `nowMin = Math.min(res[0] * nums[i], res[1] * nums[i], nums[i]);` 3. `res = [nowMax, nowMin ]` 在此过程中我们可以求出最大值max 代码实现一1234567891011121314151617181920/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var maxProduct = function(nums) &#123; if (!nums.length) &#123; return 0; &#125; let max = nums[0] let min = nums[0] let res = [nums[0], nums[0]]; for (let i = 1 ; i &lt; nums.length; i++) &#123; let nowMax = Math.max(res[0] * nums[i], res[1] * nums[i], nums[i]); let nowMin = Math.min(res[0] * nums[i], res[1] * nums[i], nums[i]); max = Math.max(nowMax, max); // min = Math.min(nowMin, min); res = [nowMax, nowMin]; &#125; return max;&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"JavaScript：leetcode_210. 课程表 II","slug":"JavaScript：leetcode_210. 课程表 II（BFS）","date":"2020-05-17T09:59:13.000Z","updated":"2020-05-28T01:59:20.314Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_210. 课程表 II（BFS）/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_210. 课程表 II（BFS）/","excerpt":"题目说明1234567891011121314151617181920212223242526272829现在你总共有 n 门课需要选，记为 0 到 n-1。在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。示例 1:输入: 2, [[1,0]] 输出: [0,1]解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。示例 2:输入: 4, [[1,0],[2,0],[3,1],[3,2]]输出: [0,1,2,3] or [0,2,1,3]解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。 因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。说明:输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。你可以假定输入的先决条件中没有重复的边。提示:这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。拓扑排序也可以通过 BFS 完成。","text":"题目说明1234567891011121314151617181920212223242526272829现在你总共有 n 门课需要选，记为 0 到 n-1。在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。示例 1:输入: 2, [[1,0]] 输出: [0,1]解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。示例 2:输入: 4, [[1,0],[2,0],[3,1],[3,2]]输出: [0,1,2,3] or [0,2,1,3]解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。 因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。说明:输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。你可以假定输入的先决条件中没有重复的边。提示:这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。拓扑排序也可以通过 BFS 完成。 解题思路一 首先要理解题意，该题的目的是要我们按依赖顺序排序。 二维数组中，首位表示一门课程，数组余下的值表示，学习该课程之前所要完成的。例如[3,1],[3,2] 表示，最后的序列，3要在2和1的后面 所以的我的做法是：以 4, [[1,0],[2,0],[3,1],[3,2]]为例 利用hash收集每门课程的前置课程：{1:[0], 2:[0], 3:[1, 2], 0:[]},[]表示该门课程不需要前序课程，这种课程就可以直接放入序列中了。 第二步要做两件事：1. 将前序为空的课程放入序列，删除已经放入序列的课程。2. 遍历hash，在各课程的前序课程中，去掉已经放入序列的课程。结果：hash：{1:[], 2:[], 3:[1, 2]},序列res：[0] while循环直到res中包含了所有的课程res.length === numCourses 以上是我们的大体思路，但是该题中还有一个问题。存在循环前置例如[[0,1],[1,0]]或者[0,1][1,2][2,0]等等，当课程存在这样的循环时，我们无法得知到底该先学习哪门课程。需要直接返回[]代表无法完成。 该问题也很好解决，当我们遍历hash找不到任何一个前置课程为[]的课程时，表示存在循环引用了！这时候就可以返回[]了 代码实现一12345678910111213141516171819202122232425262728293031323334353637/** * @param &#123;number&#125; numCourses * @param &#123;number[][]&#125; prerequisites * @return &#123;number[]&#125; */var findOrder = function(numCourses, prerequisites) &#123; let hash = &#123;&#125;; let res = []; //初始化hash表 for(let i = 0; i &lt; numCourses; i++) &#123; hash[i] = []; &#125; //收集课程的前置课程 for(let i = 0; i &lt; prerequisites.length; i++) &#123; hash[prerequisites[i][0]] = Array.from(new Set([...hash[prerequisites[i][0]], ...prerequisites[i].slice(1)])); &#125; // 遍历直到res排满 while (res.length &lt; numCourses) &#123; let count = 0;//标记hash中的前序为空的课程。 //遍历hash，碰到前序为空的，放入res，然后删除，最后在hash各课程的前序中去掉它。 for (key in hash) &#123; if (hash[key].length === 0) &#123; count++; res.push(Number(key)); delete hash[key] for (key2 in hash) &#123; hash[key2].indexOf(Number(key)) &gt; -1 ? hash[key2].splice(hash[key2].indexOf(Number(key)), 1) : '' &#125; &#125; &#125; // 如果遍历hash没有找到前置为空的课程，表示存在循环，返回[] if (!count) &#123; return [] &#125; &#125; return res;&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"JavaScript：leetcode_560. 和为K的子数组（前序和）","slug":"JavaScript：leetcode_560. 和为K的子数组（前序和）","date":"2020-05-15T09:59:13.000Z","updated":"2020-05-28T01:59:01.962Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_560. 和为K的子数组（前序和）/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_560. 和为K的子数组（前序和）/","excerpt":"题目说明12345678910给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。示例 1 :输入:nums = [1,1,1], k = 2输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。说明 :数组的长度为 [1, 20,000]。数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。","text":"题目说明12345678910给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。示例 1 :输入:nums = [1,1,1], k = 2输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。说明 :数组的长度为 [1, 20,000]。数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。 解题思路一 该题可以使用前序和进行计算和为k的个数，也可以用动态规划的思路来理解 我们记录该元素之前的所有前缀和。 然后利用上一次的结果，分别加上该元素的值，获取该元素所有的前缀和。（注意不要漏掉只有本身的结果）。 判断前缀和集合中有几个值为k的情况。就是该元素对k个数的解。 记录所有元素的解的个数，求和。即为结果 代码实现一1234567891011121314151617181920/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; k * @return &#123;number&#125; */var subarraySum = function(nums, k) &#123; let kNums = nums[0] === k ? 1 : 0; let now = [nums[0]] for (let i = 1; i &lt; nums.length; i++) &#123; now = now.map((item) =&gt; &#123; if (item + nums[i] == k) &#123; kNums++; &#125; return item + nums[i]; &#125;) nums[i] === k ? kNums++ : \"\" now.push(nums[i]); &#125; return kNums&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"JavaScript：leetcode_102. 二叉树的层序遍历（1. 层序遍历 + 深度遍历 2. 动态规划）","slug":"JavaScript：leetcode_102. 二叉树的层序遍历（1. 层序遍历 + 深度遍历 2. 动态规划）","date":"2020-05-14T09:59:13.000Z","updated":"2020-05-28T01:59:54.758Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_102. 二叉树的层序遍历（1. 层序遍历 + 深度遍历 2. 动态规划）/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_102. 二叉树的层序遍历（1. 层序遍历 + 深度遍历 2. 动态规划）/","excerpt":"题目说明1234567891011121314151617181920给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 示例：二叉树：[3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7返回其层次遍历结果：[ [3], [9,20], [15,7]] 说明该题对于我来说一共有两种思路，四种方案。","text":"题目说明1234567891011121314151617181920给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 示例：二叉树：[3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7返回其层次遍历结果：[ [3], [9,20], [15,7]] 说明该题对于我来说一共有两种思路，四种方案。 解题思路一 （层序+深度） 该题如果去掉分组，就是一个层序遍历的问题。加上分组也不过是多深度遍历一遍 代码实现一 (1)1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[][]&#125; */ var levelOrder = function(root) &#123; if (!root) &#123; return [] &#125; let res = []; function deepNode(root, node) &#123; node.deep = root.deep + 1; node.left &amp;&amp; deepNode(node, node.left); node.right &amp;&amp; deepNode(node, node.right); &#125; deepNode(&#123;deep: -1&#125;, root); let help = [root] while(help.length) &#123; let node = help.shift(); node.right &amp;&amp; help.unshift(node.right); node.left &amp;&amp; help.unshift(node.left); if (!res[node.deep]) &#123; res[node.deep] = []; &#125; res[node.deep].push(node.val); &#125; return res; &#125;; 代码实现一 (2)可以看到实现方式二去掉了while遍历，使用了一组数组。因为数组的顺序是前序遍历的结果，所以标记过每个节点的层级之后，我们其实按顺序将它分别放到二维数组中就可以了。1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[][]&#125; */var levelOrder = function(root) &#123; if (!root) &#123; return [] &#125; let res = []; let nodeList = []; function deepNode(root, node, nodeList) &#123; node.deep = root.deep + 1; nodeList.push(&#123; val: node.val, deep: node.deep &#125;) node.left &amp;&amp; deepNode(node, node.left, nodeList); node.right &amp;&amp; deepNode(node, node.right, nodeList); &#125; deepNode(&#123;deep: -1&#125;, root, nodeList); for (let i = 0; i &lt; nodeList.length; i++) &#123; if (!res[nodeList[i].deep]) &#123; res[nodeList[i].deep] = []; &#125; res[nodeList[i].deep].push(nodeList[i].val); &#125; return res;&#125;; 解题思路二 （递归 + 动态规划） 首先我们可以这么想：根节点属于数组的第一层。 那么第二层该如何得到呢，其实就是按顺序遍历第一层所有节点的左右节点。 第三层就是遍历第二层的所有左右节点。 按照这样理解，这个题就更加清晰了。 状态转移的方式是将当前层的所有子节点放入下一层。 代码实现二 (1)123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[][]&#125; */ var levelOrder = function(root) &#123; if (!root) &#123; return [] &#125; let nodeList = [[root]]; let res = [[root.val]]; function deepNode(nodeList, row, res) &#123; nodeList[row + 1] = []; res[row + 1] = []; for (let i = 0; i &lt; nodeList[row].length; i++) &#123; nodeList[row][i].left &amp;&amp; (nodeList[row + 1].push(nodeList[row][i].left), res[row+1].push(nodeList[row][i].left.val)); nodeList[row][i].right &amp;&amp; (nodeList[row + 1].push(nodeList[row][i].right), res[row+1].push(nodeList[row][i].right.val)); &#125; if (nodeList[row + 1].length) &#123; deepNode(nodeList, row + 1, res) &#125; &#125; deepNode(nodeList, 0, res); res.length -= 1; return res; &#125;; 代码实现二 (2)去掉了递归，使用了for循环。12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[][]&#125; */var levelOrder = function(root) &#123; if (!root) &#123; return [] &#125; let nodeList = [[root]]; let res = [[root.val]]; for (let i = 0; ; i++) &#123; nodeList[i + 1] = []; res[i + 1] = []; for (let j = 0; j &lt; nodeList[i].length; j++) &#123; nodeList[i][j].left &amp;&amp; (nodeList[i + 1].push(nodeList[i][j].left), res[i + 1].push(nodeList[i][j].left.val)); nodeList[i][j].right &amp;&amp; (nodeList[i + 1].push(nodeList[i][j].right), res[i + 1].push(nodeList[i][j].right.val)); &#125; if (!nodeList[i + 1].length) &#123; break; &#125; &#125; res.length -= 1; return res;&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"JavaScript：leetcode_136. 只出现一次的数字（异或运算）","slug":"JavaScript：leetcode_136. 只出现一次的数字（异或运算）","date":"2020-05-14T09:59:13.000Z","updated":"2020-05-28T01:59:45.480Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_136. 只出现一次的数字（异或运算）/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_136. 只出现一次的数字（异或运算）/","excerpt":"题目说明1234567891011121314给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？示例 1:输入: [2,2,1]输出: 1示例 2:输入: [4,1,2,1,2]输出: 4","text":"题目说明1234567891011121314给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？示例 1:输入: [2,2,1]输出: 1示例 2:输入: [4,1,2,1,2]输出: 4 解题思路一主要看一下题目的要求，线性复杂度，不适用额外的空间。 这里可以巧妙的使用异或运算符的特性，相同值的异或为0；所有的值，异或0都是本身。数组的所有项向异或之后的结果就是只出现一次的值 我使用了reduce的数组方法，事实上可能也新开辟了空间，我们完全按照题意的话，可以直接使用数组第1项进行代替。 代码实现一123456789/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var singleNumber = function(nums) &#123; return nums.reduce((sum, item, key, arr) =&gt; &#123; return (sum ^= item) &#125;, 0)&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"JavaScript：leetcode_155. 最小栈（辅助栈）","slug":"JavaScript：leetcode_155. 最小栈（辅助栈）","date":"2020-05-12T09:59:13.000Z","updated":"2020-05-28T01:59:30.587Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_155. 最小栈（辅助栈）/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_155. 最小栈（辅助栈）/","excerpt":"题目说明12345678910111213141516171819202122232425262728293031设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。push(x) —— 将元素 x 推入栈中。pop() —— 删除栈顶的元素。top() —— 获取栈顶元素。getMin() —— 检索栈中的最小元素。 示例:输入：[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;][[],[-2],[0],[-3],[],[],[],[]]输出：[null,null,null,null,-3,null,0,-2]解释：MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.getMin(); --&gt; 返回 -2. 提示：pop、top 和 getMin 操作总是在 非空栈 上调用。","text":"题目说明12345678910111213141516171819202122232425262728293031设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。push(x) —— 将元素 x 推入栈中。pop() —— 删除栈顶的元素。top() —— 获取栈顶元素。getMin() —— 检索栈中的最小元素。 示例:输入：[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;][[],[-2],[0],[-3],[],[],[],[]]输出：[null,null,null,null,-3,null,0,-2]解释：MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.getMin(); --&gt; 返回 -2. 提示：pop、top 和 getMin 操作总是在 非空栈 上调用。 解题思路一 首先确定栈的特点吧，先进后出，只能从栈顶进栈出栈，然后我们用数组来模拟他，将数组末尾当作栈顶，在此进栈出栈。 其实就是实现一个数组的push，pop功能，然后增加获取最小值的api和返回数组最后一位的api 由于最开始栈为空，所以栈是通过push，或者pop得到的。并且题目要求最小值要通过常数次操作得到，也就getMin的时间复杂度为O(1).那我们可以在push，pop的过程中，确定最小值。代码实现一123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * initialize your data structure here. */var MinStack = function() &#123; return void ( this.stack = [], this.min = [Number.MAX_SAFE_INTEGER], //整数类型的最大值 this.topValue = null );&#125;;/** * @param &#123;number&#125; x * @return &#123;void&#125; */MinStack.prototype.push = function(x) &#123; return void (this.stack[this.stack.length] = x, this.topValue = x, this.min[this.min.length] = (x &gt; this.min[this.min.length - 1] ? this.min[this.min.length - 1] : x));&#125;;/** * @return &#123;void&#125; */MinStack.prototype.pop = function() &#123; return void (this.stack.length -= 1, this.topValue = this.stack[this.stack.length - 1], this.min.length -= 1);&#125;;/** * @return &#123;number&#125; */MinStack.prototype.top = function() &#123; return this.topValue;&#125;;/** * @return &#123;number&#125; */MinStack.prototype.getMin = function() &#123; return this.min[this.min.length - 1];&#125;;/** * Your MinStack object will be instantiated and called as such: * var obj = new MinStack() * obj.push(x) * obj.pop() * var param_3 = obj.top() * var param_4 = obj.getMin() */","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"JavaScript：leetcode_50. Pow(x, N)（幂计算）","slug":"JavaScript：leetcode_50. Pow(x, n)（幂计算）","date":"2020-05-11T09:59:13.000Z","updated":"2020-05-28T02:00:18.677Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_50. Pow(x, n)（幂计算）/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_50. Pow(x, n)（幂计算）/","excerpt":"题目说明123456789101112131415161718191.实现 pow(x, n) ，即计算 x 的 n 次幂函数。示例 1:输入: 2.00000, 10输出: 1024.00000示例 2:输入: 2.10000, 3输出: 9.26100示例 3:输入: 2.00000, -2输出: 0.25000解释: 2-2 = 1/22 = 1/4 = 0.25说明:-100.0 &lt; x &lt; 100.0n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。","text":"题目说明123456789101112131415161718191.实现 pow(x, n) ，即计算 x 的 n 次幂函数。示例 1:输入: 2.00000, 10输出: 1024.00000示例 2:输入: 2.10000, 3输出: 9.26100示例 3:输入: 2.00000, -2输出: 0.25000解释: 2-2 = 1/22 = 1/4 = 0.25说明:-100.0 &lt; x &lt; 100.0n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 解题思路一 计算X的n次幂。首先要理解 x^n^ === (x^2^)^n/2^ 理解幂计算就可以了。 当n为奇数的时候，我们记得计算完平方之后再乘以 x 请看代码实现。 代码实现一12345678910111213141516/** * @param &#123;number&#125; x * @param &#123;number&#125; n * @return &#123;number&#125;// */var myPow = function(x, n) &#123; n &lt; 0 ? (x = 1/x ,n = -n) : '' let res = 1; while(n) &#123; if(n &amp; 1) res = res * x; // 当n为奇数时，我们需要收集一下落单的x x = x * x; n = Math.floor(n / 2) // n &gt;&gt;&gt;= 1 ; 需要用&gt;&gt;&gt; 因为数字2147483648 用二进制 2^32 - 1 位表示不了了，所以要 &#125; return res&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"JavaScript：leetcode_236. 二叉树的最近公共祖先（1. 层序遍历 + 二叉树任意遍历方法 2. 二叉树遍历 + 动态规划）","slug":"JavaScript：leetcode_236. 二叉树的最近公共祖先（1. 层序遍历 + 二叉树任意遍历方法 2. 二叉树遍历 + 动态规划）","date":"2020-05-10T09:59:13.000Z","updated":"2020-05-28T01:59:15.371Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_236. 二叉树的最近公共祖先（1. 层序遍历 + 二叉树任意遍历方法 2. 二叉树遍历 + 动态规划）/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_236. 二叉树的最近公共祖先（1. 层序遍历 + 二叉树任意遍历方法 2. 二叉树遍历 + 动态规划）/","excerpt":"题目说明123456给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 1234567891011121314151617示例 1:输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。示例 2:输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 说明:所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉树中。","text":"题目说明123456给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 1234567891011121314151617示例 1:输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。示例 2:输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 说明:所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉树中。 解题思路一 层序遍历二叉树，每遍历到一个节点，就收集该节点在内的所有子节点。 该节点子节点集合中是否同时存在p,q，如果存在，标记该节点，flag为true代表：该节点是p，q的一个公共祖先，然后依次遍历其左右节点的子节点集合。 若不存在，说明其子节点的集合肯定也不存在，就中断递归，没必要再继续了。 最终递归会在左右节点都不存在的情况下终止遍历。形成一个带有标记的树，每个节点上标记有flag为true的都是p，q的公共祖先 最后再进行一次层序遍历，收集flag为true的节点，然后数组的末尾一位就是他们的最近公共祖先。 注意： 题目中的5，步骤也可以放在 2-3步骤中同时进行收集。代码实现中，我使用了unshift(),所以输出的是第一位。 代码实现一12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @param &#123;TreeNode&#125; p * @param &#123;TreeNode&#125; q * @return &#123;TreeNode&#125; */// 注意是返回节点，不是返回节点的值！！！var lowestCommonAncestor = function(root, p, q) &#123; p = p.val; q = q.val; find(root, p, q); let help = [root] let res = []; while (help.length) &#123; let now = help.shift(); if(now.flag) &#123; res.unshift(now); now.left &amp;&amp; help.push(now.left); now.right &amp;&amp; help.push(now.right); &#125; &#125; return res[0]&#125;;function find(root, p, q) &#123; let help = [root] let res = []; while (help.length) &#123; let now = help.shift(); res.push(now.val); now.left &amp;&amp; help.push(now.left); now.right &amp;&amp; help.push(now.right); &#125; if (res.indexOf(p) !== -1 &amp;&amp; res.indexOf(q) !== -1) &#123; root.flag = true; root.left &amp;&amp; (find(root.left, p, q)) root.right &amp;&amp; (find(root.right, p, q)) &#125;&#125; 解题思路二 收集所有的节点的祖先节点，类似于动态规划，每个节点的所有公共祖先都是父节点所有公共祖先的加上该节点本身。 通过动态规划和递归进行收集。 判断该节点是否是p或者q，收集到对象中。 二叉树遍历完成后，将收集到的p，q所有的祖先节点进行遍历，倒序遍历到第一个相同的节点就是他们的最近公共祖先 这个方法在实际提交中，超内存了。。。但是思路应该是没毛病的。 代码实现一12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @param &#123;TreeNode&#125; p * @param &#123;TreeNode&#125; q * @return &#123;TreeNode&#125; */// 注意是返回节点，不是返回节点的值！！！var lowestCommonAncestor = function(root, p, q) &#123; p = p.val; q = q.val; let res = &#123; p: [], q: [] &#125; find(root, p, q, [], res); for (let i = res.q.length; i &gt;= 0; i--) &#123; if (res.p.indexOf(res.q[i]) !== -1) &#123; return res.q[i] &#125; &#125;&#125;;function find(root, p, q, prev, res) &#123; prev = [...prev, root]; if (root.val === p) &#123; res.p = [...prev] &#125; if (root.val === q) &#123; res.q = [...prev] &#125; root.left &amp;&amp; (find(root.left, p, q, prev, res)); root.right &amp;&amp; (find(root.right, p, q, prev, res));&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"JavaScript：leetcode_69. X 的平方根","slug":"JavaScript：leetcode_69. x 的平方根","date":"2020-05-09T09:59:13.000Z","updated":"2020-05-28T02:00:09.813Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_69. x 的平方根/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_69. x 的平方根/","excerpt":"题目说明12345678910111213141516实现 int sqrt(int x) 函数。计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。示例 1:输入: 4输出: 2示例 2:输入: 8输出: 2说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。","text":"题目说明12345678910111213141516实现 int sqrt(int x) 函数。计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。示例 1:输入: 4输出: 2示例 2:输入: 8输出: 2说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 解题思路一 求平方根，一种是利用我们Math.sqrt()直接求，这种就不说了。 然后说我们手动求的方式，最简单的方式，就是for循环遍历从1到x，求出x/i === i 那么这个i就是他的平方根。 问题是你遇到非整平方根你可就求不出来了。 所以再进行一次判断(i * i &gt; x &amp;&amp; (i-1)*(i-1) &lt; x)判断x是否存在于这个范围内，如果再，取i-1，因为我们是向下取整的。代码实现一12345678910111213141516171819/** * @param &#123;number&#125; x * @return &#123;number&#125; */var mySqrt = function(x) &#123; let length = (String(x).length &gt;&gt; 1) + 1; let max = ((new Array(length).fill((String(x)[0] - 0 &gt;&gt; 1) + 2).fill(0,1)).join('')) - 0; for(let i = max; i &gt;= 0; i--) &#123; if(i * i === x) &#123; return i &#125; if((i * i &gt; x &amp;&amp; (i-1)*(i-1) &lt; x)) &#123; return i - 1 &#125; &#125; return 0&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"JavaScript：leetcode_72. 编辑距离（动态规划，Vue，react的类似diff算法）","slug":"JavaScript：leetcode_72. 编辑距离（动态规划，vue，react的类似diff算法）","date":"2020-05-08T09:59:13.000Z","updated":"2020-05-28T02:00:07.808Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_72. 编辑距离（动态规划，vue，react的类似diff算法）/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_72. 编辑距离（动态规划，vue，react的类似diff算法）/","excerpt":"题目说明123456789101112131415161718192021222324252627给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。你可以对一个单词进行如下三种操作：插入一个字符删除一个字符替换一个字符 示例 1：输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;输出：3解释：horse -&gt; rorse (将 &apos;h&apos; 替换为 &apos;r&apos;)rorse -&gt; rose (删除 &apos;r&apos;)rose -&gt; ros (删除 &apos;e&apos;)示例 2：输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;输出：5解释：intention -&gt; inention (删除 &apos;t&apos;)inention -&gt; enention (将 &apos;i&apos; 替换为 &apos;e&apos;)enention -&gt; exention (将 &apos;n&apos; 替换为 &apos;x&apos;)exention -&gt; exection (将 &apos;n&apos; 替换为 &apos;c&apos;)exection -&gt; execution (插入 &apos;u&apos;)","text":"题目说明123456789101112131415161718192021222324252627给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。你可以对一个单词进行如下三种操作：插入一个字符删除一个字符替换一个字符 示例 1：输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;输出：3解释：horse -&gt; rorse (将 &apos;h&apos; 替换为 &apos;r&apos;)rorse -&gt; rose (删除 &apos;r&apos;)rose -&gt; ros (删除 &apos;e&apos;)示例 2：输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;输出：5解释：intention -&gt; inention (删除 &apos;t&apos;)inention -&gt; enention (将 &apos;i&apos; 替换为 &apos;e&apos;)enention -&gt; exention (将 &apos;n&apos; 替换为 &apos;x&apos;)exention -&gt; exection (将 &apos;n&apos; 替换为 &apos;c&apos;)exection -&gt; execution (插入 &apos;u&apos;) 说明此题是一个最短编辑距离问题，我们在工作中用到工具和框架有很多也是类似的算法。比如Git提交，对比差异。vue中将更新前的虚拟dom改成更新后的虚拟dom（vue中对此做了取舍，有优化） 首先对题意要有个理解： 一三种操作，增，删，改，都是针对word1的。但是其实此题目中只要求求出最短操作。所以word1和word2之间，操作互换一样可以达到同样的效果。 比如word1为people，word2为peopl，此时，word1末尾删除e 或者 word2末尾增加e都可以达到 word1 == word2 的效果。 所以针对word1的增删操作可以转化为对word1或者word2的增操作再加上对word1的改操作 二假如当word1和word2末尾相同的时候，其实是相当于没有操作。 比如 people 到peopl 和peoplee到people 二者所需要的操作都是相同的。 解题思路一根据题目意思，我们需要找到最少操作数，最少最优，基本上都和贪心及动态规划有关系。此题需要对比word1和word2进行对比操作。先使用动态规划解决。 首先构建一个二维数组用来记录子问题的解。 dp “” r (ro) o (ros) s “” 0 1 2 3 h 1 (ho) o 2 (hor)r 3 (hors)s 4 (horse)e 5 dp[i][j] 表示 i 到 j 所需要的步数，以dp[2][1]为例子，表示“ho”转换到“r” 所需要的操作数 如表，是我们要初始化出来的dp二维数组。表内数字，分别代表竖列到达横排所需要的操作数。有了dp数组，我们先来操作一次。求出dp[1][1]的值。 dp[1][1]处，word1为h，word2为r。两位不同,那么有三种处理方式 h -&gt; r 更改h,操作数为1，修改之后变成了 r和r，参照说明中的第二条，我们再加上dp[0][0]即可 word2增加h变为rh,操作数为1, h和rh参照说明中的第二条，就变成了‘’ =&gt; &quot;r&quot;所用的步数，dp[0][1] word1增加r变为hr,操作数为1, hr和r参照说明中的第二条，就变成了‘h’ =&gt; &quot;&quot;所用的步数，dp[1][0] 当我们分析出了以上三种情况后，我们肯定要取最小值作为我们此次dp[1][1]所要求出来的值了。 转换为代码就是 1 + Math.min(dp[0][0],dp[0][1],dp[1][0]) 以上是末尾不相同的情况，如果相同，请参照说明第二条。实际上就是和横纵各退一步的情况相同 最后我们将dp[i][j]看作此次dp[1][1]时。实际代码就出来了123dp[i][j] = word1[i-1] === word2[j-1] ? dp[i-1][j-1] : (1 + Math.min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])) 最终完成的dp dp “” r (ro) o (ros) s “” 0 1 2 3 h 1 1 2 3 (ho) o 2 2 1 2 (hor)r 3 2 2 2 (hors)s 4 3 3 2 (horse)e 5 4 4 3 代码实现一123456789101112131415161718192021222324252627282930/** * @param &#123;string&#125; word1 * @param &#123;string&#125; word2 * @return &#123;number&#125; */var minDistance = function(word1, word2) &#123; let length1 = word1.length; let length2 = word2.length; let dp = new Array(length1 + 1).fill(0).map((item) =&gt; &#123;return new Array(length2 + 1).fill(0)&#125;); for (let i = 0; i &lt; dp.length; i++) &#123; dp[i][0] = i; &#125; for (let i = 0; i &lt; dp[0].length; i++) &#123; dp[0][i] = i; &#125; //初始化工作结束 for (let i = 1; i &lt;= length1; i++) &#123; for (let j = 1; j &lt;= length2; j++) &#123; dp[i][j] = word1[i-1] === word2[j-1] ? dp[i-1][j-1] : (1 + Math.min( dp[i-1][j], dp[i][j-1], dp[i-1][j-1] )) &#125; &#125; return dp[length1][length2]&#125;; 总结我们知道vue的diff算法被优化到了O(n)而此题我们观察发现除了两层循环对比每个元素，还需要min操作。实际时间复杂度到达了O(n^3)。 那么vue是如何做到的呢？还记得我们循环节点时需要设置的key。通过这个key，我们就可以一一对应前后节点之间的关系。那我们只需要遍历一次节点就可以了。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"JavaScript：leetcode_572. 另一个树的子树（广度遍历+深度遍历）","slug":"JavaScript：leetcode_572. 另一个树的子树（广度遍历+深度遍历）","date":"2020-05-07T09:59:13.000Z","updated":"2020-05-28T01:58:58.858Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_572. 另一个树的子树（广度遍历+深度遍历）/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_572. 另一个树的子树（广度遍历+深度遍历）/","excerpt":"题目说明12345678910111213141516171819202122232425262728293031323334给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。示例 1:给定的树 s: 3 / \\ 4 5 / \\ 1 2给定的树 t： 4 / \\ 1 2返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。示例 2:给定的树 s： 3 / \\ 4 5 / \\ 1 2 / 0给定的树 t： 4 / \\ 1 2返回 false。","text":"题目说明12345678910111213141516171819202122232425262728293031323334给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。示例 1:给定的树 s: 3 / \\ 4 5 / \\ 1 2给定的树 t： 4 / \\ 1 2返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。示例 2:给定的树 s： 3 / \\ 4 5 / \\ 1 2 / 0给定的树 t： 4 / \\ 1 2返回 false。 说明解题之间看清除问题中的两个例子，什么是子树。树中的某节点及其所有子节点组成的树，叫子树。不可以漏掉一个的。所以看例2，是返回false的哦。 解题思路一广度优先找子树根，深度优先对比s，t。我这种思路可能稍麻烦些，但是好在容易理解。符合人脑回路。 广度优先遍历S树。依赖队列实现（push和shift配合实现队列先进先出的特点） 直到S树某节点的val值和T树的根节点val值相同时。(s.val === t.val) 深度遍历做对比。使用递归 还有一种思路是依赖JSON.stingify将对象转换成字符串，再判断字符串之间是否包含。投机取巧不太可取就不做展示了。 代码实现一1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; s * @param &#123;TreeNode&#125; t * @return &#123;boolean&#125; */var isSubtree = function(s, t) &#123; let sArr = []; let tArr = []; let dp = [s]; let flag = 'default'; function frontTree(s, t) &#123; //这个判断有点多，哈哈 if (t === null || s === null || s.val !== t.val) &#123; return (flag = false) &#125; if ((s.left &amp;&amp; !t.left) || (!s.left &amp;&amp; t.left)) &#123; return (flag = false) &#125; if ((s.right &amp;&amp; !t.right) || (!s.right &amp;&amp; t.right)) &#123; return (flag = false) &#125; if (s.left &amp;&amp; t.left) &#123; frontTree(s.left, t.left); &#125; if (s.right &amp;&amp; t.right) &#123; frontTree(s.right, t.right); &#125; &#125; while (dp.length) &#123; let s = dp.shift(); if(s.val === t.val) &#123; flag = true; //开始深度对比，默认为true frontTree(s, t);//如果不匹配，flag会设置为false if (flag) &#123; //如果匹配，返回true, 如果不匹配，继续往下找，一直到最后。 return true &#125; &#125; s.left &amp;&amp; dp.push(s.left) s.right &amp;&amp; dp.push(s.right) &#125; // 若flag为default,说明没有找到和t根节点相同的节点，返回false return flag === 'default' ? false : flag&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"JavaScript：leetcode_983. 最低票价（动态规划）","slug":"JavaScript：leetcode_983. 最低票价（动态规划）","date":"2020-05-06T09:59:13.000Z","updated":"2020-05-28T01:58:43.868Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_983. 最低票价（动态规划）/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_983. 最低票价（动态规划）/","excerpt":"题目说明123456789101112131415161718192021222324252627282930313233343536373839404142在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。火车票有三种不同的销售方式：一张为期一天的通行证售价为 costs[0] 美元；一张为期七天的通行证售价为 costs[1] 美元；一张为期三十天的通行证售价为 costs[2] 美元。通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。 示例 1：输入：days = [1,4,6,7,8,20], costs = [2,7,15]输出：11解释： 例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：在第 1 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 1 天生效。在第 3 天，你花了 costs[1] = $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。在第 20 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 20 天生效。你总共花了 $11，并完成了你计划的每一天旅行。示例 2：输入：days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]输出：17解释：例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划： 在第 1 天，你花了 costs[2] = $15 买了一张为期 30 天的通行证，它将在第 1, 2, ..., 30 天生效。在第 31 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 31 天生效。 你总共花了 $17，并完成了你计划的每一天旅行。 提示：1 &lt;= days.length &lt;= 3651 &lt;= days[i] &lt;= 365days 按顺序严格递增costs.length == 31 &lt;= costs[i] &lt;= 1000","text":"题目说明123456789101112131415161718192021222324252627282930313233343536373839404142在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。火车票有三种不同的销售方式：一张为期一天的通行证售价为 costs[0] 美元；一张为期七天的通行证售价为 costs[1] 美元；一张为期三十天的通行证售价为 costs[2] 美元。通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。 示例 1：输入：days = [1,4,6,7,8,20], costs = [2,7,15]输出：11解释： 例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：在第 1 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 1 天生效。在第 3 天，你花了 costs[1] = $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。在第 20 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 20 天生效。你总共花了 $11，并完成了你计划的每一天旅行。示例 2：输入：days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]输出：17解释：例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划： 在第 1 天，你花了 costs[2] = $15 买了一张为期 30 天的通行证，它将在第 1, 2, ..., 30 天生效。在第 31 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 31 天生效。 你总共花了 $17，并完成了你计划的每一天旅行。 提示：1 &lt;= days.length &lt;= 3651 &lt;= days[i] &lt;= 365days 按顺序严格递增costs.length == 31 &lt;= costs[i] &lt;= 1000 解题思路一动态规划的问题。 好多题解是倒着来算的，对于书写是更简洁了，但是对于思维，太别扭了。。我脑子实在转不过来。 所以我就换成正序规划，这样好理解一点。 此题有点类似于背包算法。但是又不太一样。 打点 days[0] 到 days[days.length - 1]的每一天。 所以初始化 dp = new Array(days.length).fill(0),代表的是一年的第一天到计划旅行的最后一天 days[0]的值为计划开始旅行的第一天的日期，所以当开始第一天时，当然是2块钱最划算，所以dp[days[0]] = 2 第三步就比较核心了!!!! 当我们算到第二天的时候，是不是要比较买什么票合适呢？ 买如果只买一天的票，那就是今天之前所有的money加上今天的2块钱，dp[i-1] + costs[0] 如果买7天的票，那就是今天往前划拉7天的money加上今天的7块钱，dp[i-7] + costs[1] 同理买30天的票，划拉30天dp[i-30] + costs[2] 好嘞，我们又三种选择了，根据题意和常识，我们选择最便宜的。用Math.min(dp[i-1] + costs[0],dp[i-7] + costs[1],dp[i-30] + costs[2]) 代码实现一1234567891011121314151617181920/** * @param &#123;number[]&#125; days * @param &#123;number[]&#125; costs * @return &#123;number&#125; */var mincostTickets = function(days, costs) &#123; let dp = new Array(days[days.length-1]).fill(0); for (let i = days[0], k = 0; i &lt;= days[days.length-1]; i++) &#123; if (i === days[k]) &#123; //确定今天是不是旅行日 dp[i] = Math.min(dp[(i - 1)&gt;=0?(i - 1):0] + costs[0], dp[(i - 7)&gt;=0?(i - 7):0] + costs[1], dp[(i - 30)&gt;=0?(i - 30):0] + costs[2]) //如果是，就得用前面花的钱加上今天花的钱。 //今天之前的钱数都是确定的且最小的。 k++ &#125; else &#123; dp[i] = dp[i-1] //如果今天不旅行，那肯定不花钱，跟前一天的钱一样。 &#125; &#125; return dp[dp.length-1]&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"Vue(2.x 和 3.0) 双向绑定原理及实现（Object.defineProperty 和 Proxy）以及常见错误区分","slug":"Vue双向数据绑定原理及实现","date":"2020-05-06T09:59:13.000Z","updated":"2020-05-06T10:14:37.183Z","comments":true,"path":"Vue/Vue双向数据绑定原理及实现/","link":"","permalink":"http://www.zsfmyz.top/Vue/Vue双向数据绑定原理及实现/","excerpt":"","text":"说明vue实现双向绑定原理，主要是利用Object.defineProperty 来给实例data的属性添加 setter和getter.并通过发布订阅模式（一对多的依赖关系，当状态发生改变，它的所有依赖都将被通知）来实现响应。 这个环节中包含了三个部分 Observer 用来监听拦截data的属性为监察者。 Dep用来添加订阅者，为订阅器 Watcher 就是订阅者 监察者通过 Dep 向 Watcher发布更新消息 简单实现那么首先 通过对set和get的拦截，在get阶段进行依赖收集，在set阶段对通知该属性上所啊绑定的依赖。 如下我们就已经实现了一个简单的双向绑定了。 我们将data的value属性绑定上set和get，通过 _value 来进行操作。 1234&lt;!-- HTML部分 --&gt;&lt;input type=\"text\" id=\"inp\" oninput=\"inputFn(this.value)\"&gt;&lt;div id='div'&gt;&lt;/div&gt; 1234567891011121314151617181920&lt;!-- JS部分 --&gt;var inp = document.getElementById('inp');var div = document.getElementById('div');var data = &#123; value:''&#125; Object.defineProperty(data, 'value', &#123; enumerable: true, configurable: true, set: function (newValue) &#123; this._value = newValue; div.innerText = data._value = value; //watcher &#125;, get: function () &#123; return this._value; &#125;&#125;)function inputFn(value) &#123; data._value = value;&#125; 如果只是实现一个简单的双向绑定那么上面的代码就已经实现了。 进一步完善模拟vue实现首先我们将watcher抽出来 备用 123function watcher(params) &#123; div.innerText = inp.value = params; // 派发watcher&#125; 声明一个vm来模拟vue的实例,并初始化。 123456789101112131415161718var vm = &#123; //类似vue实例上的data data: &#123; value: '' &#125;, // vue私有, _data的所有属性为data中的所有属性被改造为 getter/setter 之后的。 _data: &#123; value: '' &#125;, // 代理到vm对象上，可以实现vm.value value: '', //value的订阅器用来收集订阅者 valueWatchers:[] &#125; 遍历其data上的属性 进行改造 这里我们还是只举一个例子 12345678910111213141516171819// 利用 Object.defineProperty 定义一个属性 (eg：value) 描述符为存取描述符的属性Object.defineProperty(vm._data, 'value', &#123; enumerable: true, //是否可枚举 configurable: true, //是否可配置 set: function (newValue) &#123; //set 派发watchers vm.data.value = newValue; vm.valueWatchers.map(fn =&gt; fn(newValue)); &#125;, get: function () &#123; // 收集wachter vue中会在compile解析器中通过 显示调用 (this.xxx) 来触发get进行收集 vm.valueWatchers.length = 0; vm.valueWatchers.push(watcher); return vm.data.value; &#125;&#125;) &lt;!--直接通过显示调用来触发get进行绑定 vue中是在compile解析器中来进行这一步--&gt; vm._data.value 进行到这儿也已经实现了绑定，但是我们平时使用vue ，都是可以直接通过 this.xxx来获取和定义数据 那么我们还需要进行一步Proxy 代理 1234567891011Object.defineProperty(vm, 'value', &#123; enumerable: true, configurable: true, set: function (newValue) &#123; this._data.value = newValue; //借助 &#125;, get: function () &#123; return this._data.value; &#125;&#125;) 这样我们就把vm._data.value 代理到vm.value上了，可以通过其直接操作了。 那么按照官方的写法 123456789101112131415function proxy (target, sourceKey, key) &#123; Object.defineProperty(target, key, &#123; enumerable: true, configurable: true, get() &#123; return this[sourceKey][key]; &#125;, set(val) &#123; this[sourceKey][key] = val; &#125; &#125;);&#125; proxy(vm, '_data', 'value'); 完善后的完整代码以下为整个页面，可以直接运行1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;双向绑定简单实现&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=\"text\" id=\"inp\" oninput=\"inputFn(this.value)\"&gt;&lt;br&gt;&lt;input type=\"text\" id=\"inp2\" oninput=\"inputFn(this.value)\"&gt;&lt;div id='div'&gt;&lt;/div&gt;&lt;script&gt; var inp = document.getElementById('inp'); var inp2 = document.getElementById('inp2'); var div = document.getElementById('div'); function inputFn(value) &#123; div.innerText = vm.value = value; &#125; function watcher(params) &#123; console.log(1) div.innerText = inp.value = params; // 派发watcher &#125; function watcher2(params) &#123; console.log(2) div.innerText = inp2.value = params; // 派发watcher &#125; function proxy (target, sourceKey, key) &#123; Object.defineProperty(target, key, &#123; enumerable: true, configurable: true, get() &#123; return this[sourceKey][key]; &#125;, set(val) &#123; this[sourceKey][key] = val; &#125; &#125;); &#125; let handler = &#123; enumerable: true, configurable: true, set: function (newValue) &#123; vm.data.value = newValue; vm.valueWatchers.map(fn =&gt; fn(newValue)); &#125;, get: function () &#123; vm.valueWatchers = []; //防止重复添加, vm.valueWatchers.push(watcher); vm.valueWatchers.push(watcher2); return vm.data.value; &#125; &#125; var vm = &#123; data: &#123;&#125;, _data: &#123;&#125;, value: '', valueWatchers: [] &#125; Object.defineProperty(vm._data, 'value', handler) proxy(vm, '_data', 'value'); vm.value; //显示调用绑定&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 解释再多讲一点。实际上vue在初始化的时候是用解析器解析过程中将wathcer进行绑定的。 它会利用一个全局的Dep.target = watcher 然后在get收集中，只收集全局上Dep.target, 添加完毕后会重新初始化全局Dep.target = null; 类似如下操作1234Dep.target = watcher;vm.value; // 触发get =&gt; Dep.target &amp;&amp; valueWatchers.push(Dep.target);Dep.target = null; 这样也会防止我们在调用时触发get重复去添加watcher。 而我们的例子中只是每次都初始化为[]. 实际订阅器也不只是一个watcher数组。 此例跟官方实现还是有很多差距，只是简单模拟。 vue3.0 使用 Proxy 在vue3.0中，使用proxy这个功能更加强大的函数，它可以定义对象的基本操作的自定义行为。对比defineProperty只能拦截对象的某一属性，proxy的功能更方便。所提供的可自定义的操作也更多。 上面，我用defineProperty实现了vue的双向绑定，接下来我们用proxy来实现。 首先我们可以先了解一下proxy的作用和用法 首先 defineProperty 的用法是Object.defineProperty(obj, prop, descriptor) proxy的用法如下：1const p = new Proxy(target, handler) 我们用proxy来实现一下双向绑定： 核心代码就像这样，在我们这个需求下分析 set函数中 target 为所拦截的对象 key 为属性名 newValue为所赋予的值 set中需要return true代表设置成功，返回flase在严格模式下报TypeError （代表该值与期望值类型不同） get函数中 target 为所拦截的对象 key 为属性名 get可返回任意值1234567891011121314let data = &#123;value: 0&#125;const vm = new Proxy(&#123;value: 0 &#125;, &#123; set: function(target, key, newValue)&#123; console.log(key + '被赋值为' + newValue) target[key] = newValue return true &#125;， get: function(target, key) &#123; console.log(target[key]) return target[key] &#125;&#125;)vm.value = 1 // 0; value被赋值为1 proxy双向绑定具体实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 id=\"content\"&gt;&lt;/h1&gt; &lt;p&gt;&lt;input type=\"text\" id=\"enter\" value=\"\"&gt;&lt;/p&gt;&lt;/body&gt;&lt;script&gt; let content = document.getElementById(\"content\") let enter_input = document.getElementById('enter') let data = &#123; enter_input: '', enter_input_watchers: [] &#125; let watcher = function watcherFn(value) &#123; content.innerText = value &#125; let watcher2 = function watcher2Fn(value) &#123; enter_input.value = value &#125; let handler = &#123; set: function(target, key, value) &#123; if (key === 'enter_input') &#123; target[key] = value; target[key + \"_watchers\"].map(function (watcher) &#123; watcher(value) &#125;) &#125; &#125;, get: function(target, key) &#123; target[key + \"_watchers\"] = [watcher, watcher2]; return target[key] &#125; &#125; let db = new Proxy(data, handler); db.enter_input; //收集监听 enter_input.addEventListener('input', function(e)&#123; db.enter_input = e.target.value; &#125;)&lt;/script&gt;&lt;/html&gt; 错误类型扩展平时我们常见的错误类型分为ReferenceError，TypeError，SyntaxError 这三种。 一、 ReferenceError 代表我们的作用域查找错误。123let b = 1;console.log(b)console.log(a) //ReferenceError 我们在全局定义了b，所以console.log(b)为1，但是我们没有定义a，所以我们在全局作用域下找不到a，就会报ReferenceError 如果是在函数中定义，则在函数中查找不到时，会去父作用域查找，一直到全局，都找不到，才会报ReferenceError 二、 TypeError代表数据类型与预期不符。12let b = 1;b() //TypeError 我们在全局定义了b，其类型为Number，但是我们用()来执行它，把它当作了函数用，所以就会报TypeError 三、 SyntaxError代表语法错误。123let b &gt; 1;//SyntaxError//orlet let b//SyntaxError 很明显，我们不可以这么使用let，语法就错误了，所以就会报SyntaxError","categories":[{"name":"Vue","slug":"Vue","permalink":"http://www.zsfmyz.top/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.zsfmyz.top/tags/Vue/"}]},{"title":"JavaScript：leetcode_98. 验证二叉搜索树（递归）","slug":"JavaScript：leetcode_98. 验证二叉搜索树（递归）","date":"2020-05-05T09:59:13.000Z","updated":"2020-05-28T02:00:00.154Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_98. 验证二叉搜索树（递归）/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_98. 验证二叉搜索树（递归）/","excerpt":"题目说明1234567891011121314151617181920212223242526给定一个二叉树，判断其是否是一个有效的二叉搜索树。假设一个二叉搜索树具有如下特征：节点的左子树只包含小于当前节点的数。节点的右子树只包含大于当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。示例 1:输入: 2 / \\ 1 3输出: true示例 2:输入: 5 / \\ 1 4 / \\ 3 6输出: false解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。","text":"题目说明1234567891011121314151617181920212223242526给定一个二叉树，判断其是否是一个有效的二叉搜索树。假设一个二叉搜索树具有如下特征：节点的左子树只包含小于当前节点的数。节点的右子树只包含大于当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。示例 1:输入: 2 / \\ 1 3输出: true示例 2:输入: 5 / \\ 1 4 / \\ 3 6输出: false解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 解题思路一解决树的问题，最常用的还是递归的方法。此题的关键就是找到node.val的取值范围。 其左右树的取值范围是以根节点为分界线，左集合为左树取值范围，右集合为右树取值范围。 如下 左树取值范围是[-∞，4],右树取值范围是[6，+∞]，以此类推。12345 5 / \\1 8 / \\ 6 9 以此为例，因为5为根节点，所以，他的取值范围 是[-∞，+∞]，也就是没有限制 然后观察左树，左树根节点为1，符合题目要求，要小于其根节点，也就是说其取值范围是[-∞，4] 然后观察右树，右树根节点为4，符合题目要求，要大于其根节点，也就是说其取值范围是[6，+∞] 观察右树左节点，按要求，它要小于右树根节点（8），并且大于树根节点（5），所以其取值范围是[6，7]，同理其右树右节点范围是[9，+∞]。 递归… 了解了以上步骤，那么接下来再看代码实现可能会比较清晰。 代码实现一1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;boolean&#125; */ //Number.MIN_SAFE_INTEGER 代表 -∞ //Number.MAX_SAFE_INTEGER 代表 +∞let flaglet isValidBST = function(root) &#123; let flag = true; root &amp;&amp; findTree(root, Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER); return flag&#125;;function findTree(node, min, max) &#123; if (node.val &lt;= min || node.val &gt;= max) &#123; return flag = false &#125; node.left &amp;&amp; findTree(node.left, min, node.val) //递归时，传入其左树总的取值范围 node.right &amp;&amp; findTree(node.right, node.val, max)//递归时，传入其右树总的取值范围&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"JavaScript：leetcode_45. 跳跃游戏 II（贪心算法）","slug":"JavaScript：leetcode_45. 跳跃游戏 II（贪心算法）","date":"2020-05-04T09:59:13.000Z","updated":"2020-05-28T02:00:24.156Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_45. 跳跃游戏 II（贪心算法）/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_45. 跳跃游戏 II（贪心算法）/","excerpt":"题目说明123456789101112131415给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。示例:输入: [2,3,1,1,4]输出: 2解释: 跳到最后一个位置的最小跳跃数是 2。 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。说明:假设你总是可以到达数组的最后一个位置。","text":"题目说明123456789101112131415给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。示例:输入: [2,3,1,1,4]输出: 2解释: 跳到最后一个位置的最小跳跃数是 2。 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。说明:假设你总是可以到达数组的最后一个位置。 解题思路一贪心算法。首先我们要理解这个题目。以 [3,5,2,4,1,1,1,1,1]为例子 index表示我们所处nums中的位置，maxLength代表我们下一步最远能到达的位置。 第0步时，我们处在index = 0，maxLength = 3，表示我们现在最远可以到达index = 3的位置。 当我们选择跳一步时，我们拥有了5，maxLength就变成了index（1,5的下标）+ 5 = 6，相当于从0-6的位置尽在我们掌握了 当我们选择跳二步时，我们拥有的是2，maxLength就变成了index（2，2的下标）+ 2 = 4，显然没有6大呀，不可取，不可取。 当我们选择跳三步时，我们拥有的是4，maxLength就变成了index（3，4的下标）+4 = 7，比6大，可以走的更远了，不错不错，就要他了。现在我们掌握了从 0 - 7 的位置跳转的权力了，所以它是目前的最优解，包含了其他的所以情况。 这个时候我们的位置就变成了，index = 3， maxLength = 7 然后我们判断一下，我们现在的最远距离能不能到达结尾(maxLength &gt;= (nums.length - 1)) ?，如果可以，那就结束啦，目前我们走了1步，那么下一步就可以到了，所以就是一共要走 1 + 1 步，返回 2 就好啦。 如果不可以，那还得从步骤 1 到步骤 5 再来一遍。 上面的过程，表示了我们正常处理的流程，符合我们的的思考习惯。所以问题其实就转化为了，求 可跳跃范围内的下标index + nums[index]的最大值，取出这个值，作为下一次的起点。 代码实现一123456789101112131415161718192021222324252627282930/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var jump = function(nums) &#123; if (nums.length === 1) &#123; return 0; &#125; if ((nums.length - 1) &lt;= nums[0]) &#123; return 1; &#125; let step = 0; let index = 0; let maxLength = index + nums[index]; for (let i = 0; i &lt; nums.length;) &#123; index = i; for (let j = i + 1; j &lt;= i + nums[i]; j++) &#123; if ((j + nums[j]) &gt; maxLength) &#123; index = j maxLength = (index + nums[index]) &#125; &#125; step++; i = index; if (maxLength &gt;= (nums.length - 1)) &#123; return ++step &#125; &#125; return step&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"JavaScript：leetcode_53. 最大子序和（贪心，分治）","slug":"JavaScript：leetcode_53. 最大子序和（贪心，分治）","date":"2020-05-03T09:59:13.000Z","updated":"2020-05-28T02:00:13.872Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_53. 最大子序和（贪心，分治）/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_53. 最大子序和（贪心，分治）/","excerpt":"题目说明12345678910给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。示例:输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。进阶:如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。","text":"题目说明12345678910给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。示例:输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。进阶:如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 解题思路一贪心算法。 依次求数组前i项的和，再求和之前，判断sum的值是否小于0，若小于零，直接抛弃。 若大于0，就sum+=nums[i] 由于子序列是必须要连续的，所以我们需要一个记录最大值的变量,maxSum. 每次sum求和之后，用maxSum记录最大值 maxSum= Math.max(sum, maxSum);最终返回max即可 代码实现一1234567891011121314151617/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */ var maxSubArray = function(nums) &#123; let sum = 0; let maxSum = Number.MIN_SAFE_INTEGER; for (let i = 0; i &lt; nums.length; i++) &#123; if (sum &lt; 0) &#123; sum = nums[i]; &#125; else &#123; sum += nums[i]; &#125; maxSum = Math.max(maxSum, sum) &#125; return maxSum &#125;; 解题思路二分治法。 将nums分为3个部分： 从nums[mid]处向两边求和，取得最大值。 nums的左半边 （仿照1的方式求得左半边的和） nums的右半边（仿照1的方式求得右半边的和） 求出这三个和之后，返回其最大的一个值。 从步骤一得出，我们需用使用递归计算。 代码实现一123456789101112131415161718192021222324252627282930313233343536373839404142/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var maxSubArray = function(nums) &#123; return fz(0, nums.length-1, nums)&#125;;function fz(left, right, nums) &#123; if (left === right) &#123; return nums[left] &#125; let mid = left + ((right - left) &gt;&gt; 1); let leftMax = Number.MIN_SAFE_INTEGER let rightMax = Number.MIN_SAFE_INTEGER let midMax = crossNum(left, right, nums) leftMax = fz(left, mid, nums) rightMax = fz(mid+1, right, nums) return Math.max(Math.max(midMax, rightMax), leftMax);&#125;function crossNum(left, right, nums) &#123; if (left === right) &#123; return nums[left] &#125; let mid = left + ((right - left) &gt;&gt; 1) let leftSum = 0; let leftMax = Number.MIN_SAFE_INTEGER; for (let i = mid; i &gt;= left; i--) &#123; leftSum += nums[i]; leftMax = Math.max(leftMax, leftSum) &#125; let rightSum = 0; let rightMax = Number.MIN_SAFE_INTEGER; for (let i = mid + 1; i &lt;= right; i++) &#123; rightSum += nums[i]; rightMax = Math.max(rightMax, rightSum) &#125; return rightMax + leftMax;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"JavaScript：leetcode_3. 无重复字符的最长子串（滑动窗口）","slug":"JavaScript：leetcode_3. 无重复字符的最长子串（滑动窗口）","date":"2020-05-02T09:59:13.000Z","updated":"2020-05-28T02:00:58.777Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_3. 无重复字符的最长子串（滑动窗口）/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_3. 无重复字符的最长子串（滑动窗口）/","excerpt":"题目说明12345678910111213141516171819给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。示例 1:输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。示例 2:输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。示例 3:输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。","text":"题目说明12345678910111213141516171819给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。示例 1:输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。示例 2:输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。示例 3:输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 这个题是我昨天晚上做的，没想到今天变成每日一题了。。我这个也算神预言了~ 解题思路一通过滑动窗口去解决它， 建立一个空字符串str，遍历原始字符串s每个位置的值s[i] 若str中不存在s[i]，str+=s[i] 若存在，滑动窗口，寻找str中s[i]的位置str.indexOf(s[i])，截取该位置之后的str部分，然后str+=s[i]. 进行第三步时，需要取max(length, str.length) ，length为之前截取时记录的str.length的最大值。 最后返回最大值即可。代码实现一12345678910111213var lengthOfLongestSubstring = function(s) &#123; let str = ''; let length = 0; for (let i = 0; i &lt; s.length; i++) &#123; if (str.indexOf(s[i]) == -1) &#123; str += s[i] &#125; else &#123; length = Math.max(length, str.length); str = str.slice(str.indexOf(s[i]) + 1) + s[i]; &#125; &#125; return Math.max(length, str.length);&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"JavaScript：leetcode_21. 合并两个有序链表（递归归并）","slug":"JavaScript：leetcode_21. 合并两个有序链表（递归归并）","date":"2020-05-01T04:59:13.000Z","updated":"2020-05-28T02:00:40.841Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_21. 合并两个有序链表（递归归并）/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_21. 合并两个有序链表（递归归并）/","excerpt":"题目说明123456将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例：输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4","text":"题目说明123456将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例：输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 解题思路一其实就是归并排序的最后一步。合成两个有序序列。只不过用递归的方式去遍历链表。 递归，把min(t1，t2),加入新链。 若t1小，迭代t1 = t1.next，进入下一轮。代码实现一12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; l1 * @param &#123;ListNode&#125; l2 * @return &#123;ListNode&#125; */var mergeTwoLists = function(l1, l2) &#123; let res = new ListNode(0); if (l1 &amp;&amp; l2) &#123; mergeL(l1,l2,res) &#125; else &#123; return l1 || l2 &#125; return res&#125;;function mergeL(l1, l2, res) &#123; if (l1.val &lt;= l2.val) &#123; res.next = l1 res.next.next = l2 &#125; else &#123; res.next = l2 res.next.next = l1 &#125; if (l1.next &amp;&amp; l2.next) &#123; mergeL(l1.next, l2.next, res.next.next) &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"JavaScript：202. 快乐数（快慢指针）","slug":"JavaScript：202. 快乐数（快慢指针）","date":"2020-04-30T09:59:13.000Z","updated":"2020-05-28T02:01:13.950Z","comments":true,"path":"Algorithm/每日一题/JavaScript：202. 快乐数（快慢指针）/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：202. 快乐数（快慢指针）/","excerpt":"题目描述1234567891011121314给定一个 没有重复 数字的序列，返回其所有可能的全排列。示例:输入: [1,2,3]输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]","text":"题目描述1234567891011121314给定一个 没有重复 数字的序列，返回其所有可能的全排列。示例:输入: [1,2,3]输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 解题思路一广度优先遍历方法，递归解决 如图所示， 我们需要3个信息： 1. 和已确定序列， 2. 剩余序列 题解一：1234567891011121314151617181920212223/** * @param &#123;number[]&#125; nums * @return &#123;number[][]&#125; */var permute = function(nums) &#123; let res = []; for (let i = 0; i &lt; nums.length; i++) &#123; let copy = [...nums]; join(copy.splice(i,1), copy, res); &#125; return res;&#125;;// preArr为已确认的前序列// arr为剩余的序列var join = function(preArr, arr, res) &#123; if (arr.length === 0) &#123; return res.push(preArr); &#125; for (let i = 0; i &lt; arr.length; i++) &#123; let copy = [...arr]; join(preArr.concat(copy.splice(i,1)), copy, res); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"JavaScript：617. 合并二叉树（递归合并）","slug":"JavaScript：617. 合并二叉树（递归合并）","date":"2020-04-30T09:59:13.000Z","updated":"2020-05-28T02:01:11.302Z","comments":true,"path":"Algorithm/每日一题/JavaScript：617. 合并二叉树（递归合并）/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：617. 合并二叉树（递归合并）/","excerpt":"题目说明123456789101112131415161718192021给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。示例 1:输入: Tree 1 Tree 2 1 2 / \\ / \\ 3 2 1 3 / \\ \\ 5 4 7 输出: 合并后的树: 3 / \\ 4 5 / \\ \\ 5 4 7注意: 合并必须从两个树的根节点开始。","text":"题目说明123456789101112131415161718192021给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。示例 1:输入: Tree 1 Tree 2 1 2 / \\ / \\ 3 2 1 3 / \\ \\ 5 4 7 输出: 合并后的树: 3 / \\ 4 5 / \\ \\ 5 4 7注意: 合并必须从两个树的根节点开始。 解题思路一 又是一道二叉树的题，题目要求合并二叉树，即相同位置的val值相加，不同位置的val值互相替换。 一般思路是创建一个新树，去取两树之和。 但是题目没有要求不能改变原来的两棵树，那么我们以t1树为基准，观察t2树。 若t1树对应t2树的位置都有值，则相加，若t1无，t2有，则t2替换t1节点，若t1有，t2无则无需操作。代码实现一123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; t1 * @param &#123;TreeNode&#125; t2 * @return &#123;TreeNode&#125; */let mergeTrees = (t1, t2) =&gt; &#123; if (t1 &amp;&amp; t2) &#123; mergeNode(t1,t2) &#125; return t1 || t2;&#125;;let mergeNode = (t1, t2, root) =&gt; &#123; t1.val += t2.val; if (t1.left === null) &#123; t1.left = t2.left &#125; else if( t2.left !== null) &#123; mergeNode(t1.left,t2.left) &#125; if (t1.right === null) &#123; t1.right = t2.right &#125; else if (t2.right !== null) &#123; mergeNode(t1.right,t2.right) &#125;&#125; 同样的我们使用递归的方法去遍历。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"JavaScript:一道题，带你搞定二分法!","slug":"一道题，带你搞定二分法! (JavaScript)","date":"2020-04-29T09:59:13.000Z","updated":"2020-05-01T03:54:09.941Z","comments":true,"path":"Algorithm/每日一题/一道题，带你搞定二分法! (JavaScript)/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/一道题，带你搞定二分法! (JavaScript)/","excerpt":"","text":"题目描述题目有点长，我就截个图展示了。 解题思路这跟我之前做的那个旋转数组有相似之处，都是两个有序序列的组合。JavaScript：leetcode_33. 搜索旋转排序数组（二分法） 看题目限制，肯定又是不能用遍历的O(n)。而且对获取mountain的值有100次的限制。 那么自然就想到了二分法，结合题目，mountain长度为10000那么大概分十几次就完事儿了。基本不会把一百次用完。 我的思路是，用二分法找到mountain的山顶top，将其分为两个有序序列，然后分别用二分法查找。 最终算法时间复杂度为 O(log n) findTop 查找山顶top findLeftTarget 左序查找target，左序列为升序序列。 findRightTarget 右序列查找target，右序列为降序序列。(也只是在判断条件上有所区别) 如果不太清楚二分法,那么请先看一下 文末扩展 题解：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/** * // This is the MountainArray's API interface. * // You should not implement it, or speculate about its implementation * function MountainArray() &#123; * @param &#123;number&#125; index * @return &#123;number&#125; * this.get = function(index) &#123; * ... * &#125;; * * @return &#123;number&#125; * this.length = function() &#123; * ... * &#125;; * &#125;; *//** * @param &#123;number&#125; target * @param &#123;MountainArray&#125; mountainArr * @return &#123;number&#125; */var findInMountainArray = function(target, mountainArr) &#123; let length = mountainArr.length(); let left_v = mountainArr.get(0); let right_v = mountainArr.get(length - 1); if (target &lt; left_v &amp;&amp; target &lt; right_v) &#123; return -1 &#125; let resMid = findTop(0, length - 1, mountainArr) let top = resMid.mid; let topV = resMid.mid_v; if (target &gt; topV) &#123; return -1; &#125; let left_target = findLeftTarget(0, top, mountainArr, target); return left_target === -1 ? findRightTarget(top, length-1, mountainArr, target) : left_target;&#125;;var findTop = function(left, right, mountainArr) &#123; let mid = left + ((right - left) &gt;&gt; 1); let mid_lv = mountainArr.get(mid - 1); let mid_v = mountainArr.get(mid); let mid_rv = mountainArr.get(mid + 1); if (mid_v &gt; mid_lv) &#123; if (mid_v &gt; mid_rv) &#123; return &#123; mid: mid, mid_v: mid_v, &#125; &#125; else &#123; return findTop(mid, right, mountainArr) &#125; &#125; else if (mid_v &lt; mid_lv) &#123; return findTop(left, mid, mountainArr) &#125;&#125;var findLeftTarget = function(left, right, mountainArr, target) &#123; if (right - left &lt;= 1) &#123; let left_v = mountainArr.get(left); if (left_v === target) &#123; return left; &#125; let right_v = mountainArr.get(right); if (right_v === target) &#123; return right; &#125; return -1 &#125; let mid = left + ((right - left) &gt;&gt; 1); let mid_v = mountainArr.get(mid); if (mid_v &lt; target) &#123; return findLeftTarget(mid+1, right, mountainArr, target) &#125; else if (mid_v &gt; target) &#123; return findLeftTarget(left, mid, mountainArr, target) &#125; else &#123; return mid; &#125; return -1&#125;var findRightTarget = function(left, right, mountainArr, target) &#123; if (right - left &lt;= 1) &#123; let left_v = mountainArr.get(left); if (left_v === target) &#123; return left; &#125; let right_v = mountainArr.get(right); if (right_v === target) &#123; return right; &#125; return -1 &#125; let mid = left + ((right - left) &gt;&gt; 1); let mid_v = mountainArr.get(mid); if (mid_v &gt; target) &#123; return findLeftTarget(mid+1, right, mountainArr, target) &#125; else if (mid_v &lt; target) &#123; return findLeftTarget(left, mid, mountainArr, target) &#125; else &#123; return mid; &#125; return -1&#125; 扩展 二分法详解解释： 算法：当数据量很大适宜采用该方法。采用二分法查找时，数据需是排好序的。 基本思想：假设数据是按升序排序的，对于给定值key，从序列的中间位置k开始比较， 如果当前位置arr[k]值等于key，则查找成功； 若key小于当前位置值arr[k]，则在数列的前半段中查找,arr[low,mid-1]； 若key大于当前位置值arr[k]，则在数列的后半段中继续查找arr[mid+1,high]， 直到找到为止,时间复杂度:O(log(n)) 使用方法 序列必须是有序的，无序序列无法使用二分法。 通过递归查找，直至序列长度缩小到2或者1。 模拟实现 以 nums[1,2,3,4,5]为例，找到数组中值为1的下标 left为 0，right为 4, 声明函数find(left,right) 求出中间点 mid = left + ((right - left) &gt;&gt; 1) 。 （&gt;&gt; 为位运算，相当于缩小2倍） 得到 mid 为 2；判断 nums[2] === 1 ?，若等返回mid，nums[2] 为 3，不等 1 ，进入下一步 判断nums[mid] &gt; 1,由于nums[2] ===3 &gt; 1,进入左序列find(0, 2) 求出中间点 mid = 0+ ((2- 0) &gt;&gt; 1), 得到mid 为 1；判断 nums[1] === 1 ?，若等返回mid，nums[1] 为 2，不等 1 ，进入下一步 判断nums[mid] &gt; 1,由于nums[1] ===2 &gt; 1,进入左序列find(0, 1) 求出中间点 mid = 0+ ((1 - 0) &gt;&gt; 1), 得到mid 为 0；判断 nums[0] === 1 ?，若等返回mid，nums[0] 为 1，等 1 ，return mid； 至此得到最后结果 下标为 0； 代码实现123456789101112131415let nums = [1,2,3,4,5] ;let target = 1;var find = function(left, right, target, nums) &#123; let mid = (left + ((right - left) &gt;&gt; 1)); if (nums[mid] == target) &#123; return mid; &#125; if (nums[mid] &gt; target) &#123; return find(left, mid, target, nums); &#125; if (nums[mid] &lt; target) &#123; return find(mid + 1, right, target, nums); &#125;&#125;find(0,4,1, nums) 这种是数组中一定包含target的情况下。如果不确定是否包含，需要在值只剩下1-2个的时候做出判断。 123456789101112131415161718let nums = [1,2,3,4,5] ;let target = 1;var find = function(left, right, target, nums) &#123; if (right- left &lt;= 1) &#123; return nums[left] === target ? left : (nums[right] ===target ? right: -1) &#125; let mid = (left + ((right - left) &gt;&gt; 1)); if (nums[mid] == target) &#123; return mid; &#125; if (nums[mid] &gt; target) &#123; return find(left, mid, target, nums); &#125; if (nums[mid] &lt; target) &#123; return find(mid + 1, right, target, nums); &#125;&#125;find(0,4,1, nums) 这样如果不存在返回 -1","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"JavaScript：leetcode_33. 搜索旋转排序数组（二分法）","slug":"JavaScript：leetcode_33. 搜索旋转排序数组（二分法）","date":"2020-04-26T09:59:13.000Z","updated":"2020-05-28T02:00:34.592Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_33. 搜索旋转排序数组（二分法）/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_33. 搜索旋转排序数组（二分法）/","excerpt":"题目描述123456789101112131415161718假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。你可以假设数组中不存在重复的元素。你的算法时间复杂度必须是 O(log n) 级别。示例 1:输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4示例 2:输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1","text":"题目描述123456789101112131415161718假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。你可以假设数组中不存在重复的元素。你的算法时间复杂度必须是 O(log n) 级别。示例 1:输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4示例 2:输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1 解题思路一时间复杂度要O(log n) ，那么就不能直接用遍历了。遍历是O(n) 其实一个无序的序列，查找的最小时间复杂度就是O(n) 但是，根据题意，原序列为升序序列，那么旋转后的序列其实是两个有序的序列的拼接，且没有交集。 我的思路是找到旋转点，然后分别使用二分法查找。二分法的时间复杂度就是O(log n)。 寻找旋转点同样使用二分法。 寻找旋转点时，左右序列都要包含mid，进行判断，否则会出现正好在旋转点处分割左右序列的情况。 这样的方法时间复杂度为O(2 log n) 应该还是符合题意的。 题解一：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number&#125; */var search = function(nums, target) &#123; let left = 0; let right = nums.length - 1; let flag = ef1(left, right, nums); let leftV = ef(left, flag, target, nums) let rightV = ef(flag + 1, right, target, nums) return leftV &gt; -1 ? leftV : rightV&#125;;// 查找旋转点var ef1 = function(left, right, nums) &#123; let mid = Math.floor(left + (right - left) / 2); if (right - left === 1) &#123; if (nums[left] &gt; nums[right]) &#123; return left &#125; &#125; // 左序列 如果左大于右，那说明旋转点在左序列中。 if (nums[left] &gt; nums[mid]) &#123; return ef1(left, mid, nums); &#125; // 右序列 如果左大于右，那说明旋转点在左序列中。 if (nums[mid] &gt; nums[right]) &#123; return ef1(mid, right, nums); &#125; return 0;&#125;// 查找targetvar ef = function(left, right, target, nums) &#123; let mid = Math.floor(left + (right - left) / 2); if (right - left === 1 || right - left === 0) &#123; if (target === nums[left]) &#123; return left &#125; if (target === nums[right]) &#123; return right &#125; return -1 &#125; if (nums[left] &lt;= target &amp;&amp; nums[mid] &gt;= target) &#123; return ef(left, mid, target, nums); &#125; if (nums[mid + 1] &lt;= target &amp;&amp; nums[right] &gt;= target) &#123; return ef(mid + 1, right, target, nums); &#125; return -1&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"JavaScript：leetcode_46. 全排列 (广度优先遍历)","slug":"JavaScript：leetcode_46. 全排列 (广度优先遍历)","date":"2020-04-25T09:59:13.000Z","updated":"2020-05-28T02:00:22.211Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_46. 全排列 (广度优先遍历)/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_46. 全排列 (广度优先遍历)/","excerpt":"题目描述1234567891011121314给定一个 没有重复 数字的序列，返回其所有可能的全排列。示例:输入: [1,2,3]输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]","text":"题目描述1234567891011121314给定一个 没有重复 数字的序列，返回其所有可能的全排列。示例:输入: [1,2,3]输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 解题思路一广度优先遍历方法，递归解决 如图所示， 我们需要3个信息： 1. 和已确定序列， 2. 剩余序列 题解一：1234567891011121314151617181920212223/** * @param &#123;number[]&#125; nums * @return &#123;number[][]&#125; */var permute = function(nums) &#123; let res = []; for (let i = 0; i &lt; nums.length; i++) &#123; let copy = [...nums]; join(copy.splice(i,1), copy, res); &#125; return res;&#125;;// preArr为已确认的前序列// arr为剩余的序列var join = function(preArr, arr, res) &#123; if (arr.length === 0) &#123; return res.push(preArr); &#125; for (let i = 0; i &lt; arr.length; i++) &#123; let copy = [...arr]; join(preArr.concat(copy.splice(i,1)), copy, res); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"JavaScript：面56 - I. 数组中数字出现的次数（分组异或）","slug":"JavaScript：面56 - I. 数组中数字出现的次数（分组异或）","date":"2020-04-25T09:59:13.000Z","updated":"2020-05-28T02:01:07.901Z","comments":true,"path":"Algorithm/每日一题/JavaScript：面56 - I. 数组中数字出现的次数（分组异或）/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：面56 - I. 数组中数字出现的次数（分组异或）/","excerpt":"题目说明123456789101112131415161718一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 示例 1：输入：nums = [4,1,4,6]输出：[1,6] 或 [6,1]示例 2：输入：nums = [1,2,10,4,1,4,3,3]输出：[2,10] 或 [10,2] 限制：2 &lt;= nums &lt;= 10000","text":"题目说明123456789101112131415161718一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 示例 1：输入：nums = [4,1,4,6]输出：[1,6] 或 [6,1]示例 2：输入：nums = [1,2,10,4,1,4,3,3]输出：[2,10] 或 [10,2] 限制：2 &lt;= nums &lt;= 10000 解题思路 求出数组异或的结果。因为相同值的异或为0，所以最后异或的结果为两个不同数的异或结果res。 将两个不同的值分别分割到两个不同的数组中。取res二进制中任意一位值为1的位置，作为区分标志flag。（1，说明两个不同值的二进制，在该位处的值一个为0，一个为1） 遍历数组 根据（nums[i] &amp; flag）的值区分为两个数组，并求出两个数组的异或结果。 由于两个不同值被分开，并且相同值对同一值的位与（&amp;）操作是相同的。所以，两个数组内除了不同值，其他都是由n对相同值构成，所以最后的异或操做是排除了n对相同值，最后分别得出了两个不同值。 代码实现123456789101112131415161718192021222324252627/** * @param &#123;number[]&#125; nums * @return &#123;number[]&#125; */var singleNumbers = function(nums) &#123; if (nums.length === 2)&#123; return nums; &#125; nums.unshift(0); res = 0; for (let i = 1; i &lt; nums.length; i++) &#123; res ^= nums[i]; &#125; let flag = 1; while((flag &amp; res) == 0) &#123; flag &lt;&lt;= 1 &#125; let left = 0, right = 0; for (let i = 1; i &lt; nums.length; i++) &#123; if (nums[i] &amp; flag) &#123; left ^= nums[i] &#125; else &#123; right ^= nums[i] &#125; &#125; return [left, right]&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"Leetcode_面试题51. 数组中的逆序对（归并排序记录逆序对）","slug":"JavaScript：leetcode_面试题51. 数组中的逆序对","date":"2020-04-24T09:59:13.000Z","updated":"2020-05-28T01:58:30.580Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_面试题51. 数组中的逆序对/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_面试题51. 数组中的逆序对/","excerpt":"题目描述12345678在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 示例 1:输入: [7,5,6,4]输出: 5","text":"题目描述12345678在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 示例 1:输入: [7,5,6,4]输出: 5 解题思路一N*N遍历求出逆序对的总数 题解一：123456789101112131415/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */ var reversePairs = function(nums) &#123; let res = 0; for (let i = nums.length - 1; i &gt;= 0; i++) &#123; for (let j = i; j &gt;=0; j++) &#123; if (nums[j] &lt; nums[i]) &#123; res++; &#125; &#125; &#125; return res; &#125;; 很简单，但是毫无疑问超时。 解题思路二归并排序算法，排序过程中记录逆序对的数量。最终nums还是一个升序序列。相当于我们在归并排序中顺手得到了逆序对的数量。 归并排序：它的思路就是，找到数组中间下标，然后排序左序列（left，middle）和右序列（middle+1，right）。结合递归一直分到序列长度为2，然后出栈排序。 归并排序的思路即： [4,2,3,1,8,7,6,5] =&gt; [4,2,3,1]和[8,7,6,5] [4,2,3,1] =&gt; [4,2] 和 [3,1] 到length==2,递归到终点，排序[4,2] =&gt; [2,4]。[3,1] =&gt; [1,3]。 然后得到[2,4,1,3],再对其进行排序，因为子序列的顺序都是排好的。所以，我们只需要对比，[2,4]和[1,3]哪个序列中前面的值小，就摘出来，放在help中。 比如1和2比，1小，那么help就变成了[1]，左序列还是[2,4],右序列变成了[3]. 然后3和2比，2小，那么help就变成了[1,2], 左序列变成了[4],右序列还是[3]. 一直比到左右序列有一个序列为空时，再将另外一个序列依次加入help。 题解一：123456789101112131415161718192021222324252627282930313233343536373839404142/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */ let res = 0;function mergeSort(nums, left, right) &#123; if (left === right) return; let mid = Math.floor(left + ((right - left) &gt;&gt; 1)); mergeSort(nums, left, mid) mergeSort(nums, mid + 1, right) let p1 = left; let p2 = mid + 1; let help = []; let i = 0; while(p1 &lt;= mid &amp;&amp; p2 &lt;= right) &#123; if (nums[p1] &lt;= nums[p2]) &#123; res += p2 - (mid + 1)//左序列的值，在赋值之前要看下help中，在它之前有几个右序列的值。就有几个逆序对。 &#125; help[i++] = nums[p1] &gt; nums[p2] ? nums[p2++] : nums[p1++]; &#125; while(p1 &lt;= mid) &#123; help[i++] = nums[p1++]; res += right - mid //若左序列还有剩余，那么剩余的都比右序列大，所以每个都要加上右序列的长度。 &#125; while(p2 &lt;= right) &#123; help[i++] = nums[p2++]; &#125; nums.splice(left, right - left + 1, ...help);&#125;var reversePairs = function(nums) &#123; if (!nums.length) &#123; return 0; &#125; res = 0; mergeSort(nums, 0, nums.length - 1); //nums此时是一个升序的序列 return res &#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"Leetcode_面试题 08.11. 硬币(数学方法，双百分)","slug":"JavaScript：leetcode_面试题 08.11. 硬币","date":"2020-04-23T09:59:13.000Z","updated":"2020-05-28T01:58:35.060Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_面试题 08.11. 硬币/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_面试题 08.11. 硬币/","excerpt":"题目描述1234567891011121314151617181920212223242526硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)示例1: 输入: n = 5 输出：2 解释: 有两种方式可以凑成总金额: 5=5 5=1+1+1+1+1 示例2: 输入: n = 10 输出：4 解释: 有四种方式可以凑成总金额: 10=10 10=5+5 10=5+1+1+1+1+1 10=1+1+1+1+1+1+1+1+1+1说明：注意:你可以假设：0 &lt;= n (总金额) &lt;= 1000000","text":"题目描述1234567891011121314151617181920212223242526硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)示例1: 输入: n = 5 输出：2 解释: 有两种方式可以凑成总金额: 5=5 5=1+1+1+1+1 示例2: 输入: n = 10 输出：4 解释: 有四种方式可以凑成总金额: 10=10 10=5+5 10=5+1+1+1+1+1 10=1+1+1+1+1+1+1+1+1+1说明：注意:你可以假设：0 &lt;= n (总金额) &lt;= 1000000 解题思路在这我只说一个硬刚的办法。没有算法，按照正常人类观察的思路： 一共存在n/25个25分硬币。 求当存在1个25分硬币时，剩余部分由多少个10分硬币组成。 在2的条件下，求1个10分硬币之外的部分由多少个5分硬币组成,有几个就加几个，再加上全1分的情况。 求当存在1个25分硬币时，剩余部分由多少个5分硬币组成。有几个就加几个，再加上全1分的情况。 至此我们求出了，组合中含有25分硬币的所有方法。然后按照上面的方法，求只存在10，5，1的方法，最后求只存在5，1的方法。其和即为我们所求的所有组合个数 题解一：123456789101112131415161718192021222324252627282930/** * @param &#123;number&#125; n * @return &#123;number&#125; */var waysToChange = function(n) &#123; let res = 0; //求 25分 10分 5分 1分组合情况 for ( let i = 1; i &lt;= Math.floor(n / 25); i++) &#123; for (let j = 1; j &lt;= Math.floor(( n - 25 * i) / 10) ; j++) &#123; for (let k = 0; k &lt;= Math.floor((n - 25 * i - 10*j) / 5); k++) &#123; res++; &#125; &#125; for (let l = 0; l &lt;= Math.floor(( n - 25 * i) / 5) ; l++) &#123; res++ &#125; &#125; //求 10分 5分 1分组合情况 for (let j = 1; j &lt;= Math.floor(n / 10) ; j++) &#123; for (let k = 0; k &lt;= Math.floor((n - 10*j) / 5); k++) &#123; res++; &#125; &#125; //求 5分 1分组合情况 for (let k = 0; k &lt;= Math.floor(n / 5); k++) &#123; res++; &#125; return res % 1000000007;&#125;; 这个办法，相当的好理解吧。然鹅！！！超时咯~~~ 那我就不会优化优化吗~~ 我们可以看出来求10，5，1 的情况和求5，1的情况，实际上是求当25分的个数为0时的情况。那我们合并一下，将i的值从0开始循环，那么就可以合并起来啦 结果：123456789101112131415161718192021/** * @param &#123;number&#125; n * @return &#123;number&#125; */var waysToChange = function(n) &#123; let res = 0; //求 25分 10分 5分 1分组合情况 for ( let i = 0; i &lt;= Math.floor(n / 25); i++) &#123; for (let j = 1; j &lt;= Math.floor(( n - 25 * i) / 10) ; j++) &#123; for (let k = 0; k &lt;= Math.floor((n - 25 * i - 10*j) / 5); k++) &#123; res++; &#125; &#125; for (let l = 0; l &lt;= Math.floor(( n - 25 * i) / 5) ; l++) &#123; res++ &#125; &#125; return res % 1000000007;&#125;; 再来看,这是求5，1分的。 123for (let l = 0; l &lt;= Math.floor(( n - 25 * i) / 5) ; l++) &#123; res++ &#125; 其实是求i = 0 到 Math.floor(( n - 25 i) / 5) 的个数吧，那就是Math.floor(( n - 25 i) / 5)+1个。 12let rest = Math.floor( n - 25 * i) ;res+= Math.floor(rest / 5) + 1; 同理我们把10，5，1 的for循环也提取一下123456789101112 for (let j = 1; j &lt;= Math.floor(( n - 25 * i) / 10) ; j++) &#123; for (let k = 0; k &lt;= Math.floor((n - 25 * i - 10*j) / 5); k++) &#123; res++; &#125; &#125;// 先按照2中的方法把内循环优化一下 let rest = Math.floor( n - 25 * i) ; let rest10 = Math.floor(rest / 10); for (let j = 1; j &lt;= rest10 ; j++) &#123; res+= Math.floor(rest / 5) + 1 - 2j; &#125; =&gt; 到这儿应该很清楚怎么优化了吧 (Math.floor(rest / 5) + 1)rest10 - (2 + 2 2 + 2 3+….+2 rest10)=&gt; (Math.floor(rest / 5) + 1)rest10 - (2+2rest10)/2 再提取一下公因式。1234let rest = Math.floor( n - 25 * i) ;let rest10 = Math.floor(rest / 10); res += rest10 * (Math.floor(rest / 5) - rest10) 题解二：123456789101112131415161718/** * @param &#123;number&#125; n * @return &#123;number&#125; */var waysToChange = function(n) &#123; let res = 0; let length25 = Math.floor(n / 25); for ( let i = 0; i &lt;= length25; i++) &#123; let rest = Math.floor(( n - 25 * i)); let rest10 = Math.floor(rest / 10); res += rest10 * (Math.floor(rest / 5) - rest10) res += Math.floor(rest / 5) + 1 return res % 1000000007;&#125;; 就这样完美解决了，并且时间和空间都秒杀了100%","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"Leecode_199. 二叉树的右视图(二叉树中右左遍历）","slug":"JavaScript：leecode_199. 二叉树的右视图","date":"2020-04-22T09:59:13.000Z","updated":"2020-05-28T02:01:05.638Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leecode_199. 二叉树的右视图/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leecode_199. 二叉树的右视图/","excerpt":"题目描述12345678910111213给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。示例:输入: [1,2,3,null,5,null,4]输出: [1, 3, 4]解释: 1 &lt;--- / \\2 3 &lt;--- \\ \\ 5 4 &lt;--- 解题思路对二叉树进行中右左顺序遍历，以此顺序，记录每个层级第一个被遍历的节点。","text":"题目描述12345678910111213给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。示例:输入: [1,2,3,null,5,null,4]输出: [1, 3, 4]解释: 1 &lt;--- / \\2 3 &lt;--- \\ \\ 5 4 &lt;--- 解题思路对二叉树进行中右左顺序遍历，以此顺序，记录每个层级第一个被遍历的节点。 题解一：123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */var rightSideView = function(root) &#123; let resArr = []; let level = 0; if (!root) &#123;return []&#125; nodeFn(root, 0, resArr) return resArr;&#125;;var nodeFn = function (node, level, resArr) &#123; if (resArr[level] === undefined) &#123; resArr[level] = node.val; &#125; node.right &amp;&amp; nodeFn(node.right, level + 1, resArr) node.left &amp;&amp; nodeFn(node.left, level + 1, resArr)&#125; 相当于二叉树的后序遍历的反序（中右左），只不过需要标记一下每个层级的第一个遍历节点即可。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"Leetcode_200. 岛屿数量 (DFS)","slug":"JavaScript：leetcode_200. 岛屿数量","date":"2020-04-20T09:59:13.000Z","updated":"2020-05-28T01:59:27.601Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_200. 岛屿数量/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_200. 岛屿数量/","excerpt":"题目说明123456789101112131415161718192021222324给你一个由 &apos;1&apos;（陆地）和 &apos;0&apos;（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。示例 1:输入:11110110101100000000输出: 1示例 2:输入:11000110000010000011输出: 3解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。","text":"题目说明123456789101112131415161718192021222324给你一个由 &apos;1&apos;（陆地）和 &apos;0&apos;（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。示例 1:输入:11110110101100000000输出: 1示例 2:输入:11000110000010000011输出: 3解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。 解题思路 遍历二维数组，遍历时只查找===’1‘的情况，设立大陆数量flag初始化为1 找到一块岛屿（===’1‘），此时将flag+1，并将该岛屿标记为flag（2） 深度遍历与该岛屿连接起来的所有岛屿（连起来的其他’1‘） 将其深度遍历到的岛屿标记为flag 深度遍历完成后，继续二维数组的遍历，如果在深度标记后，又找到一个’1‘，那这肯定是第二块大陆的一部分了，重复2-4的步骤。 返回flag-1就是大陆的数量。 代码实现12345678910111213141516171819202122232425262728293031let x = [-1,1,0,0]let y = [0,0,-1,1]var mark = function(i,j,flag,grid)&#123; grid[i][j] = flag; for (let key = 0; key &lt; 4; key++) &#123; (grid[i + x[key]][j + y[key]] === '1') &amp;&amp; (mark(i + x[key],j+y[key],flag,grid)); &#125;&#125;var numIslands = function(grid) &#123; if (!grid.length)&#123;return 0;&#125; let flag = 1; //这一块操作是在二维数组外层包裹了一层’0‘，也就是一层海洋，方便处理边界问题。start grid.unshift(new Array(grid[0].length).fill('0')); grid.push(new Array(grid[0].length).fill('0')); grid.map((item)=&gt;&#123; item.unshift('0') item.push('0') &#125;) //这一块操作是在二维数组外层包裹了一层’0‘，也就是一层海洋，方便处理边界问题。end for(let i = 1; i &lt; grid.length-1; i++) &#123; for (let j = 1; j &lt; grid[i].length-1; j++) &#123; if (grid[i][j] === '1') &#123; flag++; mark(i,j,flag,grid); &#125; &#125; &#125; return (flag - 1)&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"Leetcode_11. 盛最多水的容器 （暴力遍历=>双指针）","slug":"JavaScript：leetcode_11. 盛最多水的容器","date":"2020-04-19T09:59:13.000Z","updated":"2020-05-28T02:00:47.227Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_11. 盛最多水的容器/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_11. 盛最多水的容器/","excerpt":"题目描述给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。","text":"题目描述给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 解题思路 一暴力法办法一很简单，双层循环计算出所有可能的结果，选出最大的。 1234567891011121314var maxArea = function(height) &#123; let area = 0; for (let i = 0; i &lt; height.length; i++) &#123; for(let j = i; j &lt; height.length; j++) &#123; let m2 = Math.min(height[i],height[j]) * (j-i); if (m2 &gt; area) &#123; area = m2; &#125; &#125; &#125; return area;&#125;; 一点难度都没有。 优化接下来我们优化一下 123456789101112131415161718192021var getArea = function(height, i, j)&#123; return Math.min(height[i],height[j]) * (j-i);&#125;var maxArea = function(height) &#123; let start = 0; let end = height.length - 1; let area = getArea(height, start, end ); for (let i = 0; i &lt; height.length; i++) &#123; for(let j = height.length - 1; j &gt; i; j--) &#123; if (height[j] &lt; height[end]) &#123; continue; &#125; if (area &lt; getArea(height, i, j)) &#123; area = getArea(height,i, j); start = i; end = j; &#125; &#125; &#125; return area;&#125;; 把计算面积提出到getArea中了 标记了start，end。并利用其进行剪枝（优化去掉不必要的for循环），因为我们很容易看出来，比end（距离start最远）位更短的木板没有必要再进行计算了。 解题思路 二 双指针其实这道题的思路是这样：计算start，end之间的距离（宽），和Math.min(start，end)(高)的面积。怎么计算最大面积呢？目标是找最宽和最高。即在start，end距离最远的情况下，找两边最高的木板。 所以，我们通过让start和end在最远的距离处，开始慢慢靠近，靠近的规则是： 抛弃最短的，即若start比end处的木板短，start向右移一位+1，（反之end处短，则end - 1） 这样可以使两边都保证是最长的木板之间的面积 同样我们可以加入上面的优化，移位后，比原本位置短的，直接过滤掉。 123456789101112131415161718192021222324252627282930var getArea = function(height, i, j)&#123; return Math.min(height[i],height[j]) * (j-i);&#125;var maxArea = function(height) &#123; let start = 0; let end = height.length - 1; let area = getArea(height, start, end ); for (let i = 0,j = end; i &lt; j;) &#123; if (height[i] &gt; height[j]) &#123; j--; if (height[j] &lt; height[end]) &#123; continue; &#125; &#125; else &#123; i++ if (height[i] &lt; height[start]) &#123; continue; &#125; &#125; let m2 = getArea(height, i, j); if (area &lt; m2) &#123; area = m2; start = i; end = j; &#125; &#125; return area;&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"块级作用域内的函数声明到底是什么？？","slug":"块级作用域内的函数声明到底是什么？？","date":"2020-04-16T04:19:13.000Z","updated":"2020-04-24T07:51:09.551Z","comments":true,"path":"JavaScript/块级作用域内的函数声明到底是什么？？/","link":"","permalink":"http://www.zsfmyz.top/JavaScript/块级作用域内的函数声明到底是什么？？/","excerpt":"","text":"说明在一篇文章里看到这样一个问题。文章地址 文章中会扩展一些其他的内容， 大家可以看过之后再来看我这篇个人的总结 函数声明写在块级作用域中（ES6）12345678var a = 0;if(true)&#123; a = 1; function a()&#123;&#125; a = 21; console.log(\"里面\",a);&#125;console.log(\"外部\",a); 请问输出是什么？ 答案是：里面21 外面1。 正如我一样，看到答案的我蒙蔽了，然后就继续阅读完全文，感觉还是有点不太明白。最后经过我查询资料我得到了答案。 转换结果代码转化如下： 123456789101112var a; var a = 0; if (true) &#123; let a = function a() &#123; &#125; a = 1; window.a = a; //此处为原函数声明的位置 a = 21; console.log(\"里面\",a); &#125; console.log(\"外部\",a); 其实，函数声明放在块级作用域内做了以下几件事。so， 我想看到了转换后的代码，估计大家就豁然开朗了。 {}内部修改的是let定义的块级a，跟外部没关系。 所以 a = 1 的时候，外部其实还是为0。 外部的全局a原本为0， 被window.a = a 同步为了1. a =21 块级a变成了21，全局a无变化还是1. 那么为啥会这么转换呢???? 实质 函数声明会被提升到块级作用域顶部。 使用了类似let的方式定义了一个块级作用域的函数同名变量，并赋值。（个人总结） 函数声明的变量被声明到了全局作用域（或者函数作用域）顶部。 在函数声明的位置，会将目前块级作用域内的变量的值，同步到全局作用域（函数作用域）下。 解释如下标记 1234 ，我想这样是最直观的。 （window 代表的外层的作用域上下文，意思是if块所在的作用域，因为此处为全局，所以为window）。 12345678910111213var a; // 3 var a = 0; if (true) &#123; let a = function a() &#123; // 1，2 &#125; a = 1; window.a = a; // 4：此处为原函数声明的位置 a = 21; console.log(\"里面\",a); &#125; console.log(\"外部\",a); 扩展1234if(true) &#123; function a( )&#123;&#125;&#125; 转换为es5为 12345\"use strict\";if (true) &#123; var a = function a() &#123;&#125;;&#125; 所以经过我的查找，所有人都不推荐直接在块级作用域内进行函数声明，如果非要，就请使用es5的函数表达式写法。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zsfmyz.top/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zsfmyz.top/tags/JavaScript/"}]},{"title":"Leetcode 每日一题 旋转矩阵 （逆列 => 行）","slug":"JavaScript：leetcode.旋转矩阵","date":"2020-04-07T09:59:13.000Z","updated":"2020-05-28T01:58:19.114Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode.旋转矩阵/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode.旋转矩阵/","excerpt":"题目描述给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。 不占用额外内存空间能否做到？ 示例 1: 123456给定 matrix = [ [1,2,3], [4,5,6], [7,8,9]], 原地旋转输入矩阵，使其变为: 12345[ [7,4,1], [8,5,2], [9,6,3]]","text":"题目描述给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。 不占用额外内存空间能否做到？ 示例 1: 123456给定 matrix = [ [1,2,3], [4,5,6], [7,8,9]], 原地旋转输入矩阵，使其变为: 12345[ [7,4,1], [8,5,2], [9,6,3]] 解题思路目标阵列的每一横列为对应原始阵列每一竖列的倒序。 题解一：1234567891011121314151617/** * @param &#123;number[][]&#125; matrix * @return &#123;void&#125; Do not return anything, modify matrix in-place instead. */var rotate = function(matrix) &#123; let N = matrix.length; let newM = [] for (let i = 0; i &lt; N; i++) &#123; newM[i] = Array.from(matrix[i]); &#125; for (let i = 0; i &lt; N; i++) &#123; for(let j = 0; j &lt; N; j++) &#123; matrix[i][j] = newM [N - j - 1][i]; &#125; &#125;&#125;; 题解二：不创建新的数组空间12345678910111213141516/** * @param &#123;number[][]&#125; matrix * @return &#123;void&#125; Do not return anything, modify matrix in-place instead. */var rotate = function(matrix) &#123; let N = matrix.length; for (let i = 0; i &lt; N; i++) &#123; for(let j = 0; j &lt; N; j++) &#123; matrix[i][j + N] = matrix[N - j - 1][i]; &#125; &#125; for (let i = 0; i &lt; N; i++) &#123; matrix[i] = matrix[i].slice(N, 2*N); &#125;&#125;; 事实上这种方法是取巧了的，数组扩容了。数组检测到需要扩容时，就会开辟新的内存空间，最终大小为1.5倍+16。当数组内存空间&gt;=length*2+16的时候会进行缩容。如果数组长度比之前缩短了1，则只回收多余容量的一半，若长度比之前缩小的更多，则全部回收多余容量。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"leetcode_289.生命游戏：巧妙处理边界问题。","slug":"JavaScript：leetcode_289.生命游戏","date":"2020-04-03T09:59:13.000Z","updated":"2020-05-28T01:59:05.438Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_289.生命游戏/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_289.生命游戏/","excerpt":"题目描述","text":"题目描述 解题思路其实这道题，大家看到第一眼应该就知道很简单了。 同时更新的意思就是让我们拷贝一份数据备用嘛， 根据原版备份数据去更新新的细胞阵列。 boardBak = copy(board) 然后看看核心思路 统计8个位置的1的个数 ==3 那肯定要活着， ==2 自生自灭，其他情况都嗝屁 12345678910111213141516boardBak[y-1][x-1] + boardBak[y+1][x+1] + boardBak[y-1][x] + boardBak[y][x-1] + boardBak[y-1][x+1] + boardBak[y+1][x-1] + boardBak[y][x+1] + boardBak[y+1][x];if (sum === 3) &#123; board[y][x] = 1;&#125; else if(sum !== 2) &#123; board[y][x] = 0;&#125; so 核心的部分就是这些，一点难度都没有。 然后假定m为行数，n为列数，将下面的循环包裹在核心代码外，就ok了 for (y=0, y &lt; m) for (x=0, x &lt; n) 是不是很简单！！ 但是可恶的是，报错了。。因为边边上的细胞不够8个。。 那怎么办呢。。 我是这个样子处理的。 1234567891011121314151617[ [0,1,0], [0,0,1], [1,1,1], [0,0,0]]====&gt;[ [0,0,1,0,0], [0,0,1,0,0], [0,0,0,1,0], [0,1,1,1,0], [0,0,0,0,0], [0,0,0,0,0],] 看粗来了吗 我用了一圈死细胞（0）把我们的目标组织包裹起来了，这样不管是边界细胞还是里面的细胞，大家都可以统一的按照8个周边处理咯 当然我们不要直接改造目标细胞，而是改造备份细胞。 改造完之后，只需要改变一下循环条件，目的是为了从(1,1)坐标的细胞开始遍历到(m-1,n-1)，不去遍历我们包裹的边界。 for (y=1, y &lt; m-1) for (x=1, x &lt; n-1) 同样的现在我们的原阵列跟备份阵列的坐标存在不同咯。 备份阵列因为多了一层，所以，需要-1之后才是备份细胞在原阵列中的位置。 if (sum === 3) { board[y-1][x-1] = 1; } else if(sum !== 2) { board[y-1][x-1] = 0; } 到此就完事儿了。 下面是具体实现。 代码123456789101112131415161718192021222324252627282930313233343536/** * @param &#123;number[][]&#125; board * @return &#123;void&#125; Do not return anything, modify board in-place instead. */var gameOfLife = function(board) &#123; let boardBak = []; let n = board[0].length; board.map((row)=&gt;&#123; boardBak.push([0, ...row, 0]); &#125;) boardBak = [new Array(n + 2).fill(0), ...boardBak, new Array(n + 2).fill(0)] let m = boardBak.length; n = boardBak[0].length; for (let y = 1; y &lt; m - 1; y++) &#123; for (let x = 1; x &lt; n - 1; x++) &#123; let sum = 0; sum = boardBak[y-1][x-1] + boardBak[y+1][x+1] + boardBak[y-1][x] + boardBak[y][x-1] + boardBak[y-1][x+1] + boardBak[y+1][x-1] + boardBak[y][x+1] + boardBak[y+1][x]; if (sum === 3) &#123; board[y-1][x-1] = 1; &#125; else if(sum !== 2) &#123; board[y-1][x-1] = 0; &#125; &#125; &#125; return board;&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"Leetcode_226. 翻转二叉树","slug":"JavaScript：leetcode_226.翻转二叉树","date":"2020-03-26T03:59:13.000Z","updated":"2020-04-15T07:40:23.891Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_226.翻转二叉树/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_226.翻转二叉树/","excerpt":"题目解析翻转一棵二叉树。 示例示例 1:12345678910111213输入: 4 / \\ 2 7 / \\ / \\1 3 6 9输出: 4 / \\ 7 2 / \\ / \\9 6 3 1 解题思路递归，递归判断条件 1. 左右节点是否为null，不为null，则翻转其左右节点","text":"题目解析翻转一棵二叉树。 示例示例 1:12345678910111213输入: 4 / \\ 2 7 / \\ / \\1 3 6 9输出: 4 / \\ 7 2 / \\ / \\9 6 3 1 解题思路递归，递归判断条件 1. 左右节点是否为null，不为null，则翻转其左右节点 解答1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;TreeNode&#125; */function ex(treeNode) &#123; if (treeNode == null) &#123; return null; &#125; let item = treeNode.left; treeNode.left = treeNode.right; treeNode.right = item; treeNode.left &amp;&amp; ex(treeNode.left) treeNode.right &amp;&amp; ex(treeNode.right)&#125;var invertTree = function(root) &#123; ex(root) return root&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"定时器中的异步请求堆积如何解决？","slug":"定时器中的异步请求堆积如何解决？","date":"2020-03-14T04:50:34.000Z","updated":"2020-04-15T07:40:23.891Z","comments":true,"path":"JavaScript/定时器中的异步请求堆积如何解决？/","link":"","permalink":"http://www.zsfmyz.top/JavaScript/定时器中的异步请求堆积如何解决？/","excerpt":"说明有时候我们需要用setinterval来执行一些异步操作来刷新页面的信息。但是如果一旦异步函数的请求时间过长，就会造成事件操作堆积。 如： 12345this.interval = setInterval(async () =# &#123; const resp = await ajax(); this.rows = resp.rows; &#125;, 5000); 假设ajax()请求的时间因为网络或者其他原因超过了5秒，定时器并不会等待其返回结果，而是依旧会进行下一次循环，这样的话，其实定时器和异步请求之间的时序并没有联系顺序也毫无规律，那么我们如何实现等本次ajax请求完毕之后等待一段时间之后再进行下一次循环呢？","text":"说明有时候我们需要用setinterval来执行一些异步操作来刷新页面的信息。但是如果一旦异步函数的请求时间过长，就会造成事件操作堆积。 如： 12345this.interval = setInterval(async () =# &#123; const resp = await ajax(); this.rows = resp.rows; &#125;, 5000); 假设ajax()请求的时间因为网络或者其他原因超过了5秒，定时器并不会等待其返回结果，而是依旧会进行下一次循环，这样的话，其实定时器和异步请求之间的时序并没有联系顺序也毫无规律，那么我们如何实现等本次ajax请求完毕之后等待一段时间之后再进行下一次循环呢？ 1.简单代码实现1234567891011121314151617181920212223242526function setIntervalWaitable(callback,ms)&#123; this._self = &#123; fn: callback, timeout: ms, timeoutHandler: null &#125;&#125;setIntervalWaitable.prototype.request = function() &#123; if (this._self.timeoutHandler) &#123; clearTimeout(this._self.timeoutHandler); &#125; this._self.timeoutHandler = setTimeout(() =&gt; &#123; this._self.fn(); &#125;, this._self.timeout);&#125;&lt;!-- 模拟执行 --&gt;&lt;!-- let ms = 2000;let asyncMs = 1000;var set = new setIntervalWaitable(()=&gt;&#123; setTimeout(function()&#123; set.request() &#125;, asyncMs)&#125;, ms)set.request() --&gt; 达到如下效果的异步刷新时序图： 12rfn########----------------rfn##----------------rfn########################----------------rfn####-----------5000ms##########-----5000ms##########---------------------------5000ms########## 2. 改造： 等待传入的ms时间，如果此时callback已经完成，重新执行callback 否则，等待callback完成，再重新执行callback 例如500ms周期时序图:rpc########—-rpc############rpc########################rpc####——–rpc######——rpc####500ms##########500ms##########500ms##########————500ms##########500ms########## 实现思路：在第一题的基础上，在异步函数调用settimeout之前判断异步函数用时和settimeout的时间大小，计算差值，以差值作为下次定时器执行的时间。 如果异步函数用时大于定时器设定时间，直接执行下次异步函数即可 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function setIntervalWaitable2(callback,ms)&#123; this._self = &#123; fn: callback, timeout: ms, timeoutHandler: null, start: null, duration: null &#125;&#125;setIntervalWaitable2.prototype.request = function() &#123; let that = this; let timeout = 0; //首次直接执行事件 if (that._self.timeoutHandler) &#123; clearTimeout(that._self.timeoutHandler); &#125; // 判断 if (that._self.start) &#123; //计算更新timeout值 that._self.duration = new Date().getTime() - that._self.start; if (that._self.duration &lt; that._self.timeout) &#123; timeout = that._self.timeout - that._self.duration; &#125; &#125; that._self.timeoutHandler = setTimeout(() =&gt; &#123; that._self.start = new Date().getTime(); that._self.fn(); &#125;, timeout);&#125;&lt;!-- 模拟执行let ms = 2000;let asyncMs = 1000; //假设异步操作时间var set = new setIntervalWaitable2(()=&gt;&#123; setTimeout(function()&#123; console.log(&apos;函数执行&apos; + new Date().getSeconds()) set.request() &#125;, asyncMs)&#125;, ms)set.request() --&gt;&lt;!-- 实际执行 --&gt; &lt;!-- 实际执行 --&gt;created() &#123; this.interval = new setIntervalWaitable2(()=&gt;&#123; const resp = await getNewStatistics(); this.rows = resp.rows; this.interval.request() &#125;, 500) this.interval.request() //执行 &#125; 3. 实现暂停和重启实现思路:增加flag判断即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 function setIntervalWaitable3(callback,ms)&#123; this._self = &#123; fn: callback, timeout: ms, timeoutHandler: null, timeoutEnabled: true, start: null, duration: null &#125; &#125; setIntervalWaitable3.prototype.request = function() &#123; let that = this; let timeout = 0; if (!that._self.timeoutEnabled) &#123; return; &#125; if (that._self.timeoutHandler) &#123; clearTimeout(that._self.timeoutHandler); &#125; that._self.duration = new Date().getTime() - that._self.start; if (that._self.duration &lt; that._self.timeout) &#123; timeout = that._self.timeout - that._self.duration; &#125; that._self.timeoutHandler = setTimeout(() =&gt; &#123; that._self.start = new Date().getTime(); that._self.fn(); &#125;, timeout); &#125; setIntervalWaitable3.prototype.stop = function() &#123; this._self.timeoutEnabled = false; &#125; setIntervalWaitable3.prototype.restart = function() &#123; this._self.timeoutEnabled = true;this.request() &#125; &lt;!-- 模拟执行 --&gt; &lt;!-- let ms = 2000; let asyncMs = 1000; //假设异步操作时间 var set = new setIntervalWaitable3(()=&gt;&#123; setTimeout(function()&#123; console.log(&apos;函数执行&apos; + new Date().getSeconds()) set.request() &#125;, asyncMs) &#125;, ms) set.request() //执行 --&gt; &lt;!-- 实际执行 --&gt; created() &#123; this.interval = new setIntervalWaitable3(()=&gt;&#123; const resp = await getNewStatistics(); this.rows = resp.rows; this.interval.request() &#125;, 500) this.interval.request() //执行 &#125; destroyed() &#123; this.interval.stop(); &#125; 总结如上实现过程，思路很简单，就是在异步请求结束后手动调起下次循环，这样才能保证时序性。（当然我现在也只能想到这种办法，无论怎么考虑，第二次循环始终需要异步请求结尾处调用。） 目前我已经将该功能进行了封装，对其功能进行了一部分添加和完善。包括两种循环模式。 详情 Github 项目 npm 使用 npm i async-loop-timer","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zsfmyz.top/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zsfmyz.top/tags/JavaScript/"}]},{"title":"Vue性能优化方案","slug":"Vue性能优化方案","date":"2020-03-10T09:05:27.000Z","updated":"2020-03-27T09:56:43.174Z","comments":true,"path":"Vue/Vue性能优化方案/","link":"","permalink":"http://www.zsfmyz.top/Vue/Vue性能优化方案/","excerpt":"背景 总结一下使用Vue涉及到的性能优化方法，从我实践和查阅资源总结出来的集合。 目录： v-if 和 v-show v-if v-show computed 和 watch v-for加key，避免使用v-if keepalive Object.freeze长列表优化","text":"背景 总结一下使用Vue涉及到的性能优化方法，从我实践和查阅资源总结出来的集合。 目录： v-if 和 v-show v-if v-show computed 和 watch v-for加key，避免使用v-if keepalive Object.freeze长列表优化 一、 v-if 和 v-show 一般使用过vue或者angular及其相同框架的人都会知道他们的区别。 v-if它是真正的条件判断语句，会根据条件对条件内的组件进行重建和销毁。它是惰性的，在第一次判断条件为true时，才会去创建相应的组件。即初始化为false时，该条件内组件不会加载。 v-show它仅仅是通过控制css的display属性来控制组件的显示和隐藏。所以，无论是否为false，该组件都会在页面构建时加载。 优化：我们可以在需要频繁切换显示隐藏的组件上使用v-show，在只需要一次或少数判断的时候使用v-if。 二、 computed 和 watch computed 和 watch 都可以对个变量进行监听依赖，但是用法上还是有很大区别的。 如 name = ‘xiaoming’1&lt;div&gt;&#123;&#123; name.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;&lt;/div&gt; 如上我们想把name反转，如此写在html中略显混乱，并对阅读不友好。 computed它表示计算属性，目的是用来方便控制需要计算之后再进行展示的数据。computed属性会被缓存，只有computed所依赖的属性发生变化之后，才会触发computed重新计算。 使用computed 12345678910111213141516171819&lt;div&gt;&#123;&#123; nameReverse &#125;&#125;&lt;/div&gt;// ... data() &#123; return &#123; name: &apos;xiaoming&apos; &#125;; &#125;, computed: &#123; nameReverse: &#123; get: function () &#123; return this.name.split(&apos;&apos;).reverse().join(&apos;&apos;); &#125;, set: function (newValue) &#123; //同时computed也有set函数，可以在计算变量赋值时触发。 //this.name = ... &#125;, &#125; &#125;// ... watchwatch事实上就是一个监听函数，通过监听该变量来执行一些更加复杂的操作。它是比computed更耗费性能的。 注意watch在进入页面之后是不会立即触发的。 使用watch 12345678910111213141516171819&lt;div&gt;&#123;&#123; nameReverse &#125;&#125;&lt;/div&gt;data() &#123; return &#123; name: &apos;xiaoming&apos;, nameReverse: &apos;&apos; //定义 &#125;;&#125;,method: &#123; nameHandler: function (newQuestion, oldQuestion) &#123; this.nameReverse = newQuestion.split(&apos;&apos;).reverse().join(&apos;&apos;); &#125;,&#125;watch: &#123; // &apos;obj.name&apos;: &apos;xxxhandler&apos; 也可以监听深层属性 name:&#123; handler: &quot;nameHandler&quot;, immediate: true //该属性设置之后watch会以当前值立即触发回调函数。 &#125; &#125; 优化：所以我们可以根据computed和watch的不同用法，来区分使用场景。当我们仅仅需要获取一个通过一系列操作后的计算结果，我们应该使用computed。当我们需要在属性变化时进行更加复杂的操作，比如异步操作，设置中间状态进行节流等，这些都需要使用watch实现。 三、 v-for 和 key 避免使用v-if 我们都知道使用v-for的时候要在每个节点加上唯一的key值，否则即采用就地复用的原则，同时避免使用v-if使用computed来代替。 不加key官方文档对key的解释很清楚，key的用途主要用于虚拟DOM对比时对vnode进行辨别。 那么不加key的就地复用是什么意思呢?即当节点被删除或者位置被移动，节点不会被删除或者替换。虚拟DOM将会遍历vnode，直接更改其内容。（该操作是高效的）但是其只适用于渲染列表Dom结构极其简单的情况。 加key加上key之后，对vnode增加了独特的标记，虚拟DOM的对比将不会再遍历vnodes，而是直接采用key的映射进行对比。将会基于key冲i性能排序元素顺序，删除key不存在的节点，替换和删除节点。它也能触发完整的生命周期函数。 v-if 和 computed如果我们的列表只需要渲染其中的一部分，我们可以使用computed，即通过computed对最终显示数据进行过滤，而非在html中进行if判断过滤。 优化：官方建议：建议尽可能在使用 v-for 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。注意： key值需使用使用string和数值型基础类型，不要使用对象数组等复杂类型。同时key值需要独特性。可以使用列如id属性作为key。 四、 keepalive使用keep-alive包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们；keep-alive是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中； 使用keepalive当组件在 内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行。可以保存组件的状态，比如一个下拉框，选择了第二项，切换其他组件再返回时依旧是第二个组件。防止组件重复的销毁和重建。 123456&lt;!-- include表示匹配要缓存的组件名称，exclude表示不缓存的组件名称，exclude优先级更高。 max表示最大缓存数 --&gt;&lt;keep-alive :include=&quot;&quot; :exclude=&quot;&quot; :max=&quot;&quot;&gt; &lt;comp-a v-if=&quot;a &gt; 1&quot;&gt;&lt;/comp-a&gt; &lt;comp-b v-else&gt;&lt;/comp-b&gt;&lt;/keep-alive&gt; keepalive 多了解一点keepalive是vue的一个组件，它自己的生命周期有created和destoryed,。 created用来创建一个cache用来保存需要缓存的Vnode节点，和一个keys数组用来保存cache中对应的key值。destoryed用来遍历缓存节点并逐个调用$destory()进行销毁。 rander首先会获取第一个子组件，获取到名称，然后进行include和exclude过滤，判断是否匹配缓存。如果不符合缓存条件，直接返回vnode，如果符合，则以名称为key值去keys中查找。若命中，则返回cache中的缓存，并将cache中key位置的缓存删除，并添加到cache的末尾。若没命中，则进行缓存并返回vnode，并将其添加至cache尾部。 返回前会将它们的keepAlive属性设置为true用于后面调用activated与deactivated函数。 watch同时keepalive会监听include和exclude的变化，不存在的key将进行销毁并以出cache列表。 keepalive 组件本身并不会生成节点，在keep-alive中，设置了 abstract: true ，该属性表示此组件为抽象组件意思就是不会生成实际节点。 相关荐文 优化：如果你的组件需要保持切换前的状态就需要加上keepalive，或者对于频繁切换的组件也需要加上，以保证它避免被销毁，保存渲染状态，提高性能。 五、 Object.freeze 冻结对象，长列表优化有时候我们会有一些比较长的列表要进行展示，而且这些数据展示完之后并不会发生变化。但是vue对数据都是使用了Object.defineProperty进行了数据劫持，所以初始化时就会造成大量的无用劫持。这时候我们就可以使用Object.freeze进行冻结，冻结之后数据就不会再被修改了。 1this.list = Object.freeze(list); 优化对一些不需要双向绑定的列表进行Object.freeze()进行冻结，提高性能。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://www.zsfmyz.top/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.zsfmyz.top/tags/Vue/"}]},{"title":"Leetcode_101. 对称二叉树","slug":"JavaScript：leetcode_101. 对称二叉树","date":"2019-12-12T03:59:13.000Z","updated":"2020-03-27T09:56:43.175Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_101. 对称二叉树/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_101. 对称二叉树/","excerpt":"题目解析：给定一个二叉树，检查它是否是镜像对称的。 示例示例 1:12345678输入: [1,2,2,3,4,4,3] 对称 1 / \\ 2 2 / \\ / \\3 4 4 3输出: true 示例 2:12345678输入: [1,2,2,null,3,null,3] 非对称 1 / \\ 2 2 \\ \\ 3 3输出: false 说明&amp;&amp;进阶:1如果你可以运用递归和迭代两种方法解决这个问题，会很加分。","text":"题目解析：给定一个二叉树，检查它是否是镜像对称的。 示例示例 1:12345678输入: [1,2,2,3,4,4,3] 对称 1 / \\ 2 2 / \\ / \\3 4 4 3输出: true 示例 2:12345678输入: [1,2,2,null,3,null,3] 非对称 1 / \\ 2 2 \\ \\ 3 3输出: false 说明&amp;&amp;进阶:1如果你可以运用递归和迭代两种方法解决这个问题，会很加分。 解题思路递归，递归判断条件 1. 左右对称的节点是否相同。 2. 递归判断直至叶节点。 解答1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;boolean&#125; */var isSymmetric = function(root) &#123; if (root === null) &#123; return true; &#125; return fun(root.left, root.right);&#125;;var fun = function(left, right) &#123; if (left === null &amp;&amp; right === null) &#123; return true; &#125; if (left === null || right === null) &#123; return false; &#125; return (left.val === right.val) &amp;&amp; fun(left.left, right.right) &amp;&amp; fun(left.right, right.left);&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"Leetcode_112. 路径总和","slug":"JavaScript：leetcode_112. 路径总和","date":"2019-12-12T03:59:13.000Z","updated":"2020-03-27T09:56:43.175Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_112. 路径总和/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_112. 路径总和/","excerpt":"题目解析：给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 示例示例 1:12345678910给定如下二叉树，以及目标和 sum = 22 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。 说明&amp;&amp;进阶:1说明: 叶子节点是指没有子节点的节点。","text":"题目解析：给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 示例示例 1:12345678910给定如下二叉树，以及目标和 sum = 22 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。 说明&amp;&amp;进阶:1说明: 叶子节点是指没有子节点的节点。 解题思路递归，递归判断条件 1. 左右对称的节点是否相同。 2. 递归判断直至叶节点。 解答12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @param &#123;number&#125; sum * @return &#123;boolean&#125; */var hasPathSum = function(root, sum) &#123; if (root === null) &#123; return false; &#125; return fun(root, 0, sum);&#125;;var fun = function(root, mysum, sum) &#123; root.mysum = root.val + mysum; if (root.left === null &amp;&amp; root.right === null)&#123; return root.mysum === sum; &#125; return (root.left &amp;&amp; fun(root.left, root.mysum, sum)) || (root.right &amp;&amp; fun(root.right, root.mysum, sum)) || false; // 或（||）会取最后一个转义为false的值。 即可能会出现0，null，undefined等结果 // 为避免不必要的错误，增加 || false;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"QQ音乐api(持续更新)","slug":"QQ音乐api(持续更新)","date":"2019-12-05T07:10:03.000Z","updated":"2020-06-03T08:04:52.656Z","comments":true,"path":"api/QQ音乐api(持续更新)/","link":"","permalink":"http://www.zsfmyz.top/api/QQ音乐api(持续更新)/","excerpt":"说明2020/6/03 接口已恢复。感谢蒟蒻…的帮助, 才能这么快解决这个问题。有兴趣可以查看他的关于sign获取的文章 2020/5/27 发现获取vkey的接口现在获取不到了，应该是官方换了请求方式，目前播放地址受到了影响，无法播放，修复时间待定。 2020/5/7 之前要使用api的话只能通过服务端请求，嗯嗯..想了想，现在支持跨域了。还是仅测试使用，服务器太渣渣。。经不起造。 2020/2/25 最近在做新的项目，叫小鱼干APP，可以在百度，vivo，小米，apple store 中下载，暂时没有时间来搞这个音乐api的东西了，不过服务没有停，如果想用来测试或者玩玩的还是可以用的。 2019/12/26 更新 获取歌曲播放地址接口 增加 lyric参数代表是否获取歌词。 增加获取歌词接口 2019/12/24 更新 所有音乐接口更改，增加一层music/ ，获取地址改为 music/song 增加福利图片接口 示例接口更改为https 接口仅供交流学习使用 github 项目地址 欢迎star 因为之前使用网络上别人封装的音乐api现在无法使用，或者一些需要付费使用，当然这也无可厚非。 但对我而言，只需要简单的一些音乐api做一些东西。 感觉给钱有点亏。 就自己搞一个简单的符合我的需求的吧。 文档","text":"说明2020/6/03 接口已恢复。感谢蒟蒻…的帮助, 才能这么快解决这个问题。有兴趣可以查看他的关于sign获取的文章 2020/5/27 发现获取vkey的接口现在获取不到了，应该是官方换了请求方式，目前播放地址受到了影响，无法播放，修复时间待定。 2020/5/7 之前要使用api的话只能通过服务端请求，嗯嗯..想了想，现在支持跨域了。还是仅测试使用，服务器太渣渣。。经不起造。 2020/2/25 最近在做新的项目，叫小鱼干APP，可以在百度，vivo，小米，apple store 中下载，暂时没有时间来搞这个音乐api的东西了，不过服务没有停，如果想用来测试或者玩玩的还是可以用的。 2019/12/26 更新 获取歌曲播放地址接口 增加 lyric参数代表是否获取歌词。 增加获取歌词接口 2019/12/24 更新 所有音乐接口更改，增加一层music/ ，获取地址改为 music/song 增加福利图片接口 示例接口更改为https 接口仅供交流学习使用 github 项目地址 欢迎star 因为之前使用网络上别人封装的音乐api现在无法使用，或者一些需要付费使用，当然这也无可厚非。 但对我而言，只需要简单的一些音乐api做一些东西。 感觉给钱有点亏。 就自己搞一个简单的符合我的需求的吧。 文档 所支持的Api 音乐搜索 音乐top100列表 音乐播放地址 福利图片 (新增 2019/12/24). 音乐歌词 (新增 2019/12/26). 很简单的三个基本的功能。 所有方法都是GET 本项目所支持的Api 音乐 music音乐列表list 参数 类型 描述 p string 页码 n string 数目 w string 关键词 返回参数 参数 类型 描述 curpage int 页码 curnum int 数目 list — 音乐列表 eg： 1http://api.zsfmyz.top/music/list?p=1&amp;n=30&amp;w=简单爱 返回参数举例 123456789101112131415161718192021222324252627282930313233343536373839404142 &#123; &quot;curnum&quot;: 41, &quot;curpage&quot;: 1, &quot;list&quot;: [ &#123; &quot;songname&quot;: &quot;简单爱&quot;, &quot;singer&quot;: &#123; &quot;id&quot;: 4558, &quot;mid&quot;: &quot;0025NhlN2yWrP4&quot;, &quot;name&quot;: &quot;周杰伦&quot;, &quot;name_hilight&quot;: &quot;周杰伦&quot; &#125;, &quot;albumname&quot;: &quot;范特西&quot;, &quot;songmid&quot;: &quot;0009BCJK1nRaad&quot;, &quot;albumimg&quot;: &quot;http://imgcache.qq.com/music/photo/album_300/17300_albumpic_8217_0.jpg&quot; &#125;, &#123; &quot;songname&quot;: &quot;简单爱 (Live)&quot;, &quot;singer&quot;: &#123; &quot;id&quot;: 4558, &quot;mid&quot;: &quot;0025NhlN2yWrP4&quot;, &quot;name&quot;: &quot;周杰伦&quot;, &quot;name_hilight&quot;: &quot;周杰伦&quot; &#125;, &quot;albumname&quot;: &quot;周杰伦 2004 无与伦比 演唱会 Live CD&quot;, &quot;songmid&quot;: &quot;0022nw6P1dcHgp&quot;, &quot;albumimg&quot;: &quot;http://imgcache.qq.com/music/photo/album_300/23300_albumpic_14323_0.jpg&quot; &#125;, &#123; &quot;songname&quot;: &quot;简单爱 (Live)&quot;, &quot;singer&quot;: &#123; &quot;id&quot;: 143, &quot;mid&quot;: &quot;003Nz2So3XXYek&quot;, &quot;name&quot;: &quot;陈奕迅&quot;, &quot;name_hilight&quot;: &quot;陈奕迅&quot; &#125;, &quot;albumname&quot;: &quot;2015江苏卫视新年演唱会&quot;, &quot;songmid&quot;: &quot;001IcyF42TKTf1&quot;, &quot;albumimg&quot;: &quot;http://imgcache.qq.com/music/photo/album_300/53300_albumpic_929853_0.jpg&quot; &#125; ]&#125; 音乐top100列表top参数 无 返回参数 参数 类型 描述 date string 日期 curpage int 页码 curnum int 数目 list — 音乐列表 topinfo — 音乐top100信息 list中歌曲信息比普通列表多了排名: cur_count eg： 1https://api.zsfmyz.top/music/top 返回参数举例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137 &#123; &quot;code&quot;: &quot;0&quot;, &quot;data&quot;: &#123; &quot;code&quot;: 0, &quot;date&quot;: &quot;2019-12-05&quot;, &quot;curnum&quot;: 100, &quot;curpage&quot;: 1, &quot;list&quot;: [ &#123; &quot;cur_count&quot;: &quot;1&quot;, &quot;songname&quot;: &quot;像极了&quot;, &quot;singer&quot;: &#123; &quot;id&quot;: 1441799, &quot;mid&quot;: &quot;0023dQD40to8NP&quot;, &quot;name&quot;: &quot;永彬Ryan.B&quot; &#125;, &quot;albumname&quot;: &quot;像极了&quot;, &quot;songmid&quot;: &quot;000V8En93R3Dvd&quot;, &quot;albumimg&quot;: &quot;http://imgcache.qq.com/music/photo/album_300/36300_albumpic_9218636_0.jpg&quot; &#125;, &#123; &quot;cur_count&quot;: &quot;2&quot;, &quot;songname&quot;: &quot;拱手相让&quot;, &quot;singer&quot;: &#123; &quot;id&quot;: 22529, &quot;mid&quot;: &quot;001z6uGh1j5qBh&quot;, &quot;name&quot;: &quot;胜屿&quot; &#125;, &quot;albumname&quot;: &quot;拱手相让&quot;, &quot;songmid&quot;: &quot;002DIlMZ48qB1F&quot;, &quot;albumimg&quot;: &quot;http://imgcache.qq.com/music/photo/album_300/66300_albumpic_9414066_0.jpg&quot; &#125;, &#123; &quot;cur_count&quot;: &quot;3&quot;, &quot;songname&quot;: &quot;余年&quot;, &quot;singer&quot;: &#123; &quot;id&quot;: 1060985, &quot;mid&quot;: &quot;0022eAG537I1bg&quot;, &quot;name&quot;: &quot;肖战&quot; &#125;, &quot;albumname&quot;: &quot;余年&quot;, &quot;songmid&quot;: &quot;000bFWrY2VrdVp&quot;, &quot;albumimg&quot;: &quot;http://imgcache.qq.com/music/photo/album_300/92300_albumpic_9423892_0.jpg&quot; &#125;, &#123; &quot;cur_count&quot;: &quot;4&quot;, &quot;songname&quot;: &quot;触不可及&quot;, &quot;singer&quot;: &#123; &quot;id&quot;: 199509, &quot;mid&quot;: &quot;003fA5G40k6hKc&quot;, &quot;name&quot;: &quot;周深&quot; &#125;, &quot;albumname&quot;: &quot;触不可及&quot;, &quot;songmid&quot;: &quot;002EFRnf3ekI9S&quot;, &quot;albumimg&quot;: &quot;http://imgcache.qq.com/music/photo/album_300/4300_albumpic_9320604_0.jpg&quot; &#125;, &#123; &quot;cur_count&quot;: &quot;5&quot;, &quot;songname&quot;: &quot;冷静和热情之间&quot;, &quot;singer&quot;: &#123; &quot;id&quot;: 198135, &quot;mid&quot;: &quot;001IoTZp19YMDG&quot;, &quot;name&quot;: &quot;易烊千玺&quot; &#125;, &quot;albumname&quot;: &quot;冷静和热情之间&quot;, &quot;songmid&quot;: &quot;0014YYnw3vadJJ&quot;, &quot;albumimg&quot;: &quot;http://imgcache.qq.com/music/photo/album_300/59300_albumpic_9415259_0.jpg&quot; &#125;, &#123; &quot;cur_count&quot;: &quot;6&quot;, &quot;songname&quot;: &quot;美丽谎言&quot;, &quot;singer&quot;: &#123; &quot;id&quot;: 71976, &quot;mid&quot;: &quot;001gthIA2JeIV1&quot;, &quot;name&quot;: &quot;都智文&quot; &#125;, &quot;albumname&quot;: &quot;美丽谎言&quot;, &quot;songmid&quot;: &quot;003sJCeZ1iK9mZ&quot;, &quot;albumimg&quot;: &quot;http://imgcache.qq.com/music/photo/album_300/88300_albumpic_9353488_0.jpg&quot; &#125;, &#123; &quot;cur_count&quot;: &quot;7&quot;, &quot;songname&quot;: &quot;那男孩还好吗&quot;, &quot;singer&quot;: &#123; &quot;id&quot;: 3298773, &quot;mid&quot;: &quot;003yGiqM2qF7Gm&quot;, &quot;name&quot;: &quot;Uu&quot; &#125;, &quot;albumname&quot;: &quot;那男孩还好吗&quot;, &quot;songmid&quot;: &quot;002COmzJ0SPZMl&quot;, &quot;albumimg&quot;: &quot;http://imgcache.qq.com/music/photo/album_300/36300_albumpic_9132036_0.jpg&quot; &#125;, &#123; &quot;cur_count&quot;: &quot;8&quot;, &quot;songname&quot;: &quot;星辰大海&quot;, &quot;singer&quot;: &#123; &quot;id&quot;: 25724, &quot;mid&quot;: &quot;0044vhyY2lfSB8&quot;, &quot;name&quot;: &quot;周冬雨&quot; &#125;, &quot;albumname&quot;: &quot;星辰大海&quot;, &quot;songmid&quot;: &quot;003enTsq4M1J59&quot;, &quot;albumimg&quot;: &quot;http://imgcache.qq.com/music/photo/album_300/63300_albumpic_9305663_0.jpg&quot; &#125;, &#123; &quot;cur_count&quot;: &quot;9&quot;, &quot;songname&quot;: &quot;Lover (Remix)&quot;, &quot;singer&quot;: &#123; &quot;id&quot;: 11921, &quot;mid&quot;: &quot;000qrPik2w6lDr&quot;, &quot;name&quot;: &quot;Taylor Swift&quot; &#125;, &quot;albumname&quot;: &quot;Lover (Remix)&quot;, &quot;songmid&quot;: &quot;000H6p9p0V4MXi&quot;, &quot;albumimg&quot;: &quot;http://imgcache.qq.com/music/photo/album_300/58300_albumpic_9207358_0.jpg&quot; &#125;, ], &quot;topinfo&quot;: &#123; &quot;ListName&quot;: &quot;巅峰榜·新歌&quot;, &quot;MacDetailPicUrl&quot;: &quot;http://y.gtimg.cn/music/common/upload/iphone_order_channel/20150820172435.jpg&quot;, &quot;MacListPicUrl&quot;: &quot;http://y.gtimg.cn/music/common/upload/iphone_order_channel/20150820172427.jpg&quot;, &quot;UpdateType&quot;: &quot;1&quot;, &quot;albuminfo&quot;: &quot;&quot;, &quot;headPic_v12&quot;: &quot;http://y.gtimg.cn/music/common/upload/iphone_order_channel/20150820174934.jpg&quot;, &quot;info&quot;: &quot;集结30天内发行的优质歌曲，鼓励原创、着眼未来的乐坛风向标。根据每日综合数据进行排序，体现QQ音乐用户追新潮流，致力于打造最权威最有公信力的专业健康的新歌排行榜。&lt;br&gt;&lt;br&gt;歌曲数量：100首&lt;br&gt;综合数据：登录用户在QQ音乐收听/分享/下载数据&quot;, &quot;listennum&quot;: 1497166, &quot;pic&quot;: &quot;http://y.gtimg.cn/music/common/upload/iphone_order_channel/20150820172421.jpg&quot;, &quot;picDetail&quot;: &quot;http://y.gtimg.cn/music/common/upload/iphone_order_channel/20150820172414.jpg&quot;, &quot;pic_album&quot;: &quot;http://imgcache.qq.com/music/photo_new/T002R300x300M000000tSk703NJAVD.jpg&quot;, &quot;pic_h5&quot;: &quot;http://y.gtimg.cn/music/common/upload/iphone_order_channel/20150820172242.jpg&quot;, &quot;pic_v11&quot;: &quot;http://y.gtimg.cn/music/common/upload/iphone_order_channel/20150820172421.jpg&quot;, &quot;pic_v12&quot;: &quot;http://y.gtimg.cn/music/photo_new/T003R300x300M000003zALCN1hkB6y.jpg&quot;, &quot;topID&quot;: &quot;27&quot;, &quot;type&quot;: &quot;0&quot; &#125; &#125;&#125; 音乐播放地址song 参数 类型 描述 songmid string 用于获取token guid string 用于获取token lyric string 默认为0不获取歌词，1获取歌词 其他参数固定 返回参数 参数 类型 描述 musicUrl string 音乐播放地址 eg: 1https://api.zsfmyz.top/music/song?songmid=003lghpv0jfFXG&amp;guid=126548448 返回参数举例 1234567 &#123; &quot;code&quot;: &quot;0&quot;, &quot;data&quot;: &#123; &quot;musicUrl&quot;: &quot;http://ws.stream.qqmusic.qq.com/C400003lghpv0jfFXG.m4a?fromtag=0&amp;guid=126548448&amp;vkey=7888A32FC10168AAD914CA484401762D7F060E7337C0B9187D8B907681BB177669ADB3DFBF398E0FC4D6ED1E0EC7574716872D7B5FE14322&quot;, &quot;lyric&quot;: &quot;无&quot; &#125;&#125; 音乐歌词lyric 参数 类型 描述 songmid string 用于获取歌词 其他参数固定 返回参数 参数 类型 描述 lyric string 歌词内容 eg: 1https://api.zsfmyz.top/music/lyric?songmid=000wocYU11tSzS 返回参数举例 1234567 &#123; &quot;code&quot;: &quot;0&quot;, &quot;data&quot;: &#123; &quot;lyric&quot;: &quot;[ti:差不多姑娘]\\n[ar:G.E.M. 邓紫棋]\\n[al:差不多姑娘]\\n[by:]\\n[offset:0]\\n[00:00.00]差不多姑娘 - G.E.M. 邓紫棋\\n[00:00.17]\\n[00:02.67]差不多的姑娘\\n[00:06.27]追逐差不多的漂亮\\n[00:11.88]她们差不多的愿望\\n[00:17.18]牵着她们鼻子方向\\n[00:23.05]我回到差不多的家\\n[00:24.38]躺在差不多的沙发\\n[00:25.68]微博差不多的刷\\n[00:26.99]都吃着差不多的瓜\\n[00:28.48]那标题差不多的炸\\n[00:29.78]...&quot;, &#125; &#125;&#125; 福利图片 welfare 根据每日福利社的接口进行了封装，因为他们的https失效了，所以自己反向代理了。 图片列表list 参数 类型 描述 per_page string 每页数据量 page string 第几页 其他参数固定 返回参数 如下： eg: 1https://api.zsfmyz.top/welfare/list?per_page=20&amp;page=2 返回参数举例 12345678910111213141516171819202122232425262728293031&#123; &quot;code&quot;: 0, &quot;data&quot;: &#123; &quot;error&quot;: false, &quot;results&quot;: [ &#123; &quot;_id&quot;: &quot;5b63cd4e9d21225e0d3f58c9&quot;, &quot;createdAt&quot;: &quot;2018-08-03T11:34:38.672Z&quot;, &quot;desc&quot;: &quot;2018-08-03&quot;, //描述 &quot;publishedAt&quot;: &quot;2018-08-03T00:00:00.0Z&quot;, &quot;source&quot;: &quot;api&quot;, &quot;type&quot;: &quot;福利&quot;, // 类型 &quot;url&quot;: &quot;https://ww1.sinaimg.cn/large/0065oQSqgy1ftwcw4f4a5j30sg10j1g9.jpg&quot;, //图片地址 &quot;used&quot;: true, &quot;who&quot;: &quot;lijinshan&quot; &#125;, &#123; &quot;_id&quot;: &quot;5b6151509d21225206860f08&quot;, &quot;createdAt&quot;: &quot;2018-08-01T14:21:04.556Z&quot;, &quot;desc&quot;: &quot;2018-08-01&quot;, &quot;publishedAt&quot;: &quot;2018-08-01T00:00:00.0Z&quot;, &quot;source&quot;: &quot;api&quot;, &quot;type&quot;: &quot;福利&quot;, &quot;url&quot;: &quot;https://ww1.sinaimg.cn/large/0065oQSqly1ftu6gl83ewj30k80tites.jpg&quot;, &quot;used&quot;: true, &quot;who&quot;: &quot;lijinshan&quot; &#125;, // ... ] &#125;&#125; over 暂时只有这 ~~ 三 ~~ 四个，不过做一个音乐demo足够了，有兴趣的话可以试试。 ~~ http://api.zsfmyz.top/ ~~ https://api.zsfmyz.top/ 是目前开放的api接口地址，可直接食用。 原接口说明搜索 https://c.y.qq.com/soso/fcgi-bin/client_search_cp?aggr=1&amp;cr=1&amp;flag_qc=0&amp;p=1&amp;n=30&amp;w=简单爱 封面 http://imgcache.qq.com/music/photo/album_300/[albumid%100]/300_albumpic_[albumid]_0.jpg, albumid%100, albumid 比如albumid=8217，封面地址就是 http://imgcache.qq.com/music/photo/album_300/17/300_albumpic_8217_0.jpg。 歌曲token https://c.y.qq.com/base/fcgi-bin/fcg_music_express_mobile3.fcg?format=json205361747&amp;platform=yqq&amp;cid=205361747&amp;songmid=003lghpv0jfFXG&amp;filename=C400003lghpv0jfFXG.m4a&amp;guid=126548448 songmid可以从歌曲信息中取到，filename根据songmid生成。 比如，songmid是003lghpv0jfFXG，则filename就是前缀加上C400，后缀加上.m4a，即C400003lghpv0jfFXG.m4a。 其他字段format、platform、cid、guid可以写死，但都是必须的。 拼接播放地址 http://ws.stream.qqmusic.qq.com/C400003lghpv0jfFXG.m4a?fromtag=0&amp;guid=126548448&amp;vkey=D661E5DF19B8FEB2FBFC554276746AC608AE98B0F30595B3B3BAD5C1C89ECCDD7BE599E306F786621856D22D6BD6B96F5DD344CF3814DB71 原文依据","categories":[{"name":"api","slug":"api","permalink":"http://www.zsfmyz.top/categories/api/"}],"tags":[{"name":"api","slug":"api","permalink":"http://www.zsfmyz.top/tags/api/"}]},{"title":"Git入门篇","slug":"Git入门篇","date":"2019-11-28T07:14:27.000Z","updated":"2020-03-27T09:56:43.174Z","comments":true,"path":"Git/Git入门篇/","link":"","permalink":"http://www.zsfmyz.top/Git/Git入门篇/","excerpt":"开始 首先我们需要去github官网申请git账号。git官网 申请之后，我们进入自己的linux服务器 安装git 123yum install -y gitgit --version","text":"开始 首先我们需要去github官网申请git账号。git官网 申请之后，我们进入自己的linux服务器 安装git 123yum install -y gitgit --version 配置 ssh-keygen 1234// 生成keyssh-keygen//查看公钥 cat ~/.ssh/id_rsa.pub 然后在GitHub上加入这个公钥 配置公钥 设置git命令的简写模式（alias） 1234git config --global alias.co checkoutgit config --global alias.br branchgit config --global alias.ci commitgit config --global alias.st status 设置自己的名字和邮箱 12git config --global user.name &quot;your name&quot;git config --global user.email &quot;your email @.com&quot; fork 如果你想使用别人的项目，就需要fork。 一般我们参与公司项目，都会先fork公司的仓库。 clone 进入一个你想存放项目的文件夹。 如图复制ssh地址。 一般我们复制的这个ssh地址，是先fork了公司的仓库，然后回到自己的仓库下面复制自己的ssh。 1git clone git@github.com:xxx/xxx.git 然后就可以对代码进行修改和提交了。 checkout 项目有不同的分支。一般本地主分支为master。自己的远程仓库为 origin如果是公司的项目，可能还会添加一个公司仓库 gongsi 可以用以下命令查看。1git br -va 一般我们都master分支上。 那么当我们修改了master分支的文件，但是又想恢复它到我们修改之前的状态，就需要checkout 1git co xxx.html checkout也可以创建本地分支: origin/develop为远程仓库origin里面的一条分支， 我们要在本地创建一条和它一样的分支。 1git co -b develop origin/develop 另一种情况 本地和远程都只有master分支， 我们要在master的基础上添加订制功能， 需要独立出来一条和master一样的分支，然后再修改。 12345git co -b develop origin/master# 增加完新功能之后git push origin develop 这样就会在本地和远程origin都创建了一条develop分支完成定制功能的添加又不影响原来的master分支。 commit 当我们修改某个文件，使用git st就可以看到哪些文件被修改了。然后使用 git add 可以将我们修改过的文件添加进暂存区123git stgit add xxx.html commit为某次修改的描述，是阶段性的。我们每完成一个功能，或者每修复一个bug，最好都进行一次提交。 1git ci -m &apos;描述&apos; 最后将代码push到我们的远程分支 1git push origin master(分支名) show提交了之后，下一次我们想看看我们以前某次提交的东西是什么。 12git loggit show 版本号 这样可以查看该版本提交的东西，当然我们也可以上git去查看。 reset有时候我们会后悔添加了文件。那么可以用reset 返回 1git reset xxx.html 这样就可以返回add之前的文件状态。 同样的我们如果已经push到远程分支了 想要回到我们push之前的状态，或者再之前的某个版本。 12git refloggit reset --hard 版本号 以上两个步骤，第一步是查看我们这个分支的所有版本号。 复制你想要回退的版本号，然后执行第二步，就会回退到目标版本了。 然后再次执行你想要add，ci，push等命令，将你想要提交的文件push到远程。 fetch/merge push之后我们的远程分支就会和本地分支的内容一样了。 但是如果我们是一个公共项目，那就需要并入公共仓库（gongsi）。 这个就需要管理员来操作了。 等管理员合并了之后，别人就需要fetch并且merge你的代码，以此来使大家的代码都是同步的。 123git fetch --allgit merge gongsi/master 每次push之前我们都应该先merge一下公共仓库的代码。以免我们在旧代码上修改提交导致冲突。 delete 那么我们如何删除自己的本地分支和远程分支呢，拿new_master举例 12git br -d new_mastergit push origin -d new_master remote 当我们从某个git地址clone下来仓库后，仓库的远程地址就是你所clone的地址。 此时如果我们想修改我们的远程仓库怎么办呢（也就是修改origin的远程地址） 那就用到remote了 首先查看远程地址：1git remote -v 然后修改远程地址 1234git remote set-url [仓库名称] [url]# 例如：修改origin这个仓库的远程地址。# git remote set-url origin git@github.com:xiaoming/project.git 那么如果要新添加一个远程地址呢？比如我们添加公司的（或者其他任何）。 1234git remote add [自定义远程仓库名] [url]# 例如：# git remote add gongsi git@github.com:gongsi/project.git 添加完公司的仓库之后，我们远程公司的仓库有了，但是本地还没有，怎么办呢，就用到前面的checkout了。 1234git co -b [创建本地分支名] [远程仓库名/远程仓库分支名]# 例如：创建一个本地分支 develop 该分支的内容和gongsi/develop分支的内容一致。# git co -b develop gongsi/develop 推送到自己的远程分支。如果我们的origin上没有 develop 分支，那就会自动创建一个。 这样就保持三个分支一致了。 1git push origin develop stash 有的时候，我们正在修改master分支。突然有一个紧急需求需要在develop上修改。 但是master还没有修改完，我们不能切换分支。 那怎么办呢？我们可以使用stash。 1234567git stashgit co developgit co mastergit stash pop 以上三个步骤 第一步 将我们修改的内容缓存起来 第二步 切换到develop 分支,然后修改提交之后 第三步 切换到master分支 第四步 恢复切换到develop之前的master分支的修改内容。 以上就是常用的git命令，当然还有更多的和更深的命令，可以扩展了解一下。 另外我们装完git如果颜色都是白色的，会感觉不太容易区分。可以配置下颜色 1234git config --global color.status autogit config --global color.diff autogit config --global color.branch autogit config --global color.interactive auto","categories":[{"name":"Git","slug":"Git","permalink":"http://www.zsfmyz.top/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.zsfmyz.top/tags/Git/"}]},{"title":"linux文件共享服务(Samba安装配置)","slug":"linux文件共享服务(samba安装配置)","date":"2019-11-27T10:14:27.000Z","updated":"2020-03-27T09:56:43.175Z","comments":true,"path":"Linux/linux文件共享服务(samba安装配置)/","link":"","permalink":"http://www.zsfmyz.top/Linux/linux文件共享服务(samba安装配置)/","excerpt":"我们的服务器基本都是linux系统的，但是我们需要在windows下开发。 解决方案有两种： 通过git同步linux和windows下的代码。 通过文件共享使windows连接linux下的共享文件夹 现在说第二种方式如何实现： Samba的介绍我就不多说了，总结一下就是可以在windows下操作编辑linux里面共享的内容。","text":"我们的服务器基本都是linux系统的，但是我们需要在windows下开发。 解决方案有两种： 通过git同步linux和windows下的代码。 通过文件共享使windows连接linux下的共享文件夹 现在说第二种方式如何实现： Samba的介绍我就不多说了，总结一下就是可以在windows下操作编辑linux里面共享的内容。 #####（一）samba 安装 安装之前用rpm确定一下自己的服务器是否已经安装过了。 1rpm -qa | grep samba 如果没有，我们就通过yum来下载rpm包来安装它 1yum install -y samba 安装完成之后可以再通过第一条命令查看是否安装成功。 安装成功之后，我们就需要修改samba的配置文件了。 #####（二）samba 配置 一般都在etc中 1vim /etc/samba/smb.conf 打开之后其他的不用管，在该配置文件的末尾增加一段 例如我们要共享根目录下的opt文件夹 1234567[opt] comment = OPT path = /opt/ public = yes writable = yes printable = no guest ok = yes path 是你要共享的路径。 保存之后重启服务。 12345systemctl start smbsystemctl restart smbsystemctl stop smb 重启完之后基本samba就算安装配置完成。 想要使用还需要配置samba所需要的端口。 #####（三）配置 samba 端口 在这里使用阿里云服务器举例。 如图添加安全组规则 分别添加 136/138和445端口。 至此linux系统的问题都ok了。 #####（四）映射网络驱动器 然后到你的windows系统中 右键我的电脑，映射网络驱动器。 输入\\ip\\xxx 以opt为例：\\ip\\opt ,ip为你的linux服务器ip 点击完成输入你的用户和密码。 我们也可以创建一个用来使用samba的用户 1smbpasswd -a xiaoming #添加用户xiaoming到Samba用户中 然后接着会让你设置密码，设置完之后。重启samba就可以了。 #####（五）配置 samba 防火墙 如果连接不上，请关闭windows的防火墙试试。 如果还不行就设置下linux的防火墙 iptables 123456iptables -I RH-Firewall-1-INPUT 5 -m state --state NEW -m tcp -p tcp --dport 139 -j ACCEPTiptables -I RH-Firewall-1-INPUT 5 -m state --state NEW -m tcp -p tcp --dport 445 -j ACCEPTiptables -I RH-Firewall-1-INPUT 5 -p udp -m udp --dport 137 -j ACCEPTiptables -I RH-Firewall-1-INPUT 5 -p udp -m udp --dport 138-j ACCEPTiptables-savesystemctl restart iptables selinux 12setsebool -P samba_enable_home_dirs onsetsebool -P samba_export_all_rw on 然后重新映射网络位置。 #####（六）放弃 如果还不可以，那放弃就好了。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.zsfmyz.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.zsfmyz.top/tags/Linux/"}]},{"title":"Leetcode_145. 二叉树的后序遍历","slug":"JavaScript：leetcode_145. 二叉树的后序遍历","date":"2019-11-17T03:59:13.000Z","updated":"2020-03-27T09:56:43.175Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_145. 二叉树的后序遍历/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_145. 二叉树的后序遍历/","excerpt":"题目解析：给定一个二叉树，返回它的 后序 遍历。 示例示例 1:12345678输入: [1,null,2,3] 1 \\ 2 / 3 输出: [3,2,1] 说明&amp;&amp;进阶:1234 递归算法很简单，你可以通过迭代算法完成吗？前序排列的顺序是左，右，父。","text":"题目解析：给定一个二叉树，返回它的 后序 遍历。 示例示例 1:12345678输入: [1,null,2,3] 1 \\ 2 / 3 输出: [3,2,1] 说明&amp;&amp;进阶:1234 递归算法很简单，你可以通过迭代算法完成吗？前序排列的顺序是左，右，父。 解题思路递归，递归判断条件，该节点左右节点是否为null，递归时先左后右。 跟前序遍历唯一的差别是最后再push。 解答12345678910111213141516171819202122232425/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */ let postorderArr = []; let addNode = (root) =&gt; &#123; root.left &amp;&amp; addNode(root.left); root.right &amp;&amp; addNode(root.right); postorderArr.push(root.val) // 唯一的差别 &#125; let postorderTraversal = (root) =&gt; &#123; postorderArr = []; if (!root) &#123; return postorderArr; &#125; addNode(root); return postorderArr; &#125;; 解题思路二 迭代法，基于栈的特性将递推出来的节点压进栈中。然后遵循先进后出的原则，直至将栈排空。 后序遍历的迭代法比较前序遍历要复杂一些。 我的思路是打表，已经遍历过的节点需要标记（截断）。 解答二12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */let postorderArr = [], nodeList = [], nowNode;let postorderTraversal = (root) =&gt; &#123; postorderArr = []; if (!root) &#123; return postorderArr; &#125; nodeList = [], nowNode = root; while(nodeList.length &gt; 0 || nowNode) &#123; while (nowNode) &#123; nowNode.flag = true; // 标记该节点已经进入过数组 nodeList.push(nowNode); //如果该节点的左节点已经遍历过了就不需要遍历了 先左 if (nowNode.left &amp;&amp; !nowNode.left.flag) &#123; nowNode = nowNode.left; //如果该节点的右节点已经遍历过了就不需要遍历了 后右 &#125; else if (nowNode.right &amp;&amp; !nowNode.right.flag) &#123; nowNode = nowNode.right; &#125; else &#123; //左右节点都遍历过的相当于叶节点（度为0，没有子节点） nowNode = null; &#125; &#125; // 从栈中取值 nowNode = nodeList.pop(); // 用来区分是否为叶节点 若为叶则赋值null，遍历下一轮。 if (!nowNode.right || nowNode.right.flag) &#123; postorderArr.push(nowNode.val); nowNode = null; &#125; &#125; return postorderArr;&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"Leetcode_144. 二叉树的前序遍历","slug":"JavaScript：leetcode_144. 二叉树的前序遍历","date":"2019-10-17T03:59:13.000Z","updated":"2020-03-27T09:56:43.175Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_144. 二叉树的前序遍历/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_144. 二叉树的前序遍历/","excerpt":"题目解析：给定一个二叉树，返回它的 前序 遍历。 示例示例 1:12345678输入: [1,null,2,3] 1 \\ 2 / 3 输出: [1,2,3] 说明&amp;&amp;进阶:1234 递归算法很简单，你可以通过迭代算法完成吗？前序排列的顺序是父节点在前，然后遍历左树，然后遍历右树。","text":"题目解析：给定一个二叉树，返回它的 前序 遍历。 示例示例 1:12345678输入: [1,null,2,3] 1 \\ 2 / 3 输出: [1,2,3] 说明&amp;&amp;进阶:1234 递归算法很简单，你可以通过迭代算法完成吗？前序排列的顺序是父节点在前，然后遍历左树，然后遍历右树。 解题思路递归，递归判断条件，该节点左右节点是否为null，递归时先左后右。 解答12345678910111213141516171819202122232425/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */let frontArr = [];let addNode = (root) =&gt; &#123; frontArr.push(root.val) root.left &amp;&amp; addNode(root.left); root.right &amp;&amp; addNode(root.right);&#125;let preorderTraversal = (root) =&gt; &#123; frontArr = []; if (!root) &#123; return frontArr; &#125; addNode(root); return frontArr;&#125;; 解题思路二 迭代法，基于栈的特性将递推出来的节点压进栈中。然后遵循先进后出的原则，直至将栈排空。 解答二123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */let frontArr = [], nodeList = [], nowNode;let preorderTraversal = (root) =&gt; &#123; frontArr = []; if (!root) &#123; return frontArr; &#125; nodeList = [root]; while(nodeList.length &gt; 0) &#123; nowNode = nodeList.pop(); frontArr.push(nowNode.val); nowNode.right &amp;&amp; nodeList.push(nowNode.right); nowNode.left &amp;&amp; nodeList.push(nowNode.left); &#125; return frontArr;&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"Leetcode_94. 二叉树的中序遍历","slug":"JavaScript：leetcode_94. 二叉树的中序遍历","date":"2019-10-17T03:59:13.000Z","updated":"2020-03-27T09:56:43.175Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_94. 二叉树的中序遍历/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_94. 二叉树的中序遍历/","excerpt":"题目解析：给定一个二叉树，返回它的 中序 遍历。 示例示例 1:12345678输入: [1,null,2,3] 1 \\ 2 / 3 输出: [1,3,2] 说明&amp;&amp;进阶:1234 递归算法很简单，你可以通过迭代算法完成吗？前序排列的顺序是左，父，右。","text":"题目解析：给定一个二叉树，返回它的 中序 遍历。 示例示例 1:12345678输入: [1,null,2,3] 1 \\ 2 / 3 输出: [1,3,2] 说明&amp;&amp;进阶:1234 递归算法很简单，你可以通过迭代算法完成吗？前序排列的顺序是左，父，右。 解题思路递归，递归判断条件，该节点左右节点是否为null，递归时先左后右。 解答12345678910111213141516171819202122232425/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */var addNode = function (root) &#123; root.left &amp;&amp; addNode(root.left); inorderArr.push(root.val); // 前，中序遍历唯一区别 root.right &amp;&amp; addNode(root.right);&#125;let inorderArr = [];var inorderTraversal = function(root) &#123; inorderArr = []; if (!root) &#123; return inorderArr; &#125; addNode(root); return inorderArr&#125;; 解题思路二 迭代法，基于栈的特性将递推出来的节点压进栈中。然后遵循先进后出的原则，直至将栈排空。 解答二123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */let inorderArr = [], nodeList = [], nowNode;var inorderTraversal = function(root) &#123; inorderArr = [], nodeList = [], nowNode = root; if (!root) &#123; return inorderArr; &#125; while(nodeList.length &gt; 0 || nowNode) &#123; while (nowNode) &#123; nodeList.push(nowNode); nowNode = nowNode.left; &#125; nowNode = nodeList.pop(); inorderArr.push(nowNode.val); nowNode = nowNode.right; &#125; return inorderArr&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"Leetcode_264. 丑数 II","slug":"JavaScript：leetcode_264. 丑数 II","date":"2019-10-12T03:59:13.000Z","updated":"2020-03-27T09:56:43.175Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_264. 丑数 II/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_264. 丑数 II/","excerpt":"题目解析：编写一个程序，找出第 n 个丑数。 丑数就是只包含质因数 2, 3, 5 的正整数。 示例示例 1:123输入: n = 10输出: 12解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 提示：121 是丑数。n 不超过1690。","text":"题目解析：编写一个程序，找出第 n 个丑数。 丑数就是只包含质因数 2, 3, 5 的正整数。 示例示例 1:123输入: n = 10输出: 12解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 提示：121 是丑数。n 不超过1690。 解题思路方法一暴力循环（毫无疑问超时了） 解答12345678910111213141516171819202122232425var isUgly = function(num) &#123; if (num &lt; 1) &#123; return false; &#125; while(num % 2 == 0) &#123; num/=2 &#125; while(num % 3 == 0) &#123; num/=3 &#125; while(num % 5 == 0) &#123; num/=5 &#125; return (num == 1) ? true : false;&#125;; var nthUglyNumber = function(n) &#123; var ugly = 1; for (var i = 0; i &lt; n; ugly++) &#123; if (isUgly(ugly)) &#123; i++; &#125; &#125; return ugly;&#125;; 解题思路二1. 根据题目的意思，我们首先知道丑数的因子只能是(2, 3, 5). 当我们要从[1],推算出[1,2,3,4,5,6,8,9...]丑数序列时,过程如下 var arr = [1]; 推算第二个数：比较arr[0]*2 和 arr[0]*3 和arr[0]*5 中取最小的一个arr[0]*2 放进数组中： [1, arr[0]*2]。 依次类推下次比较：arr[1]*2 和 arr[0]*3 和 arr[0]*5 中取最小arr[0]*3 放进数组中： [1, arr[0]*2, arr[0]*3] 依次类推下次比较：arr[1]*2 和 arr[1]*3 和 arr[0]*5 中取最小arr[1]*2 放进数组中： [1, arr[0]*2, arr[0]*3, arr[1]*2] 等等。。 2. 由上可以看出，我们需要丑数组arr, 还有2,3,5三个质因数分别乘到了arr的第几个数。 拿2作例子：我们需要知道数组的前多少个已经乘过2了。当arr[0]*2 之后， 下次就该arr[1]*2跟其他的作比较了。 即这2，3，5需要三个标记。在上面举例中第三次之后的下标为：[2, 1, 0]. 即下次比较应该用arr[2]*2 和 arr[1]*3 和arr[0]*5 来比较哪个小。 3. 中间会遇到比如 arr[2]*2 == arr[1]*3 这样的情况。 此时把2，3 的下标都+1即可. 最后依次求到目标数组arr的第n个数即为答案。 解答二1234567891011121314151617181920var nthUglyNumber = function(n) &#123; var arr = [1], indexArr = [0, 0, 0],v2,v3,v5,temp; for(var i = 0; i &lt;= n; i++) &#123; v2 = arr[indexArr[0]] * 2; v3 = arr[indexArr[1]] * 3; v5 = arr[indexArr[2]] * 5; temp = Math.min(v2,Math.min(v3,v5)); // 判断最小 if (temp == v2) &#123; indexArr[0]++; &#125; if (temp == v3) &#123; indexArr[1]++; &#125; if (temp == v5) &#123; indexArr[2]++; &#125; arr.push(temp); &#125; return arr[n-1];&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"Leetcode_26. 删除排序数组中的重复项","slug":"JavaScript：leetcode_26. 删除排序数组中的重复项","date":"2019-09-27T03:59:13.000Z","updated":"2020-03-27T09:56:43.175Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_26. 删除排序数组中的重复项/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_26. 删除排序数组中的重复项/","excerpt":"题目解析：给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例示例 1:12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2:12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 提示： 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125;","text":"题目解析：给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例示例 1:12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2:12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 提示： 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解题思路题目中原地的意思大概就是要在原数组中操作不能开辟新的数组空间。 题目简单，就是去除数组中的重复元素。 首先想到的是删除数组中的重复元素，用到了splice。 解答123456789var removeDuplicates = function(nums) &#123; for (var i = 0; i &lt; nums.length; i++) &#123; if (nums.includes(nums[i], i + 1)) &#123; nums.splice(i, 1); i--; &#125; &#125; return nums.length;&#125;; 解题思路二由于第一种方法用到了splice，所以其实时空间复杂度还是比较高的。 所以，根据题目要求我们其实只需要保证数组的前面排列的是我们需要的就可以了。超过的部分我可以忽略不计。 那其实就是依次从头填充数组就可以了！直到遍历完数组的最后一位。 双指针就解决了。一个用来遍历数组，一个用来从头修改数组。 由于题目告诉为排序数组，所以我们可以用i，i+1判断。 解答二12345678910var removeDuplicates = function(nums) &#123; var next = 0; for (var i = 0; i &lt; nums.length; i++) &#123; if (nums[i] != nums[i+1]) &#123; nums[next] = nums[i]; next++; &#125; &#125; return next;&#125;; 解题思路三了解一下ES6的array.includes(searchEle, fromIndex); 判断数组种是否含有searchEle。(true / false); searchEle为搜索的元素（必填），fromIndex为从数组的哪一位开始搜索。 使用includes同时可以判断非排序的数组 解答三12345678910var removeDuplicates = function(nums) &#123; var j = 0; for (var i = 0; i &lt; nums.length; i++) &#123; if (!nums.includes(nums[i], i + 1)) &#123; nums[j] = nums[i]; j++; &#125; &#125; return j;&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"Leetcode_5198. 丑数 III","slug":"JavaScript：leetcode_5198. 丑数 III","date":"2019-09-26T03:59:13.000Z","updated":"2020-03-27T09:56:43.175Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_5198. 丑数 III/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_5198. 丑数 III/","excerpt":"题目解析：请你帮忙设计一个程序，用来找出第 n 个丑数。 丑数是可以被 a 或 b 或 c 整除的 正整数。 示例示例 1:123输入：n = 3, a = 2, b = 3, c = 5输出：4解释：丑数序列为 2, 3, 4, 5, 6, 8, 9, 10... 其中第 3 个是 4。 示例 2:123输入：n = 4, a = 2, b = 3, c = 4输出：6解释：丑数序列为 2, 3, 4, 6, 8, 9, 12... 其中第 4 个是 6。 示例 3:123输入：n = 5, a = 2, b = 11, c = 13输出：10解释：丑数序列为 2, 4, 6, 8, 10, 11, 12, 13... 其中第 5 个是 10。 示例 4:12输入：n = 1000000000, a = 2, b = 217983653, c = 336916467输出：1999999984 提示：1231 &lt;= n, a, b, c &lt;= 10^91 &lt;= a * b * c &lt;= 10^18本题结果在 [1, 2 * 10^9] 的范围内","text":"题目解析：请你帮忙设计一个程序，用来找出第 n 个丑数。 丑数是可以被 a 或 b 或 c 整除的 正整数。 示例示例 1:123输入：n = 3, a = 2, b = 3, c = 5输出：4解释：丑数序列为 2, 3, 4, 5, 6, 8, 9, 10... 其中第 3 个是 4。 示例 2:123输入：n = 4, a = 2, b = 3, c = 4输出：6解释：丑数序列为 2, 3, 4, 6, 8, 9, 12... 其中第 4 个是 6。 示例 3:123输入：n = 5, a = 2, b = 11, c = 13输出：10解释：丑数序列为 2, 4, 6, 8, 10, 11, 12, 13... 其中第 5 个是 10。 示例 4:12输入：n = 1000000000, a = 2, b = 217983653, c = 336916467输出：1999999984 提示：1231 &lt;= n, a, b, c &lt;= 10^91 &lt;= a * b * c &lt;= 10^18本题结果在 [1, 2 * 10^9] 的范围内 解题思路方法一暴力循环（毫无疑问超时了） 解答123456789 var nthUglyNumber = function(n, a, b, c) &#123; var num = 1; for (var i = 1; i &lt;= n; num++) &#123; if (num % a == 0 || num % b == 0 || num % c == 0) &#123; i++; &#125; &#125; return num - 1;&#125;; 解题思路二1.找出该数可能存在的范围，首先可以思考判断得出最小的值为n ，最大为min(a,b,c) * n 2.假设最终结果为finalValue，求出该值的序列长度nums。 例如：下面的例子中finalValue为6，而其序列就为[2, 3, 4, 6],长度为4===n。 123输入：n = 4, a = 2, b = 3, c = 4输出：6解释：丑数序列为 2, 3, 4, 6, 8, 9, 12... 其中第 4 个是 6。 3.通过二分法查找finalValue 4.判断条件为: nums.length === n ? ，如果相等即为该值。 ** 注意：finalValue必须符合是a，b，c的倍数，且是所有符合条件的值中最小的一个。 ** 解答二123456789101112131415161718192021222324252627282930313233343536373839//最大公约数 ：a和 a%b 的最大公约数 和 a 和 b 的最大公约数一致var maxComFn = function(a, b) &#123; if (a % b === 0) &#123; return b; &#125; else &#123; return maxComFn(b, a % b); &#125;&#125;//最小公倍数 公式法： a*b === a和b的最大公约数 * a和b的最小公倍数var minComFn = function(a, b) &#123; var maxC = maxComFn(a, b) return a * b / maxC;&#125;//值的序列长度 容斥定理， 含有a，b，c的个数 - ab，ac，bc的公倍数的个数 + abc公倍数的个数var inNumsFn = function(a, b, c, num) &#123; return Math.floor(num / a) + Math.floor(num / b) + Math.floor(num / c) - Math.floor(num / minComFn(a, b)) - Math.floor(num / minComFn(a, c)) - Math.floor(num / minComFn(c, b)) + Math.floor(num / minComFn(c, minComFn(a, b)));&#125;var nthUglyNumber = function(n, a, b, c) &#123; var maxCom = maxComFn(a, maxComFn(b, c)); let mid, left = n, right = n * Math.min(a, b, c); while (left &lt; right) &#123; mid = Math.floor((left + right) / 2); if (inNumsFn(a, b, c, mid) &lt; n) &#123; left = mid + 1; &#125; else &#123; right = mid; //一直求到最小。 &#125; &#125; return right;&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"Leetcode_1189. “气球” 的最大数量","slug":"JavaScript：leetcode_1189. “气球” 的最大数量","date":"2019-09-25T03:59:13.000Z","updated":"2020-03-27T09:56:43.175Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_1189. “气球” 的最大数量/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_1189. “气球” 的最大数量/","excerpt":"题目解析：给你一个字符串 text，你需要使用 text 中的字母来拼凑尽可能多的单词 “balloon”（气球）。 字符串 text 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 “balloon”。 示例示例 1:12输入：text = &quot;nlaebolko&quot;输出：1 示例 2:12输入：text = &quot;loonbalxballpoon&quot;输出：2 提示：121 &lt;= text.length &lt;= 10^4text 全部由小写英文字母组成","text":"题目解析：给你一个字符串 text，你需要使用 text 中的字母来拼凑尽可能多的单词 “balloon”（气球）。 字符串 text 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 “balloon”。 示例示例 1:12输入：text = &quot;nlaebolko&quot;输出：1 示例 2:12输入：text = &quot;loonbalxballpoon&quot;输出：2 提示：121 &lt;= text.length &lt;= 10^4text 全部由小写英文字母组成 解题思路先找出各个字母的个数，然后找出其中的最小值(o,l数量除以2)。 用match正则检测字符串中符合条件的字母，其长度即为该字母在字符串中的个数。 解答123456789101112var maxNumberOfBalloons = function(text) &#123; let regexp, singleNum, min = text.length; for (let i in &quot;balon&quot;) &#123; regexp = new RegExp(&quot;balon&quot;[i], &apos;g&apos;); singleNum = text.match(regexp).length; if (&quot;balon&quot;[i]) == &apos;o&apos; || &quot;balon&quot;[i]) == &apos;l&apos;) &#123; singleNum = Math.floor(singleNum / 2) &#125; min = (min &lt;= singleNum) ? min : singleNum; &#125; return min;&#125;; 解题思路二用split分割字符串，分割之后的数组长度-1 就是该字符(分隔符)在该字符串中的个数。 解答二1234567891011var maxNumberOfBalloons = function(text) &#123; let singleNum, min = text.length; for (let i in &quot;balon&quot;) &#123; singleNum = text.split(&quot;balon&quot;[i]).length - 1; if (&quot;balon&quot;[i]) == &apos;o&apos; || &quot;balon&quot;[i]) == &apos;l&apos;) &#123; singleNum = Math.floor(singleNum / 2) &#125; min = (min &lt;= singleNum) ? min : singleNum; &#125; return min;&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"Leetcode_14. 最长公共前缀","slug":"JavaScript：leetcode_14. 最长公共前缀","date":"2019-09-20T03:59:13.000Z","updated":"2020-03-27T09:56:43.175Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_14. 最长公共前缀/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_14. 最长公共前缀/","excerpt":"题目解析：编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot;。 示例示例 1:12输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot; 示例 2:123输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。","text":"题目解析：编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot;。 示例示例 1:12输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot; 示例 2:123输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。 解题思路依序判断所有字符串的第N位字符是否一致。一致就加入共同前缀，不一致就跳出返回之前的前缀。 解答12345678910111213141516171819202122232425var longestCommonPrefix = function(strs) &#123; // 首先判断一下边界情况： // 1. 当长度为0时，结果必然为&quot;&quot;; // 2. 当长度为1时，结果必然为&quot;strs[0]&quot;; if (!strs.length) &#123;return &quot;&quot;;&#125;; if (strs.length == 1) &#123;return strs[0]&#125;; // 定义公共前缀 let comStr = &quot;&quot;; // 循环每个字符串的每个字母,以第一个字符串的长度为准 for (let i = 0; i &lt; strs[0].length; i++) &#123; // 定义每次循环的第一个字符串的字母 当其字符串长度不够时，取值为undefined,所以会判断为不相等跳出循环。 let item = strs[0][i]; // 循环数组 for (let j = 0; j &lt; strs.length; j++) &#123; //判断所有字符串的第i个字母是否一致，不一致返回原来的共同前缀。 if (strs[j][i] != item) &#123; return comStr; &#125; &#125; //一致的话将该字母加入共同前缀 comStr += item; &#125; // 回共同前缀 当所有字符串都一致的情况下才会在此处返回。 return comStr;&#125;; 解题思路二对数组中的字符串排序，然后比较最大和最小的字符串的公共前缀。即为数组的公共前缀 解答二123456789101112var longestCommonPrefix = function(strs) &#123; if (!strs.length) &#123;return &quot;&quot;;&#125;; if (strs.length == 1) &#123;return strs[0]&#125;; let comStr = &quot;&quot;; strs.sort(); for (let i = 0; i &lt; strs[0].length; i++) &#123; if (strs[0][i] != strs[strs.length - 1][i]) &#123; return strs[0].slice(0, (i + 1)); &#125; &#125; return strs[0];&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"Leetcode_35. 搜索插入位置","slug":"JavaScript：leetcode_35. 搜索插入位置","date":"2019-09-20T03:59:13.000Z","updated":"2020-03-27T09:56:43.175Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_35. 搜索插入位置/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_35. 搜索插入位置/","excerpt":"题目解析：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例示例 1:12输入: [1,3,5,6], 5输出: 2 示例 2:12输入: [1,3,5,6], 0输出: 0","text":"题目解析：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例示例 1:12输入: [1,3,5,6], 5输出: 2 示例 2:12输入: [1,3,5,6], 0输出: 0 解题思路利用findIndex函数遍历数组。 解答123456var findFuc = function(el, index, arr) &#123; return el &gt;= this&#125;var searchInsert = function(nums, target) &#123; return nums.findIndex(findFuc, target) == -1 ? nums.length : nums.findIndex(findFuc, target)&#125;; 解题思路二利用二分法遍历数组。 解答二1234567891011121314151617181920var searchInsert = function(nums, target) &#123; if (nums[0] &gt;= target) &#123; return 0; &#125; if (nums[nums.length - 1] &lt; target) &#123; return nums.length; &#125; let left = 0, right = nums.length - 1, mid = parseInt((nums.length - 1)/2); while(left &lt; (right-1)) &#123; if (nums[mid] &gt; target) &#123; right = mid; &#125; else if (nums[mid] &lt; target) &#123; left = mid; &#125; else &#123; return mid; &#125; mid = parseInt((left + right) / 2); &#125; return right;&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"HTML5 Drag & Drop 拖拽与拖放","slug":"HTML5 drag & drop 拖拽与拖放","date":"2019-09-07T03:09:34.000Z","updated":"2020-04-15T07:40:23.890Z","comments":true,"path":"JavaScript/HTML5 drag & drop 拖拽与拖放/","link":"","permalink":"http://www.zsfmyz.top/JavaScript/HTML5 drag & drop 拖拽与拖放/","excerpt":"拖拽与拖放 drop &amp; drag 是html5自带的拖拽与拖放的api 语法：所有需要被拖动的元素都要加上draggable属性，默认除了a，img等标签外不可拖动。 123456// html 行内绑定&lt;element ondrag=&quot;myScript&quot;&gt;// js 绑定元素object.ondrag=function()&#123;&#125;;// 全局监听object.addEventListener(&quot;drag&quot;, myScript);","text":"拖拽与拖放 drop &amp; drag 是html5自带的拖拽与拖放的api 语法：所有需要被拖动的元素都要加上draggable属性，默认除了a，img等标签外不可拖动。 123456// html 行内绑定&lt;element ondrag=&quot;myScript&quot;&gt;// js 绑定元素object.ondrag=function()&#123;&#125;;// 全局监听object.addEventListener(&quot;drag&quot;, myScript); 相关重点api 拖拽元素上触发的事件（事件target是拖拽元素） dragstart 被拖拽元素开始被拖拽时触发。 drag 被拖拽元素拖拽中触发 dragend 完成拖动时触发。 拖拽目标容器上的事件（事件target是目标容器） dragenter 被拖拽元素在进入其原始容器内的时候触发。 dragleave 跟enter相对应。 dragover 在另一容器内时触发（实测，只要我开始拖动之后就一直触发，且该事件需要阻止浏览器默认事件，因为在其他容器内都是默认不能拖动的。） drop 释放鼠标时候触发 DataTransfer 是拖拽元素的一个媒介对象，可以设置一些功能 dataTransfer.dropEffect：设置或返回拖放目标上允许发生的拖放行为。如果此设置的拖放行为不在effectAllowed属性设置的多种拖放行为之内，拖放操作将会失败。该属性值只允许none、copy、link、move值之一。 dataTransfer.effectAllowed：设置或返回被拖动元素允许发生的拖动行为。该属性值可设置为none、copy、copyLink、copyMove、link、linkMove、move、all、uninitialized。 dataTransfer.items：该属性返回DataTransferItems对象，该对象代表了拖动数据。 dataTransfer.setDragImage(element x,y)：设置拖放操作的自定义图标。其中element设置自定义图标，x设置图标与鼠标在水平方向的距离；y设置图标与鼠标在垂直方向的距离。 dataTransfer.addElement(element)：添加自定义图标。 dataTransfer.types：该属性返回一个DOMStringList对象，该对象包括了存入dataTransfer中数据的所有类型。 dataTransfer.getData(format)：获取DataTransfer对象中设置format格式的数据。其中format代表数据格式，data代表数据。 dataTransfer.clearData([format])：清除DataTransfer对象中format格式的数据，如果省略format格式，则意味着清除DataTransfer对象中的全部数据。 例子12345678910111213141516&lt;span draggable=&quot;true&quot; &gt;&lt;/span&gt; // 所有需要被拖动的元素都要加上draggable属性，默认除了a，img等标签外不可拖动。//start drag end 中 event都是被拖拽的元素document.addEventListener(&quot;dragstart&quot;, function (event) &#123; var id = $(event.target).prop(&apos;id&apos;); event.dataTransfer.dropEffect = &apos;move&apos; //设置拖动样式&#125;);//dragover dragleave dragenter drop 中event都代表拖放的容器元素 document.addEventListener(&quot;dragover&quot;, function(event) &#123; // drop 阻止浏览器默认事件 event.preventDefault(); console.log(&quot;容器内&quot;);&#125;);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zsfmyz.top/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zsfmyz.top/tags/JavaScript/"}]},{"title":"HTML5 Video截图功能实现","slug":"HTML5 Video截图功能实现","date":"2019-08-30T07:37:09.000Z","updated":"2020-04-15T07:40:23.890Z","comments":true,"path":"JavaScript/HTML5 Video截图功能实现/","link":"","permalink":"http://www.zsfmyz.top/JavaScript/HTML5 Video截图功能实现/","excerpt":"背景 因为所在公司业务为视频编解码，所以项目大多数是围绕视频展开的，之前做了一个快编项目，可以当作一个web端的小型视频编辑器。当中就需要对视频当前帧图进行截取，然后后续当作视频的封面或者海报图。 那么我就需要实现这么一个视频截图的功能。","text":"背景 因为所在公司业务为视频编解码，所以项目大多数是围绕视频展开的，之前做了一个快编项目，可以当作一个web端的小型视频编辑器。当中就需要对视频当前帧图进行截取，然后后续当作视频的封面或者海报图。 那么我就需要实现这么一个视频截图的功能。 API简介 首先视频截图在我们大前端实现，就要借助canvas的drawImage()这个api了。 drawImage 该api的功能简单讲就是将一张图片(Source image)绘制在canvas(Destination canvas)上. 语法： void ctx.drawImage(image, dx, dy);void ctx.drawImage(image, dx, dy, dWidth, dHeight);void ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight); image： 原图片Element. sx, sy, sWidth, sHeight : 需要在原图取起点x，y，宽，高； dx, dy, dWidth, dHeight：在目标canvas上绘制的起点x，y，宽，高。 image，dx，dy为必填 当我们截取并绘制完图片之后，就需要将在canvas上绘制的图片转化为图片了，那就需要 toDataURL(‘image/png’) 将其转换。 该方法返回一个用作展示的图片地址。 语法： canvas.toDataURL(type, encoderOptions); type: 默认为 image/png， 可选 image/jpeg或者image/webp encoderOptions：当type为 jpeg或者webp 时，可以选择0-1区间内的值作为输出的图片质量。 MDN HTMLCanvasElement.toDataURL() CanvasRenderingContext2D.drawImage() 回到正题，函数实现 代码实现HTML12345&lt;video id=&quot;video&quot; controls=&quot;controls&quot;&gt; &lt;source src=&quot;../videos/xxx.mp4&quot; /&gt;&lt;/video&gt;&lt;button id=&quot;capture&quot;&gt;Capture&lt;/button&gt;&lt;div id=&quot;output&quot;&gt;&lt;/div&gt; Script1234567891011121314151617181920212223242526(function() &#123; var video, $output; var scale = 0.25; var initialize = function() &#123; $output = $(&quot;#output&quot;); video = $(&quot;#video&quot;).get(0); $(&quot;#capture&quot;).click(captureImage); &#125;; var captureImage = function() &#123; var canvas = document.createElement(&quot;canvas&quot;); canvas.width = video.videoWidth * scale; canvas.height = video.videoHeight * scale; canvas.getContext(&apos;2d&apos;).drawImage(video, 0, 0, canvas.width, canvas.height); var img = document.createElement(&quot;img&quot;); img.src = canvas.toDataURL(&apos;image/png&apos;); $output.prepend(img); &#125;; $(initialize);&#125;()); Demodemo演示地址 大家可以用webstrom内置的服务器进行测试。 使用chrome浏览器需要一个服务器环境，否则canvas的toDataURL方法会报错。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zsfmyz.top/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zsfmyz.top/tags/JavaScript/"}]},{"title":"Font-Family字体对照表及效果展示","slug":"font-family字体对照表及效果展示","date":"2019-08-30T07:37:09.000Z","updated":"2020-04-15T07:40:23.891Z","comments":true,"path":"Css/font-family字体对照表及效果展示/","link":"","permalink":"http://www.zsfmyz.top/Css/font-family字体对照表及效果展示/","excerpt":"","text":"Demo直接进demo演示页面查看吧。 demo演示地址","categories":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/categories/Css/"}],"tags":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/tags/Css/"}]},{"title":"Border-Radius(圆角)失效了？","slug":"border-radius(圆角)失效了？","date":"2019-08-29T02:53:27.000Z","updated":"2020-03-27T09:56:43.174Z","comments":true,"path":"Css/border-radius(圆角)失效了？/","link":"","permalink":"http://www.zsfmyz.top/Css/border-radius(圆角)失效了？/","excerpt":"今天涉及两个属性： overscroll: scroll-y / scroll-x / scroll; border-radius: 10px;","text":"今天涉及两个属性： overscroll: scroll-y / scroll-x / scroll; border-radius: 10px; 原本这两个属性是没有什么联系的，但是当同时出现在同一个元素上时，就会发生圆角效果被滑动条覆盖的情况。例如： 1234567&lt;style&gt; div &#123; border-radius:10px; overflow:scroll-y; &#125;&lt;/style&gt;&lt;div&gt;&lt;/div&gt; 这种情况下，div的右上角和右下角都会因为滚动条的存在而显示的是直角。其实div的四个角确实已经有了圆角的效果，但是滚动条属于div内部的元素，层级高，所以将div的圆角遮挡住了。那么我们解决这种情况的方法也很简单。 123456789101112&lt;style&gt; div &#123; border-radius: 10px; overflow: hidden; &#125; ul &#123; overflow: scroll-y; &#125;&lt;/style&gt;&lt;div&gt; &lt;ul&gt;&lt;/ul&gt;&lt;/div&gt; 我们在原本需要滚动的盒子内部加上一层滚动元素，将滚动的效果放在内部的滚动元素上，外部div加上overflow: hidden;并设置圆角，就可以达到我们需要的效果。 同样的我们也可以在当前元素的外层加上圆角遮罩，最终效果同上。 如有其他情况欢迎补充","categories":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/categories/Css/"}],"tags":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/tags/Css/"}]},{"title":"Hexo搭建配置总结","slug":"Hexo搭建配置总结","date":"2019-08-27T10:14:27.000Z","updated":"2020-04-15T07:40:23.890Z","comments":true,"path":"Hexo/Hexo搭建配置总结/","link":"","permalink":"http://www.zsfmyz.top/Hexo/Hexo搭建配置总结/","excerpt":"主题是material-x 最新版本叫：volantis 主题最新仓库 本博客主题所用版本 简介： Hexo 添加Favicon Hexo 添加百度统计 Hexo RSS订阅 Hexo 添加看板娘 Hexo 网站地图 Hexo 评论系统 gitalk 常见问题 Hexo deploy 报错","text":"主题是material-x 最新版本叫：volantis 主题最新仓库 本博客主题所用版本 简介： Hexo 添加Favicon Hexo 添加百度统计 Hexo RSS订阅 Hexo 添加看板娘 Hexo 网站地图 Hexo 评论系统 gitalk 常见问题 Hexo deploy 报错 Hexo 添加Favicon根目录_config.yml 根目录为public的时候,图片放在source下面的img里面就可以，没有的话创建个img文件夹。 1favicon: https://www.xxx.com/img/favicon.ico Hexo 添加百度统计 首先肯定是要去百度统计注册一下了。。百度统计注册完成之后生成统计代码，备用。 在主题配置文件_config.yml里面添加一行 12# Analyticscnzz: true 找到 \\hexo\\themes\\pacman\\layout_partial,在这个文件夹中创建一个cnzz.ejs的文件然后将下面内容复制进去，记得替换中间的script 1234567891011 &lt;% if (theme.cnzz)&#123; %&gt;&lt;!-- 将中间这一块script替换成你的统计代码 --&gt;&lt;script type=&quot;text/javascript&quot;&gt; var cnzz_protocol = ((&quot;https:&quot; == document.location.protocol) ? &quot; https://&quot;: &quot; http://&quot;); document.write(unescape(&quot;%3Cspan id=&apos;cnzz_stat_icon_1000543074&apos;%3E%3C/span%3E%3Cscript src=&apos;&quot; + cnzz_protocol + &quot;s19.cnzz.com/z_stat.php%3Fid%3D1000543074%26show%3Dpic&apos; type=&apos;text/javascript&apos;%3E%3C/script%3E&quot;));&lt;/script&gt;&lt;% &#125; %&gt; 在 \\hexo\\themes\\pacman\\layout_partial\\footer.ejs中加一行下面的代码，然后就结束了。重启生效就可以了。然后在百度中心检测代码有没有安装成功，生效了就可以看报告了。这个过程需要一定的时间。 1&lt;%- partial(&apos;cnzz&apos;) %&gt; Hexo RSS订阅 进入hexo目录 1npm install hexo-generator-feed 根目录_config.yml中添加 12345678#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed:type: atompath: atom.xmllimit: 20 主题目录下_config.yml中添加1rss: /atom.xml Hexo 添加看板娘 进入hexo目录 1npm install --save hexo-helper-live2d 根目录_config.yml中添加 12345678910111213141516171819#看板娘live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false log: false model: use: live2d-widget-model-wanko #可选择不同的看板娘名称 display: position: right width: 150 height: 300 mobile: show: true react: opacity: 0.7 可以添加看板娘列表中添加12345678910111213141516171819202122live2d-widget-model-chitoselive2d-widget-model-epsilon2_1live2d-widget-model-gflive2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru)live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru)live2d-widget-model-harutolive2d-widget-model-hibikilive2d-widget-model-hijikilive2d-widget-model-izumilive2d-widget-model-koharulive2d-widget-model-mikulive2d-widget-model-ni-jlive2d-widget-model-nicolive2d-widget-model-nietzschelive2d-widget-model-nipsilonlive2d-widget-model-nitolive2d-widget-model-shizukulive2d-widget-model-tororolive2d-widget-model-tsumikilive2d-widget-model-unitychanlive2d-widget-model-wankolive2d-widget-model-z16 想用哪个就 npm install –save xxx ， 然后在配置文件use: xxx 进行修改就好了。 取消看板娘 1npm uninstall hexo-helper-live2d 然后去掉配置文件里面的配置就好了 Hexo 网站地图 添加sitemap 12npm install hexo-generator-sitemap --save #sitemap.xml适合提交给谷歌搜素引擎npm install hexo-generator-baidu-sitemap --save #baidusitemap.xml适合提交百度搜索引擎 然后在站点配置文件_config.yml中添加以下代码 自动生成sitemap,在根目录_config.yml中添加 sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 最后修改根目录_config.yml中的url url: http://你的网站 然后hexo g, 会在/public目录下生成sitemap.xml和baidusitemap.xml 网站地图。 Hexo 评论系统 gitalk 创建评论仓库 首先到github中创建repository，库名称可以叫XXXtalk，因为这个仓库是用来存储我们的评论内容的。 创建好之后，进入这个仓库的settings界面找到issues选项，确保它的勾选着的。 注册Github Application 到github中创建Github Application。 名称和描述可以随意填写，两个URL填写你的博客地址就可以了。注册之后就可以看到Client ID 和 Client Secret。这两个是我们需要的东西。 根目录下配置gitalk 将下面的代码赋值到根目录下 123456gitalk: clientID: 你的clientID clientSecret: 你的clientSecret repo: 你的repo名 //xxxtalk 刚才我们创建的仓库名 owner: 你的GitHub名 admin: [你的GitHub名称] 接下来hexo g 执行之后，你会发现你的文章下面会出现评论了。 错误处理 第一次添加gitalk出现了 Error:Validation Failed 这样的错误具体原因是因为Github 限制 labal 长度不能超过 50引起的。 解决办法是使用md5对id进行加密。 解决方案：首先将下面的内容保存为md5.js放在 themes/material-X/source/js/ 下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788! function(n) &#123; &quot;use strict&quot;; function t(n, t) &#123; var r = (65535 &amp; n) + (65535 &amp; t); return (n &gt;&gt; 16) + (t &gt;&gt; 16) + (r &gt;&gt; 16) &lt;&lt; 16 | 65535 &amp; r &#125; function r(n, t) &#123; return n &lt;&lt; t | n &gt;&gt;&gt; 32 - t &#125; function e(n, e, o, u, c, f) &#123; return t(r(t(t(e, n), t(u, f)), c), o) &#125; function o(n, t, r, o, u, c, f) &#123; return e(t &amp; r | ~t &amp; o, n, t, u, c, f) &#125; function u(n, t, r, o, u, c, f) &#123; return e(t &amp; o | r &amp; ~o, n, t, u, c, f) &#125; function c(n, t, r, o, u, c, f) &#123; return e(t ^ r ^ o, n, t, u, c, f) &#125; function f(n, t, r, o, u, c, f) &#123; return e(r ^ (t | ~o), n, t, u, c, f) &#125; function i(n, r) &#123; n[r &gt;&gt; 5] |= 128 &lt;&lt; r % 32, n[14 + (r + 64 &gt;&gt;&gt; 9 &lt;&lt; 4)] = r; var e, i, a, d, h, l = 1732584193, g = -271733879, v = -1732584194, m = 271733878; for (e = 0; e &lt; n.length; e += 16) i = l, a = g, d = v, h = m, g = f(g = f(g = f(g = f(g = c(g = c(g = c(g = c(g = u(g = u(g = u(g = u(g = o(g = o(g = o(g = o(g, v = o(v, m = o(m, l = o(l, g, v, m, n[e], 7, -680876936), g, v, n[e + 1], 12, -389564586), l, g, n[e + 2], 17, 606105819), m, l, n[e + 3], 22, -1044525330), v = o(v, m = o(m, l = o(l, g, v, m, n[e + 4], 7, -176418897), g, v, n[e + 5], 12, 1200080426), l, g, n[e + 6], 17, -1473231341), m, l, n[e + 7], 22, -45705983), v = o(v, m = o(m, l = o(l, g, v, m, n[e + 8], 7, 1770035416), g, v, n[e + 9], 12, -1958414417), l, g, n[e + 10], 17, -42063), m, l, n[e + 11], 22, -1990404162), v = o(v, m = o(m, l = o(l, g, v, m, n[e + 12], 7, 1804603682), g, v, n[e + 13], 12, -40341101), l, g, n[e + 14], 17, -1502002290), m, l, n[e + 15], 22, 1236535329), v = u(v, m = u(m, l = u(l, g, v, m, n[e + 1], 5, -165796510), g, v, n[e + 6], 9, -1069501632), l, g, n[e + 11], 14, 643717713), m, l, n[e], 20, -373897302), v = u(v, m = u(m, l = u(l, g, v, m, n[e + 5], 5, -701558691), g, v, n[e + 10], 9, 38016083), l, g, n[e + 15], 14, -660478335), m, l, n[e + 4], 20, -405537848), v = u(v, m = u(m, l = u(l, g, v, m, n[e + 9], 5, 568446438), g, v, n[e + 14], 9, -1019803690), l, g, n[e + 3], 14, -187363961), m, l, n[e + 8], 20, 1163531501), v = u(v, m = u(m, l = u(l, g, v, m, n[e + 13], 5, -1444681467), g, v, n[e + 2], 9, -51403784), l, g, n[e + 7], 14, 1735328473), m, l, n[e + 12], 20, -1926607734), v = c(v, m = c(m, l = c(l, g, v, m, n[e + 5], 4, -378558), g, v, n[e + 8], 11, -2022574463), l, g, n[e + 11], 16, 1839030562), m, l, n[e + 14], 23, -35309556), v = c(v, m = c(m, l = c(l, g, v, m, n[e + 1], 4, -1530992060), g, v, n[e + 4], 11, 1272893353), l, g, n[e + 7], 16, -155497632), m, l, n[e + 10], 23, -1094730640), v = c(v, m = c(m, l = c(l, g, v, m, n[e + 13], 4, 681279174), g, v, n[e], 11, -358537222), l, g, n[e + 3], 16, -722521979), m, l, n[e + 6], 23, 76029189), v = c(v, m = c(m, l = c(l, g, v, m, n[e + 9], 4, -640364487), g, v, n[e + 12], 11, -421815835), l, g, n[e + 15], 16, 530742520), m, l, n[e + 2], 23, -995338651), v = f(v, m = f(m, l = f(l, g, v, m, n[e], 6, -198630844), g, v, n[e + 7], 10, 1126891415), l, g, n[e + 14], 15, -1416354905), m, l, n[e + 5], 21, -57434055), v = f(v, m = f(m, l = f(l, g, v, m, n[e + 12], 6, 1700485571), g, v, n[e + 3], 10, -1894986606), l, g, n[e + 10], 15, -1051523), m, l, n[e + 1], 21, -2054922799), v = f(v, m = f(m, l = f(l, g, v, m, n[e + 8], 6, 1873313359), g, v, n[e + 15], 10, -30611744), l, g, n[e + 6], 15, -1560198380), m, l, n[e + 13], 21, 1309151649), v = f(v, m = f(m, l = f(l, g, v, m, n[e + 4], 6, -145523070), g, v, n[e + 11], 10, -1120210379), l, g, n[e + 2], 15, 718787259), m, l, n[e + 9], 21, -343485551), l = t(l, i), g = t(g, a), v = t(v, d), m = t(m, h); return [l, g, v, m] &#125; function a(n) &#123; var t, r = &quot;&quot;, e = 32 * n.length; for (t = 0; t &lt; e; t += 8) r += String.fromCharCode(n[t &gt;&gt; 5] &gt;&gt;&gt; t % 32 &amp; 255); return r &#125; function d(n) &#123; var t, r = []; for (r[(n.length &gt;&gt; 2) - 1] = void 0, t = 0; t &lt; r.length; t += 1) r[t] = 0; var e = 8 * n.length; for (t = 0; t &lt; e; t += 8) r[t &gt;&gt; 5] |= (255 &amp; n.charCodeAt(t / 8)) &lt;&lt; t % 32; return r &#125; function h(n) &#123; return a(i(d(n), 8 * n.length)) &#125; function l(n, t) &#123; var r, e, o = d(n), u = [], c = []; for (u[15] = c[15] = void 0, o.length &gt; 16 &amp;&amp; (o = i(o, 8 * n.length)), r = 0; r &lt; 16; r += 1) u[r] = 909522486 ^ o[r], c[r] = 1549556828 ^ o[r]; return e = i(u.concat(d(t)), 512 + 8 * t.length), a(i(c.concat(e), 640)) &#125; function g(n) &#123; var t, r, e = &quot;&quot;; for (r = 0; r &lt; n.length; r += 1) t = n.charCodeAt(r), e += &quot;0123456789abcdef&quot;.charAt(t &gt;&gt;&gt; 4 &amp; 15) + &quot;0123456789abcdef&quot;.charAt(15 &amp; t); return e &#125; function v(n) &#123; return unescape(encodeURIComponent(n)) &#125; function m(n) &#123; return h(v(n)) &#125; function p(n) &#123; return g(m(n)) &#125; function s(n, t) &#123; return l(v(n), v(t)) &#125; function C(n, t) &#123; return g(s(n, t)) &#125; function A(n, t, r) &#123; return t ? r ? s(t, n) : C(t, n) : r ? m(n) : p(n) &#125; &quot;function&quot; == typeof define &amp;&amp; define.amd ? define(function() &#123; return A &#125;) : &quot;object&quot; == typeof module &amp;&amp; module.exports ? module.exports = A : n.md5 = A&#125;(this); 保存之后，修改主题目录下 layout/_partial/scripts.ejs 138行，修改如下 123456789101112131415161718192021&lt;% if (enableGitalk) &#123; %&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css&quot;&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/js/md5.js&quot;&gt;&lt;/script&gt; // 添加！！！！ &lt;script type=&quot;text/javascript&quot;&gt; var gitalk = new Gitalk(&#123; clientID: &quot;&lt;%- config.gitalk.clientID %&gt;&quot;, clientSecret: &quot;&lt;%- config.gitalk.clientSecret %&gt;&quot;, repo: &quot;&lt;%- config.gitalk.repo %&gt;&quot;, owner: &quot;&lt;%- config.gitalk.owner %&gt;&quot;, admin: &quot;&lt;%- config.gitalk.admin %&gt;&quot;, &lt;% if(page.gitalk &amp;&amp; page.gitalk.id) &#123; %&gt; id: &quot;&lt;%= page.gitalk.id %&gt;&quot;, &lt;% &#125; else &#123; %&gt; id: md5(location.pathname), // 修改！！！！ &lt;% &#125; %&gt; distractionFreeMode: false // Facebook-like distraction free mode &#125;); gitalk.render(&apos;gitalk-container&apos;); &lt;/script&gt;&lt;% &#125; %&gt; 如上一处添加，一处修改，当然也可以将这块代码完全替换了也可以，然后hexo g 之后问题应该就解决了。 常见问题Hexo deploy 报错报错信息一 12345678remote: Weak credentials. Please Update your password to continue using GitHub.remote: See https://help.github.com/articles/creating-a-strong-password/.fatal: unable to access &apos;https://github.com/xxx/xxx.github.io.git/&apos;: The requested URL returned error: 403FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: Spawn failed at ChildProcess.&lt;anonymous&gt; (/opt/hexo/node_modules/_hexo-util@0.6.3@hexo-util/lib/spawn.js:52:19) at ChildProcess.emit (events.js:198:13) at Process.ChildProcess._handle.onexit (internal/child_process.js:248:12) 问题描述这种报错是突然出现的，一看就知道是github的问题，大概意思就是说你的密码强度太低。所以造成了连接不上GitHub仓库地址的报错。刚开始还比较迷茫，不知道是哪个密码比较弱了。直到我想添加ssh key的时候，GitHub官网提醒，说我的GitHub密码比较弱，需要修改，否则一个月后自动修改。 这简直比较狗血，没想到还会影响到git提交。 但是目前只发现会影响hexo deploy的自动部署，账号上的其他clone的仓库不会影响。 解决办法(linux) 更改GitHub密码。 重新生成ssh key。 1sudo ssh-keygen -C &apos;xxx@email.com&apos; -t rsa 一路 y 就可以了。 将重新生成的key添加到GitHub上。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.zsfmyz.top/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.zsfmyz.top/tags/Hexo/"}]},{"title":"Z-Index失效了？","slug":"z-index失效了？ ","date":"2019-08-27T10:14:27.000Z","updated":"2020-04-15T07:40:23.891Z","comments":true,"path":"Css/z-index失效了？ /","link":"","permalink":"http://www.zsfmyz.top/Css/z-index失效了？ /","excerpt":"背景 我们在使用z-index的时候，有时候会发现，无论怎么样增大z-index的值，都无法改变目标元素的层级。 其实是这几种情况在作怪 position float opcity","text":"背景 我们在使用z-index的时候，有时候会发现，无论怎么样增大z-index的值，都无法改变目标元素的层级。 其实是这几种情况在作怪 position float opcity 父盒子的层级问题 父盒子的层级问题，当你的父盒子层级小于另一个父盒子层级的时候，你子元素的z-index再高都是没有用的。该元素的层级只在该元素所在的容器内起作用。该种情况大家应该容易理解，不过也可以看下面的例子。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;style type=&quot;text/css&quot;&gt; .a1&#123; position:relative; z-index: 2; width:400px; height:400px; background: black; border:1px solid #eee; margin-bottom: -100px; &#125; .a&#123; position:relative; z-index: 1; width:400px; height:400px; background: yellow; left:0; border:1px solid #eee; &#125; .b&#123; position:absolute; left:0; top:0; z-index: 50; width:200px; height:200px; background: red; &#125; .c&#123; position: absolute; left:0; top:0; z-index:1111; width:100px; height:100px; background: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;a1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;a&quot;&gt; &lt;div class=&quot;b&quot;&gt;&lt;/div&gt; &lt;div class=&quot;c&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt; opcity属性 opcity属性，当你要设置两个元素的z-index值的时候，要注意是否给其中一个元素添加了opcity属性，如果添加了，那么添加了opcity属性的元素将一直在最上层，这个我在另一篇文章中讲过。 opcity引发的元素层级变化 position影响 还有就是比较普遍的，我们设置层级一般都是因为设置了position，当你设置的两个子元素，一个有position属性，另一个没有position的时候，拥有position属性的元素将一直在其他元素上方。如下面的例子 123456789101112131415161718192021222324252627282930313233343536&lt;style type=&quot;text/css&quot;&gt; .a&#123; position:relative; z-index: 1; width:400px; height:400px; background: yellow; left:0; border:1px solid #eee; &#125; .b&#123; position:absolute; left:0; top:0; z-index: 50; width:200px; height:200px; background: red; &#125; .c&#123; z-index:100; width:100px; height:100px; background: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;a&quot;&gt; &lt;div class=&quot;b&quot;&gt;&lt;/div&gt; &lt;div class=&quot;c&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt; 需要给c也加上position属性才让bc可以先同处一级，然后z-index才会起作用。 float影响 那如果我把子元素的position都去掉呢？当父盒子有position而所有子元素都没有position属性的时候，z-index一样全部失效，后面的盒子将会覆盖前面的盒子，z-index无效。 同样的我们两个都加上浮动的效果跟上面的效果是一样的，后覆盖前，z-index无效 一个加float另一个不加，则是加float的元素一直浮动在最上层。 12345678910111213141516171819202122232425262728293031323334&lt;style type=&quot;text/css&quot;&gt; .a&#123; position:absolute; z-index: 1; width:400px; height:400px; background: yellow; left:0; border:1px solid #eee; &#125; .b&#123; z-index: -10; width:200px; height:200px; background: red; margin-bottom: -100px; &#125; .c&#123; z-index:101; width:100px; height:100px; background: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;a&quot;&gt; &lt;div class=&quot;b&quot;&gt;&lt;/div&gt; &lt;div class=&quot;c&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt; 其他情况欢迎补充。","categories":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/categories/Css/"}],"tags":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/tags/Css/"}]},{"title":"V-Model","slug":"v-model","date":"2019-08-26T08:59:13.000Z","updated":"2020-03-27T09:56:43.175Z","comments":true,"path":"Vue/v-model/","link":"","permalink":"http://www.zsfmyz.top/Vue/v-model/","excerpt":"最近学习vue，从最基础的文档看起。到目前基础已经看完。有两个问题很迷茫。 vue的动态参数（2.6新增）。demo一直报错。分析原因是因为vue不允许动态添加根一级的变量。（不理解） 组件中v-model的使用文档中说的让我有点绕。不过已经顺过来了，所以来分享一下。","text":"最近学习vue，从最基础的文档看起。到目前基础已经看完。有两个问题很迷茫。 vue的动态参数（2.6新增）。demo一直报错。分析原因是因为vue不允许动态添加根一级的变量。（不理解） 组件中v-model的使用文档中说的让我有点绕。不过已经顺过来了，所以来分享一下。 官方给出的例子是这样。(可以直接使用)1234567891011121314HTML:&lt;custom-input v-model=&quot;searchText&quot;&gt;&lt;/custom-input&gt;JS:Vue.component(&apos;custom-input&apos;, &#123; props: [&apos;value&apos;], template: ` &lt;input v-bind:value=&quot;value&quot; v-on:input=&quot;$emit(&apos;input&apos;, $event.target.value)&quot; &gt; `&#125;) v-model可以改写为这种形式，两者完全等价。1234567&lt;input v-model=&quot;searchText&quot;&gt;等价于：&lt;input v-bind:value=&quot;searchText&quot; v-on:input=&quot;searchText = $event.target.value&quot;&gt; //（ $event.target.value为事件当前目标上的value值。） 第二种写法： 在input上绑定了input事件，通过触发input事件，执行给searchText赋值语句。 v-bind将searchText赋值给input标签的value属性。 再看官方的例子：1&lt;custom-input v-model=&quot;searchText&quot;&gt;&lt;/custom-input&gt; 等价于：1234&lt;custom-input v-bind:value=&quot;searchText&quot; v-on:input=&quot;searchText = $event&quot; //$event 为组件内部抛出来的值。（这个如果不明白可以看组件的自定义事件部分）&gt;&lt;/custom-input&gt; 再加上官方的js写法： 123456789Vue.component(&apos;custom-input&apos;, &#123; props: [&apos;value&apos;], template: ` &lt;input v-bind:value=&quot;value&quot; v-on:input=&quot;$emit(&apos;input&apos;, $event.target.value)&quot; &gt; `&#125;) 我们在组件内的input上监听了input事件，并且用该input事件对组件上的（自定义）input事件进行触发（searchText = $event”）； 将$ event.target.value作为参数传给 v-on:input=”searchText = $ event “，$ event === $ event.target.value。执行语句searchText被赋值。 组件上的v-bind:value = “searchText” 是将searchText的值绑定到组件内部的props里的value上。 组件内部将props中的value 绑定到input的value上。就这样完成了一次双向绑定。 而根据官方v-model的两种写法，组件上转换回v-modal的写法。就完成了。最终结果就如开头所示。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://www.zsfmyz.top/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.zsfmyz.top/tags/Vue/"}]},{"title":"Leetcode_7. 整数反转","slug":"JavaScript：leetcode_7. 整数反转","date":"2019-07-27T09:59:13.000Z","updated":"2020-03-27T09:56:43.175Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_7. 整数反转/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_7. 整数反转/","excerpt":"题目解析：给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例示例 1: 输入: 123 输出: 321 示例 2: 输入: -123 输出: -321示例 3: 输入: 120 输出: 21 注意假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。","text":"题目解析：给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例示例 1: 输入: 123 输出: 321 示例 2: 输入: -123 输出: -321示例 3: 输入: 120 输出: 21 注意假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 解题思路题目就是反转，问题在于反转过程中是否溢出。 先判断正负。 10位以内直接反转。 接下来就是10位数字的反转，反转过程中判断是否会溢出。（不能反转后再判断是否溢出，因为环境只能存储32位有符号整数，所以反转之后的如果真的溢出是保存不了的）解答 12345678910111213141516var max;var flag;var reverse = function(x) &#123; x &lt; 0 ? (flag = &apos;-&apos;, max = &apos;2147483648&apos;) : (flag = &apos;+&apos;, max = &apos;2147483647&apos;); var val = (Math.abs(x) + &apos;&apos;).split(&apos;&apos;); if (val.length &lt; 10) &#123; return ((flag + val.reverse().join(&apos;&apos;)) - 0) &#125; if (val.length = 10) &#123; for (var i = 0; i &lt; 10; i++) &#123; if (val[9 - i] &gt; max[i]) &#123; return 0; &#125; else if (val[9 - i] &lt; max[i]) &#123; return ((flag + val.reverse().join(&apos;&apos;)) - 0) &#125; &#125; &#125;&#125;; 题目很简单，肯定还是可以优化的，如果有更好的办法可以留言。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"Leetcode_2. 两数相加","slug":"JavaScript：leetcode_2. 两数相加","date":"2019-06-27T09:59:13.000Z","updated":"2020-03-27T09:56:43.175Z","comments":true,"path":"Algorithm/每日一题/JavaScript：leetcode_2. 两数相加/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_2. 两数相加/","excerpt":"给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例：123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807","text":"给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例：123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 题目解析： 该题给出两个链表，求出两个链表各个结点的和，那首先我们需要知道链表是什么样子。 1234567/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; */ 如上，链表的每个结点就是这个样子，next指向下一个结点，当然这是在js中简单的实现了链表。 然后知道了链表，那么就开始各位相加吧~，这个题唯一的难点就是在于各个结点相加的时候可能会产生进位。比如9+2=11，那么就需要进一位，本位取10的余数为值，然后我们就需要在下一个结点相加时把前两位可能产生的进位也算进去。 如下是我的js解答： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; l1 * @param &#123;ListNode&#125; l2 * @return &#123;ListNode&#125; * y 为进位值 * i 代表和的位 * n 代表了和的每一位的值 * arr 代表和（我们用数组表示更方便一点） */var addTwoNumbers = function(l1, l2) &#123; var arr = [], i = 0, n = 0, y = 0; //初始化 //因为链表不一定同样长的，所以只要有一个链表的结点不为空，我们都需要继续计算； //同时我们也要考虑进位，即使两个链表结束了，如果有进位的话，那我们还是需要再计算一次的。 while (l1 !== null || l2 !== null || y !== 0) &#123; //判断链表l1的该结点是否为null，如果为null初始化成值为0的结点，方便运算。 l1 = l1 ? l1 : new ListNode(0); // 同理 l2 l2 = l2 ? l2 : new ListNode(0); // 计算该位的两个结点的和，同时要加上前两位的进位。 var num = l1.val + l2.val + y; // 判断该位是否需要进位，需要进位的话就该位取10的余数，然后进一位（y = 1），反之初始化进位值为0。 num &gt; 9 ? (y = 1, n = num - 10) : (n = num, y = 0); arr[i] = n; //给和的每一位赋值 i++; //进入下一次循环 l1 = l1.next; // 进入l1下一个结点 l2 = l2.next; // 进入l2下一个结点 &#125; //这里反转一下，原本是[7, 0, 8]反转为[8, 0, 7],方便后面生成链表。 arr = arr.reverse(); //取第一个值创建第一个结点（也是最终链表的最后一个结点） let listNode = new ListNode(arr.shift()) //取第一个值创建第一个结点（也是最终链表的最后一个结点） return arr.reduce((ori,cur)=&gt;&#123; let ln = new ListNode(cur) //生成当前结点 ln.next = ori //将当前结点的next指向之前生成的链表的第一个结点 return ln //返回新的链表（赋值给了 ori ） &#125;, listNode) // listNode是初始值。 // 即链表末端的第一个值，我们之所以从最后一个开始创建链表也是因为方便。 // 因为我们要操作结点的next，所以用新结点的next指向原来的链表，要比找到链表的最后一个结点的next指向新结点要方便一些。 // 即从后往前生成链。&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"完全背包问题","slug":"完全背包问题","date":"2019-04-30T07:10:03.000Z","updated":"2020-03-27T09:56:43.175Z","comments":true,"path":"Algorithm/完全背包问题/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/完全背包问题/","excerpt":"题目描述 这里借用一个题目的描述来说明要解决问题的背景。 LiYuxiang是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同种类的草药，采每一种都需要一些时间，每一种也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。” 如果你是LiYuxiang，你能完成这个任务吗？ 此题和原题的不同点： 1.每种草药可以无限制地疯狂采摘。 2.药的种类眼花缭乱，采药时间好长好长啊！师傅等得菊花都谢了！ 一、 什么是背包算法背包算法的基础标准描述为：当前有N件商品，每件商品都有不同的价值v和重量w。我们要把这些商品放在容量为L的背包中，实现背包中的价值最大化。（第i件商品的价值为v[i]，重量为w[i])。上面的题目中的条件之一：草药无限（每件商品可以重复放入背包）即表明了该问题是完全背包问题。","text":"题目描述 这里借用一个题目的描述来说明要解决问题的背景。 LiYuxiang是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同种类的草药，采每一种都需要一些时间，每一种也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。” 如果你是LiYuxiang，你能完成这个任务吗？ 此题和原题的不同点： 1.每种草药可以无限制地疯狂采摘。 2.药的种类眼花缭乱，采药时间好长好长啊！师傅等得菊花都谢了！ 一、 什么是背包算法背包算法的基础标准描述为：当前有N件商品，每件商品都有不同的价值v和重量w。我们要把这些商品放在容量为L的背包中，实现背包中的价值最大化。（第i件商品的价值为v[i]，重量为w[i])。上面的题目中的条件之一：草药无限（每件商品可以重复放入背包）即表明了该问题是完全背包问题。 二、 背包算法的应用背包算法在我看来是一种“性价比”算法。即我们在有限的条件下得到最大的收获。例如曾经有个节目可以让嘉宾在有限的时间内选购满满购物车的货品。这个场景及其符合背包算法。或者例如我们在考试的时侯，都会尽可能的选择简单并且分数又多的题先做。同时我们也可以应用到其他问题上去。比如在选择购买多种原材料时，尽可能的缩小原材料成本。投资时对多种投资产品的选择组合。 三、 背包算法的原理背包问题需要用到动态规划算法。当我们装一个商品的时侯需要判断几个条件： 该商品的重量和背包大小的关系。如果背包的总容量小于商品的重量，那就GG，根本不用考虑了。 商品的重量小于背包剩余容量。即背包中之前装入的商品不需要拿出来就可以把当前商品装下，那也不用考虑，直接装就好了。 商品的重量小于背包总容量，但是剩余空间不够装了。那我们就需要考虑衡量一下，拿出来原有的一部分商品，装入现在的商品是不是划算的。 从上面的三个条件可以看出最重要的就是第三条，我们需要判断价值。假设我们背包可以装8kg东西，现在有三个商品（商品都是以袋为单位销售不可拆分）： 苹果 香蕉 草莓 3kg 2kg 5kg ￥45 ￥20 ￥150 我们以1kg为单位打表:第一次打表 0kg 1kg 2kg 3kg 4kg 5kg 6kg 7kg 8kg 无 0 0 0 0 0 0 0 0 0 苹果 0 0 0 ￥45 ￥45 ￥45 ￥90 ￥90 ￥90 香蕉 0 0 0 0 0 0 0 0 0 草莓 0 0 0 0 0 0 0 0 0 第二次打表 0kg 1kg 2kg 3kg 4kg 5kg 6kg 7kg 8kg 无 0 0 0 0 0 0 0 0 0 苹果 0 0 0 ￥45 ￥45 ￥45 ￥90 ￥90 ￥90 香蕉 0 0 ￥20 ￥45 ￥45 ￥65 ￥90 ￥90 ￥110 草莓 0 0 0 0 0 0 0 0 0 最终打表结果： 0kg 1kg 2kg 3kg 4kg 5kg 6kg 7kg 8kg 无 0 0 0 0 0 0 0 0 0 苹果 0 0 0 ￥45 ￥45 ￥45 ￥90 ￥90 ￥90 香蕉 0 0 ￥20 ￥45 ￥45 ￥65 ￥90 ￥90 ￥110 草莓 0 0 ￥20 ￥45 ￥45 ￥150 ￥150 ￥170 ￥195 如表我们的最终排列结果。 核心判断为：bag[i-1][j] 和bag[i-1][j-k*w[i]] + k*v[i] 的价值哪个大。我来说明上面的变量都代表了什么： bag[i][j] 代表了我们在看到第i个商品时，背包容量占用了jkg时，背包内物品的价值。 那么bag[i-1][j] 就代表了我们在看到第i-1个商品时，背包容量占用了jkg时，背包内装的价值。 v[i]代表了当前商品的价值，k*v[i]代表了k个v[i]的价值（商品不限量）。 w[i]代表了当前商品的重量，k*w[i]代表了k个w[i]的重量。 bag[i-1][j-k*w[i]]就代表了上一个情况下，背包装了k个i商品时，余下空间在上一状态的最大价值。 所以，我们的核心判断种需要 上一个情况下的背包的所有状态。当我们把背包中 k*w[i]的空间腾出来用来装k个i商品，加上剩余空间可以装的商品的最大价值。如果它小于上一个状态下bag[i-1][j]所装货品的价值，那么我们就没必要替换这部分空间了。 12345678910//两个循环for (3) //3个商品 for (8) // 8种占用空间的情况（1kg-8kg）// 核心判断if (bag[i-1][j] &gt; bag[i-1][j-k*w[i]] + k*v[i]) &#123; bag[i][j] = bag[i-1][j];&#125; else &#123; bag[i][j] = bag[i-1][j-k*w[i]] + k*v[i];&#125; 其实回到生活上，我们的想法跟这个是一样的，当我们有个背包要装满的时侯，我们先看到了苹果，那么当然的，我们要尽可能多的把苹果装到包包里。如果有剩余空间装不下那也只能浪费着。然后我们发现了香蕉，我们会开始想着怎么用香蕉代替一部分苹果把空间填满。在这个思考的过程中，我们会一直比较什么样的组合价值最大。草莓也是一样。 其实如开头所说，我说这是“性价比”。上面我们商品出现的顺序是随机的。其实我们装东西判断价值，其实就是装性价比最高的物品。 不过同时需要考虑到空间的利用率。如果我们事先把性价比高的物品排在前面，那么效率会提高不少。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"ES6 对象数组查找某一个对象 findIndex","slug":"ES6 对象数组查找某一个对象 findIndex","date":"2019-01-27T09:50:34.000Z","updated":"2020-03-27T09:56:43.174Z","comments":true,"path":"JavaScript/ES6 对象数组查找某一个对象 findIndex/","link":"","permalink":"http://www.zsfmyz.top/JavaScript/ES6 对象数组查找某一个对象 findIndex/","excerpt":"查找数组特定元素需要用到的方法就是findIndex()。 用法与定义 findIndex() 方法返回传入一个测试条件（函数）符合条件的数组第一个元素位置。 findIndex() 方法为数组中的每个元素都调用一次函数执行： 当数组中的元素在测试条件时返回 true 时, findIndex() 返回符合条件的元素的索引位置，之后的值不会再调用 执行函数。如果没有符合条件的元素返回 -1","text":"查找数组特定元素需要用到的方法就是findIndex()。 用法与定义 findIndex() 方法返回传入一个测试条件（函数）符合条件的数组第一个元素位置。 findIndex() 方法为数组中的每个元素都调用一次函数执行： 当数组中的元素在测试条件时返回 true 时, findIndex() 返回符合条件的元素的索引位置，之后的值不会再调用 执行函数。如果没有符合条件的元素返回 -1 以上是比较官方的对于findIndex()的定义 接下来我结合实例来进行自己的解释. 第一条的意思如下:当条件函数返回true的时候，findindex会跳出，然后返回当前元素的下标。123456789101112131415161718192021222324252627282930//首先是普通数组var dataArr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];function fn(num, numIndex, nums)&#123; //该函数的三个参数，num代表当前项，numIndex代表当前项下标，nums代表该数组。 return num &gt; 5;&#125;dataArr.findIndex(fn);//值为5(即6的下标)------------------------分割线-----------------------------//同样的假如你的数组是个对象数组：var objArr = [&#123; name: &apos;小王&apos;, age: 14&#125;,&#123; name: &apos;大王&apos;, age: 41&#125;,&#123; name: &apos;老王&apos;, age: 61&#125;] function objFn(obj, objIndex, objs)&#123; return num.age &gt; 20;&#125;objArr .findIndex(objFn);//值为1(即大王的下标) 第二条的意思就更好理解了，因为findindex只返回第一个符合条件的元素下标，所以在找到第一个符合条件的元素之后，他会跳出该函数，之后的数组内的元素将不再调用，相当于加了个break； 实际用法举例 假如我们要在所有人里面挑选队友，但是不想重复。在我们通过id查找的时候，就可以这么写12345678910111213141516171819202122232425var allPeple = [&#123; name: &apos;小王&apos;, id: 14&#125;,&#123; name: &apos;大王&apos;, id: 41&#125;,&#123; name: &apos;老王&apos;, id: 61&#125;] var myTeamArr = [&#123; name: &apos;小王&apos;, id: 14&#125;] var PId = 14; //假如这个是要添加的人的IDfunction pFn(p)&#123;return p.id == PId ;&#125;//判断myteam里是不是有这个队员，如果==-1 代表没有，在allPeople中找到他，添加入我的队伍myTeamArr.findIndex(pFn) == -1 ? myTeamArr.push(allPeple.find(pFn)) : alert(&apos;已存在该人员&apos;);//这样写可以将两个for循环直接总结成一行代码 另外需要补充的一点 与其相对应的有find()函数，用法一致，只不过返回的是元素本身，而不是元素的下标。 兼容性 因为是es6的所以使用的时候要注意兼容性问题，ie11及之前的版本都不可兼容。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zsfmyz.top/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zsfmyz.top/tags/JavaScript/"}]},{"title":"Call，apply，bind的区别及实现","slug":"call，apply，bind的区别及实现","date":"2019-01-11T07:10:03.000Z","updated":"2020-03-27T09:56:43.174Z","comments":true,"path":"JavaScript/call，apply，bind的区别及实现/","link":"","permalink":"http://www.zsfmyz.top/JavaScript/call，apply，bind的区别及实现/","excerpt":"call，apply，bind的区别这三个函数的左右都是为了指定当前的this。 不同点： call，apply 两者都是对函数的直接调用，bind的返回值仍然是一个函数。 举例：a.call(b) 或者 a.apply(b) 而bind需要 a.bind(b)()这样才能执行 call和apply的传参方式不同，第一个值都是this的指向，第二个举例","text":"call，apply，bind的区别这三个函数的左右都是为了指定当前的this。 不同点： call，apply 两者都是对函数的直接调用，bind的返回值仍然是一个函数。 举例：a.call(b) 或者 a.apply(b) 而bind需要 a.bind(b)()这样才能执行 call和apply的传参方式不同，第一个值都是this的指向，第二个举例 123456a.call(b, 参数1，参数2，参数3)a.apply(b, [参数1，参数2，参数3])//同样的bind的传参方式和call相同，但又因为bind返回的是函数，所以我们可以像正常函数传参一样a.bind(b)(参数1，参数2，参数3) 以上就是三者的差别。 接下来我们实现他们的功能函数。 call： call的传入参数是（ctx,…[]） 1234567891011Function.prototype.mycall = funciton (ctx) &#123; if (typeof this != &quot;function&quot;) &#123; throw new TypeError(&apos;error&apos;); &#125; ctx = ctx || window; ctx.fn = this; var args = ...arguments.splice(1); var result = ctx.fn(args); delete ctx.fn; return result;&#125; apply: apply的传入参数跟call不同，第二个参数是数组。 1234567891011121314Function.prototype.myapply = funciton (ctx) &#123; if (typeof this != &apos;function&apos;) &#123; throw new TypeError(&apos;error&apos;); &#125; ctx = ctx || window; ctx.fn = this; var result; if (arguments[1]) &#123; result = ctx.fn(arguments[1]); &#125; else &#123; result = ctx.fn(); &#125; return result;&#125; bind 返回的是个函数 bind 返回的是个函数，同样可以执行传参 ，我们可以用myapply实现 12345Funtion.prototype.myBind = function(ctx,...args1)&#123; return (...args2) =&gt; &#123; this.myapply(ctx, args1.concat(args2)) &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zsfmyz.top/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zsfmyz.top/tags/JavaScript/"}]},{"title":"Opacity引发的元素层级变化","slug":"Opcity引发的元素层级变化","date":"2018-06-29T10:14:27.000Z","updated":"2020-03-27T09:56:43.174Z","comments":true,"path":"Css/Opcity引发的元素层级变化/","link":"","permalink":"http://www.zsfmyz.top/Css/Opcity引发的元素层级变化/","excerpt":"背景 发现这个问题是在图片上定位了一个删除按钮，当我用opacity属性对图片进行透明化处理的时候，发现删除按钮不管用了，最后发现删除按钮是被图片覆盖了，究其原因是因为opacity这个属性造成的层级变化。 我发现含有opacity属性的元素层级会比其他元素的层级高，这时候z-index是不起作用的，opacity会一直高于其他元素的层级。 给其他元素加上position属性，会使该元素跟opacity处在同一层级之上，这时候你再给元素附加z-index就可以起作用了。","text":"背景 发现这个问题是在图片上定位了一个删除按钮，当我用opacity属性对图片进行透明化处理的时候，发现删除按钮不管用了，最后发现删除按钮是被图片覆盖了，究其原因是因为opacity这个属性造成的层级变化。 我发现含有opacity属性的元素层级会比其他元素的层级高，这时候z-index是不起作用的，opacity会一直高于其他元素的层级。 给其他元素加上position属性，会使该元素跟opacity处在同一层级之上，这时候你再给元素附加z-index就可以起作用了。 总结和解决方案 总结：当你使用opacity的时候会对元素层级造成影响 解决办法：加上position和z-index可以对opacity元素进行覆盖 1234567891011121314151617181920212223.box&#123; width: 200px; height: 200px; background-color: red; color: #fff; cursor: pointer; &#125; .box1&#123; opacity: 0.8; &#125; .box2&#123; background-color: blue; margin-left: 30px; margin-top: -160px; position: relative; z-index: 100; &#125; .box3&#123; background-color: green; margin-left: 60px; margin-top: -160px; opacity: 0.7; &#125; 如上：box2的层级是最高的。","categories":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/categories/Css/"}],"tags":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/tags/Css/"}]},{"title":"Linux压缩命令常用：tar，tgz，gzip，zip","slug":"linux压缩命令常用：tar，tgz，gzip，zip","date":"2018-06-02T10:14:27.000Z","updated":"2020-03-27T09:56:43.175Z","comments":true,"path":"Linux/linux压缩命令常用：tar，tgz，gzip，zip/","link":"","permalink":"http://www.zsfmyz.top/Linux/linux压缩命令常用：tar，tgz，gzip，zip/","excerpt":"linux压缩命令常用的有三个：tar，tgz，gzip，zip","text":"linux压缩命令常用的有三个：tar，tgz，gzip，zip 一，tar（一） tar压缩命令 12345678910tar -cvf examples.tar files|dir#说明：-c, --create create a new archive 创建一个归档文件-v, --verbose verbosely list files processed 显示创建归档文件的进程-f, --file=ARCHIVE use archive file or device ARCHIVE 后面要立刻接被处理的档案名,比如--file=examples.tar#举例：tar -cvf file.tar file1 #file1文件tar -cvf file.tar file1 file2 #file1，file2文件tar -cvf file.tar dir #dir目录 （二） tar 解压命令 123456789tar -xvf examples.tar （解压至当前目录下）tar -xvf examples.tar -C /path (/path 解压至其它路径)#说明：-x, --extract, extract files from an archive 从一个归档文件中提取文件#举例：tar -xvf file.tartar -xvf file.tar -C /temp #解压到temp目录下 二，tgz（一） tgz压缩命令（tar.gz,tgz格式是相同的，命名不同而已） 1234567tar -zcvf examples.tgz examples (examples当前执行路径下的目录)说明：-z, --gzip filter the archive through gzip 通过gzip压缩的形式对文件进行归档举例：tar -zcvf file.tgz dir #dir目录 （二） tgz 解压命令 123456tar -zxvf examples.tar （解压至当前执行目录下）tar -zxvf examples.tar -C /path (/path 解压至其它路径)举例：tar -zcvf file.tgztar -zcvf file.tgz -C /temp 三，gzip（一）gzip压缩： 1gzip -d examples.gz examples （二）gzip解压： 1gunzip examples.gz 四，zip zip 格式是开放且免费的，所以广泛使用在 Windows、Linux、MacOS 平台，要说 zip有什么缺点的话，就是它的压缩率并不是很高，不如 rar及 tar.gz 等格式。 压缩： 1zip -r examples.zip examples (examples为目录) 解压： 1zip examples.zip 六 .rar压缩： 1rar -a examples.rar examples 解压： 1rar -x examples.rar","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.zsfmyz.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.zsfmyz.top/tags/Linux/"}]},{"title":"Css3 + Js：有趣的图片马赛克~ (高斯模糊)","slug":"css3 + Js：有趣的图片马赛克~ (高斯模糊)","date":"2018-05-21T08:59:13.000Z","updated":"2020-04-15T07:40:23.890Z","comments":true,"path":"Css/css3 + Js：有趣的图片马赛克~ (高斯模糊)/","link":"","permalink":"http://www.zsfmyz.top/Css/css3 + Js：有趣的图片马赛克~ (高斯模糊)/","excerpt":"前两篇文介绍了css3的过滤器filter用来实现图片的高斯模糊效果，还有js拖拽的功能。 要实现局部模糊就要把两者结合起来，计算位移就可以了。 实现原理 原理其实很简单，就是两张图的叠加。底部一张清晰的图，上面一个高斯模糊过的图，将高斯模糊的图当作上层元素的背景，利用背景定位使其只显示一部分，然后把这个高斯模糊的窗口放置在高清图的上层，背景图片的位置与下面的图片位置一致，这样看起来就像一张高清的图片打上了马赛克一样。讲起来不是很清楚，大家可以看一下代码。","text":"前两篇文介绍了css3的过滤器filter用来实现图片的高斯模糊效果，还有js拖拽的功能。 要实现局部模糊就要把两者结合起来，计算位移就可以了。 实现原理 原理其实很简单，就是两张图的叠加。底部一张清晰的图，上面一个高斯模糊过的图，将高斯模糊的图当作上层元素的背景，利用背景定位使其只显示一部分，然后把这个高斯模糊的窗口放置在高清图的上层，背景图片的位置与下面的图片位置一致，这样看起来就像一张高清的图片打上了马赛克一样。讲起来不是很清楚，大家可以看一下代码。 基础版本HTML1234567891011121314151617181920212223242526272829303132333435&lt;style type=&quot;text/css&quot;&gt; #css_box &#123; position: relative; width: 100%; height: 500px; background: url(&apos;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1567844929804&amp;di=75928af77a3db7ff54cd4eab49361bc0&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fblog%2F201307%2F19%2F20130719082039_k2NHG.jpeg&apos;) no-repeat; &#125; #css_target &#123; position: absolute; left: 0px; top: 0px; width: 200px; height: 200px; background: inherit; filter: blur(10px); /* 继承父元素的background属性 */ &#125;&lt;/style&gt;&lt;div class=&quot;demo post white-box article-type-post&quot;&gt; &lt;div id=&quot;css_box&quot;&gt; &lt;div id=&quot;css_target&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var bar = document.getElementById(&quot;css_box&quot;); var target = document.getElementById(&quot;css_target&quot;); startDrag(bar, target, function(x, y) &#123; target.style.backgroundPosition = (-1 * x) + &quot;px &quot; + (-1 * y) + &quot;px&quot;; &#125;);&lt;/script&gt; JS (当作JS文件引入)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586var getCss = function(o, key) &#123; return o.currentStyle ? o.currentStyle[key] : document.defaultView.getComputedStyle(o, false)[key];&#125;;// 拖拽var startDrag = function(bar, target, callback) &#123; maxX = parseInt(getCss(bar, &quot;width&quot;)) - parseInt(getCss(target, &quot;width&quot;)); maxY = parseInt(getCss(bar, &quot;height&quot;)) - parseInt(getCss(target, &quot;height&quot;)); var resX = 0, resY = 0; var params = &#123; left: 0, top: 0, currentX: 0, currentY: 0, flag: false &#125;; if (getCss(target, &quot;left&quot;) !== &quot;auto&quot;) &#123; params.left = getCss(target, &quot;left&quot;); &#125; if (getCss(target, &quot;top&quot;) !== &quot;auto&quot;) &#123; params.top = getCss(target, &quot;top&quot;); &#125; target.onmousedown = function(event) &#123; params.flag = true; if (!event) &#123; event = window.event; bar.onselectstart = function() &#123; return false; &#125; &#125; var e = event; params.currentX = e.clientX; params.currentY = e.clientY; &#125;; document.onmouseup = function() &#123; params.flag = false; if (getCss(target, &quot;left&quot;) !== &quot;auto&quot;) &#123; params.left = getCss(target, &quot;left&quot;); &#125; if (getCss(target, &quot;top&quot;) !== &quot;auto&quot;) &#123; params.top = getCss(target, &quot;top&quot;); &#125; &#125;; document.onmousemove = function(event) &#123; var e = event ? event : window.event; if (params.flag) &#123; var nowX = e.clientX, nowY = e.clientY; var disX = nowX - params.currentX, disY = nowY - params.currentY; if ((parseInt(params.left) + disX) &gt; maxX) &#123; resX = maxX; &#125; else if ((parseInt(params.left) + disX) &lt; 0) &#123; resX = 0; &#125; else &#123; resX = parseInt(params.left) + disX; &#125; if ((parseInt(params.top) + disY) &gt; maxY) &#123; resY = maxY; &#125; else if ((parseInt(params.top) + disY) &lt; 0) &#123; resY = 0; &#125; else &#123; resY = parseInt(params.top) + disY; &#125; target.style.left = resX + &apos;px&apos; target.style.top = resY + &apos;px&apos; if (typeof callback == &quot;function&quot;) &#123; callback(resX, resY); &#125; if (event.preventDefault) &#123; event.preventDefault(); &#125; return false; &#125; &#125;&#125;; 兼容移动端优化版本HTML12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;style type=&quot;text/css&quot;&gt; #css_box &#123; position: relative; touch-action: none; width: 100%; height: 500px; background: url(&apos;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1567844929804&amp;di=75928af77a3db7ff54cd4eab49361bc0&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fblog%2F201307%2F19%2F20130719082039_k2NHG.jpeg&apos;) no-repeat; background-size: contain; &#125; #css_target &#123; position: absolute; left: 0px; top: 0px; background: inherit; filter: blur(10px); touch-action: none; /* 继承父元素的background属性 */ &#125;&lt;/style&gt;&lt;div class=&quot;demo post white-box article-type-post&quot;&gt; &lt;h2 class=&quot;title&quot;&gt;mosaic Demo &lt;a style=&quot;color: #bd4117;&quot; href=&quot;https://www.zsfmyz.top/Css/Css3%20+%20Js%EF%BC%9A%E5%9B%BE%E7%89%87%E7%9A%84%E5%B1%80%E9%83%A8%E6%A8%A1%E7%B3%8A%EF%BC%88%E9%A9%AC%E8%B5%9B%E5%85%8B%EF%BC%89/&quot;&gt;传送门&lt;/a&gt;&lt;/h2&gt; &lt;div id=&quot;css_box&quot;&gt; &lt;div id=&quot;css_target&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;p id=&quot;position_img&quot;&gt;X: 0 px Y: 0 px&lt;/p&gt;&lt;/div&gt;&lt;script&gt; $(document).ready(function() &#123; var bar = document.getElementById(&quot;css_box&quot;); var target = document.getElementById(&quot;css_target&quot;); var p_img = document.getElementById(&quot;position_img&quot;); // 兼容分辨率 bar.style.height = (parseInt(getCss(bar, &quot;width&quot;)) * 636 / 900) + &apos;px&apos;; target.style.backgroundSize = parseInt(getCss(bar, &quot;width&quot;)) + &apos;px &apos; + (parseInt(getCss(bar, &quot;width&quot;)) * 636 / 900) + &apos;px&apos;; startDrag(bar, target, function(x, y) &#123; target.style.backgroundPosition = (-1 * x) + &quot;px &quot; + (-1 * y) + &quot;px&quot;; p_img.innerText = &quot;X: &quot; + target.style.left + &quot; Y: &quot; + target.style.top; &#125;);&#125;)&lt;/script&gt; JS (当作JS文件引入)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118&lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 拖拽 var startDrag = function(bar, target, callback) &#123; var getCss = function(o, key) &#123; return o.currentStyle ? o.currentStyle[key] : document.defaultView.getComputedStyle(o, false)[key]; &#125;; var down = function(event) &#123; // 兼容分辨率 bar.style.height = (parseInt(getCss(bar, &quot;width&quot;)) * 636 / 900) + &apos;px&apos;; target.style.backgroundSize = parseInt(getCss(bar, &quot;width&quot;)) + &apos;px &apos; + (parseInt(getCss(bar, &quot;width&quot;)) * 636 / 900) + &apos;px&apos;; params.flag = true; if (!event) &#123; event = window.event; bar.onselectstart = function() &#123; return false; &#125; &#125; var e = event; params.currentX = e.clientX || e.changedTouches[0].clientX; params.currentY = e.clientY || e.changedTouches[0].clientY; &#125;; var up = function() &#123; params.flag = false; if (getCss(target, &quot;left&quot;) !== &quot;auto&quot;) &#123; params.left = getCss(target, &quot;left&quot;); &#125; if (getCss(target, &quot;top&quot;) !== &quot;auto&quot;) &#123; params.top = getCss(target, &quot;top&quot;); &#125; &#125;; var move = function(event) &#123; var e = event ? event : window.event; if (params.flag) &#123; var nowX = e.clientX || e.changedTouches[0].clientX, nowY = e.clientY || e.changedTouches[0].clientY; var disX = nowX - params.currentX, disY = nowY - params.currentY; if ((parseInt(params.left) + disX) &gt; maxX) &#123; resX = maxX; &#125; else if ((parseInt(params.left) + disX) &lt; 0) &#123; resX = 0; &#125; else &#123; resX = parseInt(params.left) + disX; &#125; if ((parseInt(params.top) + disY) &gt; maxY) &#123; resY = maxY; &#125; else if ((parseInt(params.top) + disY) &lt; 0) &#123; resY = 0; &#125; else &#123; resY = parseInt(params.top) + disY; &#125; target.style.left = resX + &apos;px&apos; target.style.top = resY + &apos;px&apos; if (typeof callback == &quot;function&quot;) &#123; callback(resX, resY); &#125; if (event.preventDefault) &#123; event.preventDefault(); &#125; return false; &#125; &#125; var resX = 0, resY = 0; var params = &#123; left: 0, top: 0, currentX: 0, currentY: 0, flag: false &#125;; if (getCss(target, &quot;left&quot;) !== &quot;auto&quot;) &#123; params.left = getCss(target, &quot;left&quot;); &#125; if (getCss(target, &quot;top&quot;) !== &quot;auto&quot;) &#123; params.top = getCss(target, &quot;top&quot;); &#125; if ((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) &#123; console.log(&quot;mobile&quot;); target.style.width = &apos;100px&apos;; target.style.height = &apos;100px&apos;; maxX = parseInt(getCss(bar, &quot;width&quot;)) - parseInt(getCss(target, &quot;width&quot;)); maxY = parseInt(getCss(bar, &quot;height&quot;)) - parseInt(getCss(target, &quot;height&quot;)); target.ontouchstart = down document.ontouchend = up document.ontouchmove = move &#125; else &#123; console.log(&quot;pc&quot;); target.style.width = &apos;150px&apos;; target.style.height = &apos;150px&apos;; maxX = parseInt(getCss(bar, &quot;width&quot;)) - parseInt(getCss(target, &quot;width&quot;)); maxY = parseInt(getCss(bar, &quot;height&quot;)) - parseInt(getCss(target, &quot;height&quot;)); target.onmousedown = down document.onmouseup = up document.onmousemove = move &#125; &#125;;&lt;/script&gt; 以上就是局部模糊的实现方法。可以直接套用。将JS部分当作文件引入。否则要把初始化函数放在函数声明的后面。 最后可查看实际效果：demo演示地址 借鉴于张大神","categories":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/categories/Css/"}],"tags":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/tags/Css/"}]},{"title":"CSS3：图片的高斯模糊效果","slug":"CSS3：图片的高斯模糊效果","date":"2018-05-18T08:59:13.000Z","updated":"2020-04-15T07:40:23.890Z","comments":true,"path":"Css/CSS3：图片的高斯模糊效果/","link":"","permalink":"http://www.zsfmyz.top/Css/CSS3：图片的高斯模糊效果/","excerpt":"CSS3：图片的高斯模糊效果 最近项目中需要预览视频中加马赛克的效果（高斯模糊），于是找到了css3的一个属性filter来进行高斯模糊","text":"CSS3：图片的高斯模糊效果 最近项目中需要预览视频中加马赛克的效果（高斯模糊），于是找到了css3的一个属性filter来进行高斯模糊 filter（滤镜） 可以用来定义图片或者div的饱和度，模糊程度，亮度等一系列。具体参考 CSS3：filter 属性 兼容性 兼容性方案123//高斯模糊-webkit-filter：blur(10px);filter:blur(10px); 高斯模糊的这个属性是对整个元素进行高斯模糊。如果你需要局部模糊，需要结合背景定位。原理就是两层图片叠加，底层清晰，上层模糊。接下来我会结合拖拽和背景定位实现图片的局部模糊。下一篇传送门：js拖拽实现","categories":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/categories/Css/"}],"tags":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/tags/Css/"}]},{"title":"HTML5 Video 全屏","slug":"HTML5 video 全屏","date":"2018-04-13T10:14:27.000Z","updated":"2020-03-27T09:56:43.174Z","comments":true,"path":"JavaScript/HTML5 video 全屏/","link":"","permalink":"http://www.zsfmyz.top/JavaScript/HTML5 video 全屏/","excerpt":"当我们使用video标签的时候，有时候因为更多的需要，我们要自己自定义控制栏，而进入和退出全屏也是其中的一部分 不同的浏览器有不同的实现方法1234567891011// Webkitelement.webkitRequestFullScreen();//进入全屏document.webkitCancelFullScreen();//退出全屏// Firefoxelement.mozRequestFullScreen();document.mozCancelFullScreen(); // W3C element.requestFullscreen();document.exitFullscreen();","text":"当我们使用video标签的时候，有时候因为更多的需要，我们要自己自定义控制栏，而进入和退出全屏也是其中的一部分 不同的浏览器有不同的实现方法1234567891011// Webkitelement.webkitRequestFullScreen();//进入全屏document.webkitCancelFullScreen();//退出全屏// Firefoxelement.mozRequestFullScreen();document.mozCancelFullScreen(); // W3C element.requestFullscreen();document.exitFullscreen(); 一般兼容性写法，我们先使用w3c标准的方法，如果不可以在兼容不同浏览器。 12345678910111213141516171819202122//进入全屏function FullScreen() &#123; var ele = document.documentElement; if (ele .requestFullscreen) &#123; ele .requestFullscreen(); &#125; else if (ele .mozRequestFullScreen) &#123; ele .mozRequestFullScreen(); &#125; else if (ele .webkitRequestFullScreen) &#123; ele .webkitRequestFullScreen(); &#125;&#125;//退出全屏function exitFullscreen() &#123; var de = document; if (de.exitFullscreen) &#123; de.exitFullscreen(); &#125; else if (de.mozCancelFullScreen) &#123; de.mozCancelFullScreen(); &#125; else if (de.webkitCancelFullScreen) &#123; de.webkitCancelFullScreen(); &#125;&#125; 接下来是用例 1234$(ele).on(&apos;click&apos;,function()&#123; FullScreen(); // exitFullscreen();&#125;);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zsfmyz.top/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zsfmyz.top/tags/JavaScript/"}]},{"title":"Angular 的 uiRouter 的 方法$state.includes （判断当前激活路由）","slug":"angular 的 uiRouter 的 方法$state.includes （判断当前激活路由）","date":"2018-02-27T10:08:30.000Z","updated":"2020-03-27T09:56:43.174Z","comments":true,"path":"Angular/angular 的 uiRouter 的 方法$state.includes （判断当前激活路由）/","link":"","permalink":"http://www.zsfmyz.top/Angular/angular 的 uiRouter 的 方法$state.includes （判断当前激活路由）/","excerpt":"angular 的 uiRouter 的 方法$state.includes （判断当前激活路由）作用： 该方法用于判断当前激活的也就是地址栏的路由地址是哪个路由。 比如 $state.includes(‘app’) 那么如果页面地址为“www.baidu.com#/app” 或者 “www.baidu.com#/app/xxx” 的时候，该方法的值会返回true。（一般我们定义的路由和地址栏地址是相互对应的，方便管理。举例也是在app.xxx对应app/xxx这样设置路由的情况下） 如激活的路由为 app.page.page1 那么 123$state.includes(&apos;app&apos;) //返回 true$state.includes(&apos;app.page&apos;) //返回 true$state.includes(&apos;app.page.page1&apos;) //返回 true","text":"angular 的 uiRouter 的 方法$state.includes （判断当前激活路由）作用： 该方法用于判断当前激活的也就是地址栏的路由地址是哪个路由。 比如 $state.includes(‘app’) 那么如果页面地址为“www.baidu.com#/app” 或者 “www.baidu.com#/app/xxx” 的时候，该方法的值会返回true。（一般我们定义的路由和地址栏地址是相互对应的，方便管理。举例也是在app.xxx对应app/xxx这样设置路由的情况下） 如激活的路由为 app.page.page1 那么 123$state.includes(&apos;app&apos;) //返回 true$state.includes(&apos;app.page&apos;) //返回 true$state.includes(&apos;app.page.page1&apos;) //返回 true 用法： 知道了它的作用，接下来看看它的使用背景。 我们可以用来激活当前menu的状态。即使当前路由对应的菜单高亮或激活状态。 举例： 123456789101112131415161718192021&lt;div ng-init=&quot;menu_flag= !($state.includes(&apos;app.page1&apos;) || $state.includes(&apos;app.page2&apos;))&quot;&gt; 主菜单&lt;/div&gt;&lt;div ng-hide=&quot;menu_flag&quot;&gt; &lt;div ng-class=&quot;&#123;active: $state.includes(&apos;app.page1&apos;)&#125;&quot;&gt; &lt;a href=&quot;javascript:;&quot; ui-sref=&quot;app.page1&quot;&gt;子菜单一&lt;/a&gt; &lt;/div&gt; &lt;div ng-class=&quot;&#123;active: $state.includes(&apos;app.page2&apos;)&#125;&quot;&gt; &lt;a href=&quot;javascript:;&quot; ui-sref=&quot;app.page2&quot;&gt;子菜单二&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;// ...... n个类似结构组成的菜单&lt;div ng-init=&quot;menu_flag1= !($state.includes(&apos;app.page3&apos;) || $state.includes(&apos;app.page4&apos;))&quot;&gt; 主菜单&lt;/div&gt;&lt;div ng-hide=&quot;menu_flag1&quot;&gt; &lt;div ng-class=&quot;&#123;active: $state.includes(&apos;app.page3&apos;)&#125;&quot;&gt; &lt;a href=&quot;javascript:;&quot; ui-sref=&quot;app.page1&quot;&gt;子菜单一&lt;/a&gt; &lt;/div&gt; &lt;div ng-class=&quot;&#123;active: $state.includes(&apos;app.page4&apos;)&#125;&quot;&gt; &lt;a href=&quot;javascript:;&quot; ui-sref=&quot;app.page2&quot;&gt;子菜单二&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; 如上我们的菜单构成是由若干个类似结构构成，主menu控制若干个子menu。active是我们定义的激活菜单的css类名，当我们选中某个菜单时激活该菜单。即可借用$state.includes()来实现该功能。 同时，当我们的主menu要控制闭合和展开的话，当我们刷新的时候，我们通过判断($state.includes(&#39;app.page3&#39;) || $state.includes(&#39;app.page4&#39;)) 的值来在刷新之后判断该主菜单是否闭合。 当然我们也可以这样定义我们的路由。当然我们也可以这样定义我们的路由。例如： 一层菜单为 app.menu1 , 该主菜单下路由定义为 路由名称 一级路由定义 二级路由定义 一层菜单 app.menu1 二层菜单 app.menu1.menu1_1 二层菜单 app.menu1.menu1_2 这样的话我们在主菜单闭合上只需要判断 $state.includes(app.menu1) 即可。","categories":[{"name":"Angular","slug":"Angular","permalink":"http://www.zsfmyz.top/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://www.zsfmyz.top/tags/Angular/"}]},{"title":"文本的水平垂直居中","slug":"文本文字在DIV中垂直水平居中显示","date":"2018-01-17T08:59:13.000Z","updated":"2020-03-27T09:56:43.175Z","comments":true,"path":"Css/文本文字在DIV中垂直水平居中显示/","link":"","permalink":"http://www.zsfmyz.top/Css/文本文字在DIV中垂直水平居中显示/","excerpt":"#文字居中 ##垂直居中（vertical-align）我们都知道有这么一个属性可以让图片，文本等在元素中垂直居中1vertical-align:middle; vertical-align值有很多，常用的就是middle，bottom，text-bottom等，我们先说middle。","text":"#文字居中 ##垂直居中（vertical-align）我们都知道有这么一个属性可以让图片，文本等在元素中垂直居中1vertical-align:middle; vertical-align值有很多，常用的就是middle，bottom，text-bottom等，我们先说middle。 vertical-align时而没效果然而真实使用的时候，我们会发现这个属性“时灵时不灵”，有些情况下我们加了这个属性之后仍然不见img或者text有任何的变化。那是因为vertical-align只作用在inline-block或者inline，还有table-cell等元素内。同时这两种还有有所不同。 vertical-align并不是在高度内居中，而是对齐在行高内的middle线上。 所以我总结了两种使用vertical-align居中的方法： 第一种 1234&lt;div style=&quot;vertical-align: middle;display: table-cell;&quot;&gt; &lt;img src=&quot;02.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;文本居中&lt;/p&gt;&lt;/div&gt; 这种情况下图片和文字可以分行显示文字在图片下面同时图片和文字作为整体在元素内垂直居中。 第二种 1234&lt;div style=&quot;height:180px;line-height:180px;&quot;&gt; &lt;img src=&quot;02.jpg&quot; alt=&quot;图片&quot; style=&quot;vertical-align:middle;&quot; /&gt; 这是文本内容.&lt;/div&gt; 这种情况下文字是因为line-height属性而居中，跟vertical-align属性没有关系。同时img对齐在middle线上，但是如果父盒子去掉了line-height属性的话那么将会不起作用。（可以试试bottom和text-bottom的不同。） ##水平居中 1text-align:center; over","categories":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/categories/Css/"}],"tags":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/tags/Css/"}]},{"title":"Angular中ng-Repeat的track by 的使用（$Index）","slug":"angular中ng-repeat的track by 的使用（$index）","date":"2017-11-27T10:14:27.000Z","updated":"2020-03-27T09:56:43.174Z","comments":true,"path":"Angular/angular中ng-repeat的track by 的使用（$index）/","link":"","permalink":"http://www.zsfmyz.top/Angular/angular中ng-repeat的track by 的使用（$index）/","excerpt":"在angular中使用ng-repeat时数组中有重复元素 当我们在循环的数组中存在有重复的元素时候，angular的ng-repeat就会报错，那是因为其不允许collection有相同的id（相同的元素会形成相同的id）出现。而基本的数据类型它的id就是它自身的值。","text":"在angular中使用ng-repeat时数组中有重复元素 当我们在循环的数组中存在有重复的元素时候，angular的ng-repeat就会报错，那是因为其不允许collection有相同的id（相同的元素会形成相同的id）出现。而基本的数据类型它的id就是它自身的值。 我们要避免这种情况通常会使用track by $index 来让其生成自己不同的id，这样是最常用的直接通过索引来生成id。我们也可以通过自己设置业务上的id，然后用其进行遍历track by item.id. 总结一下，解决重复问题的方法就是item in items track by $index 使用$index会出现的问题。 我们使用$index不仅仅是为了避免重复元素的问题，有时候会被使用$index的索引来进行一部分操作，这里有一个坑需要注意。 当我们使用$index的时候，下列情况会出现$index跟原序列不匹配的情况 当我们改变列表的顺序的时候 当我们在列表中插入或者删除的时候 由于$index会跟随item上移下移，或者随之被删除。（例如你把列表第二条和第一条位置互换，这时候列表现在第一条的$index依旧为2，第二条还是原来的1）这时候你再使用$index传值就不在是新数组的索引了，不再匹配。 所以使用$index的时候要特别注意这些问题","categories":[{"name":"Angular","slug":"Angular","permalink":"http://www.zsfmyz.top/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://www.zsfmyz.top/tags/Angular/"}]},{"title":"Angular 的Http请求回调（success 和 Error）","slug":"angular 的http请求回调（success 和 error）","date":"2017-11-27T08:59:13.000Z","updated":"2020-03-27T09:56:43.174Z","comments":true,"path":"Angular/angular 的http请求回调（success 和 error）/","link":"","permalink":"http://www.zsfmyz.top/Angular/angular 的http请求回调（success 和 error）/","excerpt":"前面有文章写过angular的$http请求的简单书写和使用。回顾一下： 12345678910111213141516171819202122232425262728293031var Server = angular.module(&quot;Server&quot;, []);Server.service(&quot;Api&quot;, [&quot;$http&quot;, function ($http) &#123; return &#123; getTest : function (params, callback) &#123; $http(&#123; url: &apos;www.baidu.com?name=xxx&amp;passwd=xxx&apos;, method: &apos;GET&apos; &#125;).success(callback); &#125;, postTest : function (data, callback) &#123; $http(&#123; url: &apos;www.baidu.com&apos;, data: data, method: &apos;POST&apos; &#125;).success(callback); &#125;&#125;]);var App = angular.module(&quot;App&quot;, [ &quot;Server&quot;]);App.controller(&apos;Ctrl&apos;, [&apos;$scope&apos;, &apos;Api&apos;, function($scope, Api) &#123; Api.getTest(&quot;?name=xxx&amp;passwd=xxx&quot;, function(res)&#123; //res为返回值 alert(&quot;请求成功！&quot;) &#125;); Api.postTest(&#123;name: xxx, passwd: xxx&#125;, function(res)&#123; //res为返回值 alert(&quot;请求成功！&quot;) &#125;); &#125;]);","text":"前面有文章写过angular的$http请求的简单书写和使用。回顾一下： 12345678910111213141516171819202122232425262728293031var Server = angular.module(&quot;Server&quot;, []);Server.service(&quot;Api&quot;, [&quot;$http&quot;, function ($http) &#123; return &#123; getTest : function (params, callback) &#123; $http(&#123; url: &apos;www.baidu.com?name=xxx&amp;passwd=xxx&apos;, method: &apos;GET&apos; &#125;).success(callback); &#125;, postTest : function (data, callback) &#123; $http(&#123; url: &apos;www.baidu.com&apos;, data: data, method: &apos;POST&apos; &#125;).success(callback); &#125;&#125;]);var App = angular.module(&quot;App&quot;, [ &quot;Server&quot;]);App.controller(&apos;Ctrl&apos;, [&apos;$scope&apos;, &apos;Api&apos;, function($scope, Api) &#123; Api.getTest(&quot;?name=xxx&amp;passwd=xxx&quot;, function(res)&#123; //res为返回值 alert(&quot;请求成功！&quot;) &#125;); Api.postTest(&#123;name: xxx, passwd: xxx&#125;, function(res)&#123; //res为返回值 alert(&quot;请求成功！&quot;) &#125;); &#125;]); 这里以GET和POST请求为例。首先我们需要在APP中注入Server这个模块，才能使用里面的service服务Api，如上代码所示，注入Server之后我们就可以在控制器Ctl里面注入Api服务，然后使用我们之前定义好的接口。 GET请求中params 代表了？之后的参数，即 params == ‘?name=xxx&amp;passwd=xxx’,这样就可以通过传参的方式把参数加入到地址上，callback是请求成功后的回调，是个function，我们可以在里面打印出请求成功的返回值。 POST请求中data代表请求参数，传入之后直接请求即可，其他跟get请求类似。 error还有一点需要说的是http请求有时候会失败，当我们http请求失败的时候，将不会再调用success回调函数，而是会进入error回调，下面我就写一下http请求的success和error同时存在的写法。 123456789101112131415161718192021222324var Server = angular.module(&quot;Server&quot;, []);Server.service(&quot;Api&quot;, [&quot;$http&quot;, function ($http) &#123; return &#123; getTest : function (params, successCallback, errorCallback) &#123; $http(&#123; url: &apos;www.baidu.com?name=xxx&amp;passwd=xxx&apos;, method: &apos;GET&apos; &#125;).then(successCallback, errorCallback); &#125;&#125;]);var App = angular.module(&quot;App&quot;, [ &quot;Server&quot;]);App.controller(&apos;Ctrl&apos;, [&apos;$scope&apos;, &apos;Api&apos;, function($scope, Api) &#123; Api.getTest(&quot;?name=xxx&amp;passwd=xxx&quot;, function(res)&#123; //res为返回值 alert(&quot;请求成功！&quot;) &#125;, function(res)&#123; //res为返回值 alert(&quot;请求失败！&quot;) &#125;); &#125;]); 用法几乎一样，只不过把success(callback)改成了then(callback1, callback2).然后在调用的时候再加入一个function即可。 最简单的get写法 1234$http(&#123; url: &apos;www.baidu.com?name=xxx&amp;passwd=xxx&apos;, method: &apos;GET&apos; &#125;).success(callback);","categories":[{"name":"Angular","slug":"Angular","permalink":"http://www.zsfmyz.top/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://www.zsfmyz.top/tags/Angular/"}]}],"categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"},{"name":"Vue","slug":"Vue","permalink":"http://www.zsfmyz.top/categories/Vue/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zsfmyz.top/categories/JavaScript/"},{"name":"api","slug":"api","permalink":"http://www.zsfmyz.top/categories/api/"},{"name":"Git","slug":"Git","permalink":"http://www.zsfmyz.top/categories/Git/"},{"name":"Linux","slug":"Linux","permalink":"http://www.zsfmyz.top/categories/Linux/"},{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/categories/Css/"},{"name":"Hexo","slug":"Hexo","permalink":"http://www.zsfmyz.top/categories/Hexo/"},{"name":"Angular","slug":"Angular","permalink":"http://www.zsfmyz.top/categories/Angular/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"},{"name":"Vue","slug":"Vue","permalink":"http://www.zsfmyz.top/tags/Vue/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zsfmyz.top/tags/JavaScript/"},{"name":"api","slug":"api","permalink":"http://www.zsfmyz.top/tags/api/"},{"name":"Git","slug":"Git","permalink":"http://www.zsfmyz.top/tags/Git/"},{"name":"Linux","slug":"Linux","permalink":"http://www.zsfmyz.top/tags/Linux/"},{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/tags/Css/"},{"name":"Hexo","slug":"Hexo","permalink":"http://www.zsfmyz.top/tags/Hexo/"},{"name":"Angular","slug":"Angular","permalink":"http://www.zsfmyz.top/tags/Angular/"}]}