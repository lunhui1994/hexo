{"meta":{"title":"Eighteen Blog","subtitle":"Eighteen Blog","description":"Eighteen Blog","author":"赵十八","url":"https://lunhui1994.github.io","root":"/"},"pages":[{"title":"about","date":"2019-08-27T09:38:13.000Z","updated":"2019-08-27T10:07:48.357Z","comments":true,"path":"about/index.html","permalink":"https://lunhui1994.github.io/about/index.html","excerpt":"","text":"好学力行，明德任责 目前正慢慢从CSDN迁移过来一些。 一个萝卜一个坑儿。 LH_ZSF"}],"posts":[{"title":"z-index失效了？","slug":"z-index失效了？","date":"2019-08-27T10:14:27.000Z","updated":"2019-08-27T10:18:57.276Z","comments":true,"path":"2019/08/27/z-index失效了？/","link":"","permalink":"https://lunhui1994.github.io/2019/08/27/z-index失效了？/","excerpt":"","text":"我们在使用z-index的时候，有时候会发现，无论怎么样增大z-index的值，都无法改变目标元素的层级。 其实是这几种情况在作怪 position float opcity 父盒子的层级问题，当你的父盒子层级小于另一个父盒子层级的时候，你子元素的z-index再高都是没有用的。该元素的层级只在该元素所在的容器内起作用。该种情况大家应该容易理解，不过也可以看下面的例子。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;style type=&quot;text/css&quot;&gt; .a1&#123; position:relative; z-index: 2; width:400px; height:400px; background: black; border:1px solid #eee; margin-bottom: -100px; &#125; .a&#123; position:relative; z-index: 1; width:400px; height:400px; background: yellow; left:0; border:1px solid #eee; &#125; .b&#123; position:absolute; left:0; top:0; z-index: 50; width:200px; height:200px; background: red; &#125; .c&#123; position: absolute; left:0; top:0; z-index:1111; width:100px; height:100px; background: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;a1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;a&quot;&gt; &lt;div class=&quot;b&quot;&gt;&lt;/div&gt; &lt;div class=&quot;c&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt; opcity属性，当你要设置两个元素的z-index值的时候，要注意是否给其中一个元素添加了opcity属性，如果添加了，那么添加了opcity属性的元素将一直在最上层，这个我在之前的文章中讲过 opcity引发的元素层级变化 还有就是比较普遍的，我们设置层级一般都是因为设置了position，当你设置的两个子元素，一个有position属性，另一个没有position的时候，拥有position属性的元素将一直在其他元素上方。如下面的例子123456789101112131415161718192021222324252627282930313233343536&lt;style type=&quot;text/css&quot;&gt; .a&#123; position:relative; z-index: 1; width:400px; height:400px; background: yellow; left:0; border:1px solid #eee; &#125; .b&#123; position:absolute; left:0; top:0; z-index: 50; width:200px; height:200px; background: red; &#125; .c&#123; z-index:100; width:100px; height:100px; background: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;a&quot;&gt; &lt;div class=&quot;b&quot;&gt;&lt;/div&gt; &lt;div class=&quot;c&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt; 需要给c也加上position属性才让bc可以先同处一级，然后z-index才会起作用。 那如果我把子元素的position都去掉呢？当父盒子有position而所有子元素都没有position属性的时候，z-index一样全部失效，后面的盒子将会覆盖前面的盒子，z-index无效。 同样的我们两个都加上浮动的效果跟上面的效果是一样的，后覆盖前，z-index无效 一个加float另一个不加，则是加float的元素一直浮动在最上层。 12345678910111213141516171819202122232425262728293031323334&lt;style type=&quot;text/css&quot;&gt; .a&#123; position:absolute; z-index: 1; width:400px; height:400px; background: yellow; left:0; border:1px solid #eee; &#125; .b&#123; z-index: -10; width:200px; height:200px; background: red; margin-bottom: -100px; &#125; .c&#123; z-index:101; width:100px; height:100px; background: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;a&quot;&gt; &lt;div class=&quot;b&quot;&gt;&lt;/div&gt; &lt;div class=&quot;c&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt; 其他情况欢迎补充。","categories":[],"tags":[]},{"title":"angular 的 uiRouter 的 方法$state.includes （判断当前激活路由）","slug":"angular 的 uiRouter 的 方法$state.includes （判断当前激活路由）","date":"2019-08-27T10:08:30.000Z","updated":"2019-08-27T10:12:23.695Z","comments":true,"path":"2019/08/27/angular 的 uiRouter 的 方法$state.includes （判断当前激活路由）/","link":"","permalink":"https://lunhui1994.github.io/2019/08/27/angular 的 uiRouter 的 方法$state.includes （判断当前激活路由）/","excerpt":"","text":"angular 的 uiRouter 的 方法$state.includes （判断当前激活路由）作用： 该方法用于判断当前激活的也就是地址栏的路由地址是哪个路由。 比如 $state.includes(‘app’) 那么如果页面地址为“www.baidu.com#/app” 或者 “www.baidu.com#/app/xxx” 的时候，该方法的值会返回true。（一般我们定义的路由和地址栏地址是相互对应的，方便管理。举例也是在app.xxx对应app/xxx这样设置路由的情况下） 如激活的路由为 app.page.page1 那么 123$state.includes(&apos;app&apos;) //返回 true$state.includes(&apos;app.page&apos;) //返回 true$state.includes(&apos;app.page.page1&apos;) //返回 true 用法： 知道了它的作用，接下来看看它的使用背景。 我们可以用来激活当前menu的状态。即使当前路由对应的菜单高亮或激活状态。 举例： 123456789101112131415161718192021&lt;div ng-init=&quot;menu_flag= !($state.includes(&apos;app.page1&apos;) || $state.includes(&apos;app.page2&apos;))&quot;&gt; 主菜单&lt;/div&gt;&lt;div ng-hide=&quot;menu_flag&quot;&gt; &lt;div ng-class=&quot;&#123;active: $state.includes(&apos;app.page1&apos;)&#125;&quot;&gt; &lt;a href=&quot;javascript:;&quot; ui-sref=&quot;app.page1&quot;&gt;子菜单一&lt;/a&gt; &lt;/div&gt; &lt;div ng-class=&quot;&#123;active: $state.includes(&apos;app.page2&apos;)&#125;&quot;&gt; &lt;a href=&quot;javascript:;&quot; ui-sref=&quot;app.page2&quot;&gt;子菜单二&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;// ...... n个类似结构组成的菜单&lt;div ng-init=&quot;menu_flag1= !($state.includes(&apos;app.page3&apos;) || $state.includes(&apos;app.page4&apos;))&quot;&gt; 主菜单&lt;/div&gt;&lt;div ng-hide=&quot;menu_flag1&quot;&gt; &lt;div ng-class=&quot;&#123;active: $state.includes(&apos;app.page3&apos;)&#125;&quot;&gt; &lt;a href=&quot;javascript:;&quot; ui-sref=&quot;app.page1&quot;&gt;子菜单一&lt;/a&gt; &lt;/div&gt; &lt;div ng-class=&quot;&#123;active: $state.includes(&apos;app.page4&apos;)&#125;&quot;&gt; &lt;a href=&quot;javascript:;&quot; ui-sref=&quot;app.page2&quot;&gt;子菜单二&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; 如上我们的菜单构成是由若干个类似结构构成，主menu控制若干个子menu。active是我们定义的激活菜单的css类名，当我们选中某个菜单时激活该菜单。即可借用$state.includes()来实现该功能。 同时，当我们的主menu要控制闭合和展开的话，当我们刷新的时候，我们通过判断($state.includes(&#39;app.page3&#39;) || $state.includes(&#39;app.page4&#39;)) 的值来在刷新之后判断该主菜单是否闭合。 当然我们也可以这样定义我们的路由。当然我们也可以这样定义我们的路由。例如： 一层菜单为 app.menu1 , 该主菜单下路由定义为 路由名称 一级路由定义 二级路由定义 一层菜单 app.menu1 二层菜单 app.menu1.menu1_1 二层菜单 app.menu1.menu1_2 这样的话我们在主菜单闭合上只需要判断 $state.includes(app.menu1) 即可。","categories":[],"tags":[]},{"title":"leetcode_2. 两数相加","slug":"leetcode_2. 两数相加","date":"2019-08-27T09:59:13.000Z","updated":"2019-08-27T09:54:35.520Z","comments":true,"path":"2019/08/27/leetcode_2. 两数相加/","link":"","permalink":"https://lunhui1994.github.io/2019/08/27/leetcode_2. 两数相加/","excerpt":"","text":"给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出：7 -&gt; 0 -&gt; 8 原因：342 + 465 = 807 题目解析： 该题给出两个链表，求出两个链表各个结点的和，那首先我们需要知道链表是什么样子。 1234567/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; */ 如上，链表的每个结点就是这个样子，next指向下一个结点，当然这是在js中简单的实现了链表。 然后知道了链表，那么就开始各位相加吧~，这个题唯一的难点就是在于各个结点相加的时候可能会产生进位。比如9+2=11，那么就需要进一位，本位取10的余数为值，然后我们就需要在下一个结点相加时把前两位可能产生的进位也算进去。 如下是我的js解答： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; l1 * @param &#123;ListNode&#125; l2 * @return &#123;ListNode&#125; * y 为进位值 * i 代表和的位 * n 代表了和的每一位的值 * arr 代表和（我们用数组表示更方便一点） */var addTwoNumbers = function(l1, l2) &#123; var arr = [], i = 0, n = 0, y = 0; //初始化 //因为链表不一定同样长的，所以只要有一个链表的结点不为空，我们都需要继续计算；同时我们也要考虑进位，即使两个链表结束了，如果有进位的话，那我们还是需要再计算一次的。 while (l1 !== null || l2 !== null || y !== 0) &#123; l1 = l1 ? l1 : new ListNode(0); //判断链表l1的该结点是否为null，如果为null初始化成值为0的结点，方便运算。 l2 = l2 ? l2 : new ListNode(0); // 同理 var num = l1.val + l2.val + y; // 计算该位的两个结点的和，同时要加上前两位的进位。 num &gt; 9 ? (y = 1, n = num - 10) : (n = num, y = 0); // 判断该位是否需要进位，需要进位的话就该位取10的余数，然后进一位（y = 1），反之初始化进位值为0。 arr[i] = n; //给和的每一位赋值 i++; //进入下一次循环 l1 = l1.next; // 进入l1下一个结点 l2 = l2.next; // 进入l2下一个结点 &#125; arr = arr.reverse(); //这里反转一下，原本是[7, 0, 8]反转为[8, 0, 7],方便后面生成链表。 let listNode = new ListNode(arr.shift()) //取第一个值创建第一个结点（是最终链表的最后一个结点） return arr.reduce((ori,cur)=&gt;&#123; let ln = new ListNode(cur) //生成当前结点 ln.next = ori //将当前结点的next指向之前生成的链表的第一个结点 return ln //返回新的链表（赋值给了 ori ） &#125;,listNode)// listNode是初始值。即链表末端的第一个值，我们之所以从最后一个开始创建链表也是因为方便。因为我们要操作结点的next，所以将新结点的next指向原来的链表，要比找到链表的最后一个结点的next指向新结点要方便一些。&#125;;","categories":[],"tags":[]},{"title":"ES6 对象数组查找某一个对象 findIndex","slug":"ES6 对象数组查找某一个对象 findIndex","date":"2019-08-27T09:50:34.000Z","updated":"2019-08-27T09:59:18.789Z","comments":true,"path":"2019/08/27/ES6 对象数组查找某一个对象 findIndex/","link":"","permalink":"https://lunhui1994.github.io/2019/08/27/ES6 对象数组查找某一个对象 findIndex/","excerpt":"","text":"查找数组特定元素需要用到的方法就是findIndex()。 用法与定义 findIndex() 方法返回传入一个测试条件（函数）符合条件的数组第一个元素位置。 findIndex() 方法为数组中的每个元素都调用一次函数执行： 当数组中的元素在测试条件时返回 true 时, findIndex() 返回符合条件的元素的索引位置，之后的值不会再调用 执行函数。如果没有符合条件的元素返回 -1 以上是比较官方的对于findIndex()的定义 接下来我结合实例来进行自己的解释. 第一条的意思如下:当条件函数返回true的时候，findindex会跳出，然后返回当前元素的下标。123456789101112131415161718192021222324252627282930//首先是普通数组var dataArr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];function fn(num, numIndex, nums)&#123; //该函数的三个参数，num代表当前项，numIndex代表当前项下标，nums代表该数组。 return num &gt; 5;&#125;dataArr.findIndex(fn);//值为5(即6的下标)------------------------分割线-----------------------------//同样的假如你的数组是个对象数组：var objArr = [&#123; name: &apos;小王&apos;, age: 14&#125;,&#123; name: &apos;大王&apos;, age: 41&#125;,&#123; name: &apos;老王&apos;, age: 61&#125;] function objFn(obj, objIndex, objs)&#123; return num.age &gt; 20;&#125;objArr .findIndex(objFn);//值为1(即大王的下标) 第二条的意思就更好理解了，因为findindex只返回第一个符合条件的元素下标，所以在找到第一个符合条件的元素之后，他会跳出该函数，之后的数组内的元素将不再调用，相当于加了个break； 实际用法举例 假如我们要在所有人里面挑选队友，但是不想重复。在我们通过id查找的时候，就可以这么写12345678910111213141516171819202122232425var allPeple = [&#123; name: &apos;小王&apos;, id: 14&#125;,&#123; name: &apos;大王&apos;, id: 41&#125;,&#123; name: &apos;老王&apos;, id: 61&#125;] var myTeamArr = [&#123; name: &apos;小王&apos;, id: 14&#125;] var PId = 14; //假如这个是要添加的人的IDfunction pFn(p)&#123;return p.id == PId ;&#125;//判断myteam里是不是有这个队员，如果==-1 代表没有，在allPeople中找到他，添加入我的队伍myTeamArr.findIndex(pFn) == -1 ? myTeamArr.push(allPeple.find(pFn)) : alert(&apos;已存在该人员&apos;);//这样写可以将两个for循环直接总结成一行代码 另外需要补充的一点 与其相对应的有find()函数，用法一致，只不过返回的是元素本身，而不是元素的下标。 兼容性 因为是es6的所以使用的时候要注意兼容性问题，ie11及之前的版本都不可兼容。","categories":[],"tags":[]},{"title":"v-model","slug":"v-model","date":"2019-08-27T08:59:13.000Z","updated":"2019-08-27T09:07:53.125Z","comments":true,"path":"2019/08/27/v-model/","link":"","permalink":"https://lunhui1994.github.io/2019/08/27/v-model/","excerpt":"","text":"最近学习vue，从最基础的文档看起。到目前基础已经看完。有两个问题很迷茫。 vue的动态参数（2.6新增）。demo一直报错。分析原因是因为vue不允许动态添加根一级的变量。（不理解） 组件中v-model的使用文档中说的让我有点绕。不过已经顺过来了，所以来分享一下。 官方给出的例子是这样。(可以直接使用)1234567891011121314HTML:&lt;custom-input v-model=&quot;searchText&quot;&gt;&lt;/custom-input&gt;JS:Vue.component(&apos;custom-input&apos;, &#123; props: [&apos;value&apos;], template: ` &lt;input v-bind:value=&quot;value&quot; v-on:input=&quot;$emit(&apos;input&apos;, $event.target.value)&quot; &gt; `&#125;) v-model可以改写为这种形式，两者完全等价。1234567&lt;input v-model=&quot;searchText&quot;&gt;等价于：&lt;input v-bind:value=&quot;searchText&quot; v-on:input=&quot;searchText = $event.target.value&quot;&gt; //（ $event.target.value为事件当前目标上的value值。） 第二种写法： 在input上绑定了input事件，通过触发input事件，执行给searchText赋值语句。 v-bind将searchText赋值给input标签的value属性。 再看官方的例子：1&lt;custom-input v-model=&quot;searchText&quot;&gt;&lt;/custom-input&gt; 等价于：1234&lt;custom-input v-bind:value=&quot;searchText&quot; v-on:input=&quot;searchText = $event&quot; //$event 为组件内部抛出来的值。（这个如果不明白可以看组件的自定义事件部分）&gt;&lt;/custom-input&gt; 再加上官方的js写法： 123456789Vue.component(&apos;custom-input&apos;, &#123; props: [&apos;value&apos;], template: ` &lt;input v-bind:value=&quot;value&quot; v-on:input=&quot;$emit(&apos;input&apos;, $event.target.value)&quot; &gt; `&#125;) 我们在组件内的input上监听了input事件，并且用该input事件对组件上的（自定义）input事件进行触发（searchText = $event”）； 将$ event.target.value作为参数传给 v-on:input=”searchText = $ event “，$ event === $ event.target.value。执行语句searchText被赋值。 组件上的v-bind:value = “searchText” 是将searchText的值绑定到组件内部的props里的value上。 组件内部将props中的value 绑定到input的value上。就这样完成了一次双向绑定。 而根据官方v-model的两种写法，组件上转换回v-modal的写法。就完成了。最终结果就如开头所示。","categories":[],"tags":[]},{"title":"完全背包问题","slug":"完全背包问题","date":"2019-04-30T07:10:03.000Z","updated":"2019-04-30T07:16:01.912Z","comments":true,"path":"2019/04/30/完全背包问题/","link":"","permalink":"https://lunhui1994.github.io/2019/04/30/完全背包问题/","excerpt":"","text":"题目描述 这里借用一个题目的描述来说明要解决问题的背景。 LiYuxiang是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同种类的草药，采每一种都需要一些时间，每一种也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。” 如果你是LiYuxiang，你能完成这个任务吗？ 此题和原题的不同点： 1.每种草药可以无限制地疯狂采摘。 2.药的种类眼花缭乱，采药时间好长好长啊！师傅等得菊花都谢了！ 一、 什么是背包算法背包算法的基础标准描述为：当前有N件商品，每件商品都有不同的价值v和重量w。我们要把这些商品放在容量为L的背包中，实现背包中的价值最大化。（第i件商品的价值为v[i]，重量为w[i])。上面的题目中的条件之一：草药无限（每件商品可以重复放入背包）即表明了该问题是完全背包问题。 二、 背包算法的应用背包算法在我看来是一种“性价比”算法。即我们在有限的条件下得到最大的收获。例如曾经有个节目可以让嘉宾在有限的时间内选购满满购物车的货品。这个场景及其符合背包算法。或者例如我们在考试的时侯，都会尽可能的选择简单并且分数又多的题先做。同时我们也可以应用到其他问题上去。比如在选择购买多种原材料时，尽可能的缩小原材料成本。投资时对多种投资产品的选择组合。 三、 背包算法的原理背包问题需要用到动态规划算法。当我们装一个商品的时侯需要判断几个条件： 该商品的重量和背包大小的关系。如果背包的总容量小于商品的重量，那就GG，根本不用考虑了。 商品的重量小于背包剩余容量。即背包中之前装入的商品不需要拿出来就可以把当前商品装下，那也不用考虑，直接装就好了。 商品的重量小于背包总容量，但是剩余空间不够装了。那我们就需要考虑衡量一下，拿出来原有的一部分商品，装入现在的商品是不是划算的。 从上面的三个条件可以看出最重要的就是第三条，我们需要判断价值。假设我们背包可以装8kg东西，现在有三个商品（商品都是以袋为单位销售不可拆分）： 苹果 香蕉 草莓 3kg 2kg 5kg ￥45 ￥20 ￥150 我们以1kg为单位打表:第一次打表 0kg 1kg 2kg 3kg 4kg 5kg 6kg 7kg 8kg 无 0 0 0 0 0 0 0 0 0 苹果 0 0 0 ￥45 ￥45 ￥45 ￥90 ￥90 ￥90 香蕉 0 0 0 0 0 0 0 0 0 草莓 0 0 0 0 0 0 0 0 0 第二次打表 0kg 1kg 2kg 3kg 4kg 5kg 6kg 7kg 8kg 无 0 0 0 0 0 0 0 0 0 苹果 0 0 0 ￥45 ￥45 ￥45 ￥90 ￥90 ￥90 香蕉 0 0 ￥20 ￥45 ￥45 ￥65 ￥90 ￥90 ￥110 草莓 0 0 0 0 0 0 0 0 0 最终打表结果： 0kg 1kg 2kg 3kg 4kg 5kg 6kg 7kg 8kg 无 0 0 0 0 0 0 0 0 0 苹果 0 0 0 ￥45 ￥45 ￥45 ￥90 ￥90 ￥90 香蕉 0 0 ￥20 ￥45 ￥45 ￥65 ￥90 ￥90 ￥110 草莓 0 0 ￥20 ￥45 ￥45 ￥150 ￥150 ￥170 ￥195 如表我们的最终排列结果。 核心判断为：bag[i-1][j] 和bag[i-1][j-k*w[i]] + k*v[i] 的价值哪个大。我来说明上面的变量都代表了什么： bag[i][j] 代表了我们在看到第i个商品时，背包容量占用了jkg时，背包内物品的价值。 那么bag[i-1][j] 就代表了我们在看到第i-1个商品时，背包容量占用了jkg时，背包内装的价值。 v[i]代表了当前商品的价值，k*v[i]代表了k个v[i]的价值（商品不限量）。 w[i]代表了当前商品的重量，k*w[i]代表了k个w[i]的重量。 bag[i-1][j-k*w[i]]就代表了上一个情况下，背包装了k个i商品时，余下空间在上一状态的最大价值。 所以，我们的核心判断种需要 上一个情况下的背包的所有状态。当我们把背包中 k*w[i]的空间腾出来用来装k个i商品，加上剩余空间可以装的商品的最大价值。如果它小于上一个状态下bag[i-1][j]所装货品的价值，那么我们就没必要替换这部分空间了。 12345678910//两个循环for (3) //3个商品 for (8) // 8种占用空间的情况（1kg-8kg）// 核心判断if (bag[i-1][j] &gt; bag[i-1][j-k*w[i]] + k*v[i]) &#123; bag[i][j] = bag[i-1][j];&#125; else &#123; bag[i][j] = bag[i-1][j-k*w[i]] + k*v[i];&#125; 其实回到生活上，我们的想法跟这个是一样的，当我们有个背包要装满的时侯，我们先看到了苹果，那么当然的，我们要尽可能多的把苹果装到包包里。如果有剩余空间装不下那也只能浪费着。然后我们发现了香蕉，我们会开始想着怎么用香蕉代替一部分苹果把空间填满。在这个思考的过程中，我们会一直比较什么样的组合价值最大。草莓也是一样。 其实如开头所说，我说这是“性价比”。上面我们商品出现的顺序是随机的。其实我们装东西判断价值，其实就是装性价比最高的物品。 不过同时需要考虑到空间的利用率。如果我们事先把性价比高的物品排在前面，那么效率会提高不少。","categories":[],"tags":[]}]}