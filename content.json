{"meta":{"title":"Eighteen Blog","subtitle":"Eighteen Blog","description":"好学力行，明德任责。一起分享芝士。","author":"赵十八","url":"http://www.zsfmyz.top","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-09-27T10:08:37.542Z","updated":"2019-09-27T10:08:37.543Z","comments":true,"path":"404.html","permalink":"http://www.zsfmyz.top/404.html","excerpt":"","text":"404 Not Found 很抱歉，您访问的页面不存在 QQ：562032497"},{"title":"About","date":"2019-08-27T09:38:13.000Z","updated":"2019-09-24T03:13:12.024Z","comments":true,"path":"about/index.html","permalink":"http://www.zsfmyz.top/about/index.html","excerpt":"","text":"好学力行，明德任责 目前正慢慢从CSDN迁移过来一些。 一个萝卜一个坑儿。 LH_ZSF 联系方式： email：zsfqfb@163.com QQ：562032497 微信："},{"title":"所有分类","date":"2019-08-28T08:31:41.001Z","updated":"2019-08-28T08:31:41.001Z","comments":true,"path":"categories/index.html","permalink":"http://www.zsfmyz.top/categories/index.html","excerpt":"","text":""},{"title":"Demo演示列表","date":"2019-08-27T09:38:13.000Z","updated":"2019-09-07T03:37:06.935Z","comments":true,"path":"demo/index.html","permalink":"http://www.zsfmyz.top/demo/index.html","excerpt":"","text":"Video截图功能实现 font-family字体对照表效果 局部马赛克效果"},{"title":"我的朋友们","date":"2019-08-28T08:33:59.476Z","updated":"2019-08-28T08:33:59.477Z","comments":true,"path":"friends/index.html","permalink":"http://www.zsfmyz.top/friends/index.html","excerpt":"","text":""},{"title":"","date":"2019-08-28T08:32:13.061Z","updated":"2019-08-28T08:32:13.061Z","comments":true,"path":"mylist/index.html","permalink":"http://www.zsfmyz.top/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-08-28T08:32:37.717Z","updated":"2019-08-28T08:32:37.719Z","comments":true,"path":"tags/index.html","permalink":"http://www.zsfmyz.top/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-09-27T02:11:51.830Z","updated":"2019-09-27T02:11:51.830Z","comments":true,"path":"demo/1/index.html","permalink":"http://www.zsfmyz.top/demo/1/index.html","excerpt":"","text":"Title Capture (function() { \"use strict\"; var video, $output; var scale = 0.25; var initialize = function() { $output = $(\"#output\"); video = $(\"#video\").get(0); $(\"#capture\").click(captureImage); }; var captureImage = function() { var canvas = document.createElement(\"canvas\"); canvas.width = video.videoWidth * scale; canvas.height = video.videoHeight * scale; canvas.getContext('2d') .drawImage(video, 0, 0, canvas.width, canvas.height); var img = document.createElement(\"img\"); img.src = canvas.toDataURL('image/png'); $output.prepend(img); }; $(initialize); }());"},{"title":"","date":"2019-09-27T02:13:40.367Z","updated":"2019-09-27T02:13:40.368Z","comments":true,"path":"demo/mosaic/index.html","permalink":"http://www.zsfmyz.top/demo/mosaic/index.html","excerpt":"","text":"Title #css_box { position: relative; touch-action: none; width: 100%; height: 500px; background: url('https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1567844929804&di=75928af77a3db7ff54cd4eab49361bc0&imgtype=0&src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fblog%2F201307%2F19%2F20130719082039_k2NHG.jpeg') no-repeat; background-size: contain; } #css_target { position: absolute; left: 0px; top: 0px; background: inherit; filter: blur(10px); touch-action: none; /* 继承父元素的background属性 */ } mosaic Demo 传送门 X: 0 px Y: 0 px var getCss = function(o, key) { return o.currentStyle ? o.currentStyle[key] : document.defaultView.getComputedStyle(o, false)[key]; }; // 拖拽 var startDrag = function(bar, target, callback) { var down = function(event) { // 兼容分辨率 bar.style.height = (parseInt(getCss(bar, \"width\")) * 636 / 900) + 'px'; target.style.backgroundSize = parseInt(getCss(bar, \"width\")) + 'px ' + (parseInt(getCss(bar, \"width\")) * 636 / 900) + 'px'; params.flag = true; if (!event) { event = window.event; bar.onselectstart = function() { return false; } } var e = event; params.currentX = e.clientX || e.changedTouches[0].clientX; params.currentY = e.clientY || e.changedTouches[0].clientY; }; var up = function() { params.flag = false; if (getCss(target, \"left\") !== \"auto\") { params.left = getCss(target, \"left\"); } if (getCss(target, \"top\") !== \"auto\") { params.top = getCss(target, \"top\"); } }; var move = function(event) { var e = event ? event : window.event; if (params.flag) { var nowX = e.clientX || e.changedTouches[0].clientX, nowY = e.clientY || e.changedTouches[0].clientY; var disX = nowX - params.currentX, disY = nowY - params.currentY; if ((parseInt(params.left) + disX) > maxX) { resX = maxX; } else if ((parseInt(params.left) + disX) < 0) { resX = 0; } else { resX = parseInt(params.left) + disX; } if ((parseInt(params.top) + disY) > maxY) { resY = maxY; } else if ((parseInt(params.top) + disY) < 0) { resY = 0; } else { resY = parseInt(params.top) + disY; } target.style.left = resX + 'px' target.style.top = resY + 'px' if (typeof callback == \"function\") { callback(resX, resY); } if (event.preventDefault) { event.preventDefault(); } return false; } } var resX = 0, resY = 0; var params = { left: 0, top: 0, currentX: 0, currentY: 0, flag: false }; if (getCss(target, \"left\") !== \"auto\") { params.left = getCss(target, \"left\"); } if (getCss(target, \"top\") !== \"auto\") { params.top = getCss(target, \"top\"); } if ((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) { console.log(\"mobile\"); target.style.width = '100px'; target.style.height = '100px'; maxX = parseInt(getCss(bar, \"width\")) - parseInt(getCss(target, \"width\")); maxY = parseInt(getCss(bar, \"height\")) - parseInt(getCss(target, \"height\")); target.ontouchstart = down document.ontouchend = up document.ontouchmove = move } else { console.log(\"pc\"); target.style.width = '150px'; target.style.height = '150px'; maxX = parseInt(getCss(bar, \"width\")) - parseInt(getCss(target, \"width\")); maxY = parseInt(getCss(bar, \"height\")) - parseInt(getCss(target, \"height\")); target.onmousedown = down document.onmouseup = up document.onmousemove = move } }; $(document).ready(function() { var bar = document.getElementById(\"css_box\"); var target = document.getElementById(\"css_target\"); var p_img = document.getElementById(\"position_img\"); // 兼容分辨率 bar.style.height = (parseInt(getCss(bar, \"width\")) * 636 / 900) + 'px'; target.style.backgroundSize = parseInt(getCss(bar, \"width\")) + 'px ' + (parseInt(getCss(bar, \"width\")) * 636 / 900) + 'px'; startDrag(bar, target, function(x, y) { target.style.backgroundPosition = (-1 * x) + \"px \" + (-1 * y) + \"px\"; p_img.innerText = \"X: \" + target.style.left + \" Y: \" + target.style.top; }); })"},{"title":"","date":"2019-10-23T06:02:50.659Z","updated":"2019-10-23T06:02:50.661Z","comments":true,"path":"demo/font/index.html","permalink":"http://www.zsfmyz.top/demo/font/index.html","excerpt":"","text":".demo { max-width: 600px; margin: 10px auto; font-family: sans-serif; } .table { width: 100%; line-height: 21px; table-layout: fixed; border-spacing: 0; border-collapse: collapse; border: 1px solid #ccc; font-size: 16px; } .table thead td, .table th { line-height: 20px; background-color: #f7f9fa; text-align: left; margin: 0; } .table tbody td { background-color: #fff; border-bottom: 1px solid #ededed; } .table td, .table th { padding: 14px 10px!important; } .table tr:last-child td { border-bottom: 0; } .table td p { display: inline-block; margin: 0 5px 0 0!important; } .red { color: red; } input:disabled, input:disabled+label { opacity: 0; } 字体中文名 字体英文名 字体应用 宋体 SimSun 中文名 英文名 浏览器默认 黑体 SimHei 中文名 英文名 浏览器默认 微软雅黑 Microsoft Yahei 中文名 英文名 浏览器默认 微软正黑体 Microsoft JhengHei 中文名 英文名 浏览器默认 楷体 KaiTi 中文名 英文名 浏览器默认 新宋体 NSimSun 中文名 英文名 浏览器默认 仿宋 FangSong 中文名 英文名 浏览器默认 字体中文名 字体英文名 字体应用 苹方 PingFang SC 中文名 英文名 浏览器默认 华文黑体 STHeiti 中文名 英文名 浏览器默认 华文楷体 STKaiti 中文名 英文名 浏览器默认 华文宋体 STSong 中文名 英文名 浏览器默认 华文仿宋 STFangsong 中文名 英文名 浏览器默认 华文中宋 STZhongsong 中文名 英文名 浏览器默认 华文琥珀 STHupo 中文名 英文名 浏览器默认 华文新魏 STXinwei 中文名 英文名 浏览器默认 华文隶书 STLiti 中文名 英文名 浏览器默认 华文行楷 STXingkai 中文名 英文名 浏览器默认 冬青黑体简 Hiragino Sans GB 中文名 英文名 浏览器默认 兰亭黑-简 Lantinghei SC 中文名 英文名 浏览器默认 翩翩体-简 Hanzipen SC 中文名 英文名 浏览器默认 手札体-简 Hannotate SC 中文名 英文名 浏览器默认 宋体-简 Songti SC 中文名 英文名 浏览器默认 娃娃体-简 Wawati SC 中文名 英文名 浏览器默认 魏碑-简 Weibei SC 中文名 英文名 浏览器默认 行楷-简 Xingkai SC 中文名 英文名 浏览器默认 雅痞-简 Yapi SC 中文名 英文名 浏览器默认 圆体-简 Yuanti SC 中文名 英文名 浏览器默认 字体中文名 字体英文名 字体应用 幼圆 YouYuan 中文名 英文名 浏览器默认 隶书 LiSu 中文名 英文名 浏览器默认 华文细黑 STXihei 中文名 英文名 浏览器默认 华文楷体 STKaiti 中文名 英文名 浏览器默认 华文宋体 STSong 中文名 英文名 浏览器默认 华文仿宋 STFangsong 中文名 英文名 浏览器默认 华文中宋 STZhongsong 中文名 英文名 浏览器默认 华文彩云 STCaiyun 中文名 英文名 浏览器默认 华文琥珀 STHupo 中文名 英文名 浏览器默认 华文新魏 STXinwei 中文名 英文名 浏览器默认 华文隶书 STLiti 中文名 英文名 浏览器默认 华文行楷 STXingkai 中文名 英文名 浏览器默认 方正舒体 FZShuTi 中文名 英文名 浏览器默认 方正姚体 FZYaoti 中文名 英文名 浏览器默认 字体中文名 字体英文名 字体应用 思源黑体 Source Han Sans CN 中文名 英文名 浏览器默认 思源宋体 Source Han Serif SC 中文名 英文名 浏览器默认 文泉驿微米黑 WenQuanYi Micro Hei 中文名 英文名 浏览器默认 字体中文名 字体英文名 字体应用 汉仪旗黑 HYQihei 40S 中文名 英文名 浏览器默认 汉仪旗黑 HYQihei 50S 中文名 英文名 浏览器默认 汉仪旗黑 HYQihei 60S 中文名 英文名 浏览器默认 汉仪大宋简 HYDaSongJ 中文名 英文名 浏览器默认 汉仪楷体 HYKaiti 中文名 英文名 浏览器默认 汉仪家书简 HYJiaShuJ 中文名 英文名 浏览器默认 汉仪PP体简 HYPPTiJ 中文名 英文名 浏览器默认 汉仪乐喵体简 HYLeMiaoTi 中文名 英文名 浏览器默认 汉仪小麦体 HYXiaoMaiTiJ 中文名 英文名 浏览器默认 汉仪程行体 HYChengXingJ 中文名 英文名 浏览器默认 汉仪黑荔枝 HYHeiLiZhiTiJ 中文名 英文名 浏览器默认 汉仪雅酷黑W HYYaKuHeiW 中文名 英文名 浏览器默认 汉仪大黑简 HYDaHeiJ 中文名 英文名 浏览器默认 汉仪尚魏手书W HYShangWeiShouShuW 中文名 英文名 浏览器默认 字体中文名 字体英文名 字体应用 方正粗雅宋简体 FZYaSongS-B-GB 中文名 英文名 浏览器默认 方正报宋简体 FZBaoSong-Z04S 中文名 英文名 浏览器默认 方正粗圆简体 FZCuYuan-M03S 中文名 英文名 浏览器默认 方正大标宋简体 FZDaBiaoSong-B06S 中文名 英文名 浏览器默认 方正大黑简体 FZDaHei-B02S 中文名 英文名 浏览器默认 方正仿宋简体 FZFangSong-Z02S 中文名 英文名 浏览器默认 方正黑体简体 FZHei-B01S 中文名 英文名 浏览器默认 方正琥珀简体 FZHuPo-M04S 中文名 英文名 浏览器默认 方正楷体简体 FZKai-Z03S 中文名 英文名 浏览器默认 方正隶变简体 FZLiBian-S02S 中文名 英文名 浏览器默认 方正隶书简体 FZLiShu-S01S 中文名 英文名 浏览器默认 方正美黑简体 FZMeiHei-M07S 中文名 英文名 浏览器默认 方正书宋简体 FZShuSong-Z01S 中文名 英文名 浏览器默认 方正舒体简体 FZShuTi-S05S 中文名 英文名 浏览器默认 方正水柱简体 FZShuiZhu-M08S 中文名 英文名 浏览器默认 方正宋黑简体 FZSongHei-B07S 中文名 英文名 浏览器默认 方正宋三简体 FZSong 中文名 英文名 浏览器默认 方正魏碑简体 FZWeiBei-S03S 中文名 英文名 浏览器默认 方正细等线简体 FZXiDengXian-Z06S 中文名 英文名 浏览器默认 方正细黑一简体 FZXiHei I-Z08S 中文名 英文名 浏览器默认 方正细圆简体 FZXiYuan-M01S 中文名 英文名 浏览器默认 方正小标宋简体 FZXiaoBiaoSong-B05S 中文名 英文名 浏览器默认 方正行楷简体 FZXingKai-S04S 中文名 英文名 浏览器默认 方正姚体简体 FZYaoTi-M06S 中文名 英文名 浏览器默认 方正中等线简体 FZZhongDengXian-Z07S 中文名 英文名 浏览器默认 方正准圆简体 FZZhunYuan-M02S 中文名 英文名 浏览器默认 方正综艺简体 FZZongYi-M05S 中文名 英文名 浏览器默认 方正彩云简体 FZCaiYun-M09S 中文名 英文名 浏览器默认 方正隶二简体 FZLiShu II-S06S 中文名 英文名 浏览器默认 方正康体简体 FZKangTi-S07S 中文名 英文名 浏览器默认 方正超粗黑简体 FZChaoCuHei-M10S 中文名 英文名 浏览器默认 方正新报宋简体 FZNew BaoSong-Z12S 中文名 英文名 浏览器默认 方正新舒体简体 FZNew ShuTi-S08S 中文名 英文名 浏览器默认 方正黄草简体 FZHuangCao-S09S 中文名 英文名 浏览器默认 方正少儿简体 FZShaoEr-M11S 中文名 英文名 浏览器默认 方正稚艺简体 FZZhiYi-M12S 中文名 英文名 浏览器默认 方正细珊瑚简体 FZXiShanHu-M13S 中文名 英文名 浏览器默认 方正粗宋简体 FZCuSong-B09S 中文名 英文名 浏览器默认 方正平和简体 FZPingHe-S11S 中文名 英文名 浏览器默认 方正华隶简体 FZHuaLi-M14S 中文名 英文名 浏览器默认 方正瘦金书简体 FZShouJinShu-S10S 中文名 英文名 浏览器默认 方正细倩简体 FZXiQian-M15S 中文名 英文名 浏览器默认 方正中倩简体 FZZhongQian-M16S 中文名 英文名 浏览器默认 方正粗倩简体 FZCuQian-M17S 中文名 英文名 浏览器默认 方正胖娃简体 FZPangWa-M18S 中文名 英文名 浏览器默认 方正宋一简体 FZSongYi-Z13S 中文名 英文名 浏览器默认 方正剪纸简体 FZJianZhi-M23S 中文名 英文名 浏览器默认 方正流行体简体 FZLiuXingTi-M26S 中文名 英文名 浏览器默认 方正祥隶简体 FZXiangLi-S17S 中文名 英文名 浏览器默认 方正粗活意简体 FZCuHuoYi-M25S 中文名 英文名 浏览器默认 方正胖头鱼简体 FZPangTouYu-M24S 中文名 英文名 浏览器默认 方正卡通简体 FZKaTong-M19S 中文名 英文名 浏览器默认 方正艺黑简体 FZYiHei-M20S 中文名 英文名 浏览器默认 方正水黑简体 FZShuiHei-M21S 中文名 英文名 浏览器默认 方正古隶简体 FZGuLi-S12S 中文名 英文名 浏览器默认 方正幼线简体 FZYouXian-Z09S 中文名 英文名 浏览器默认 方正启体简体 FZQiTi-S14S 中文名 英文名 浏览器默认 方正小篆体 FZXiaoZhuanTi-S13T 中文名 英文名 浏览器默认 方正硬笔楷书简体 FZYingBiKaiShu-S15S 中文名 英文名 浏览器默认 方正毡笔黑简体 FZZhanBiHei-M22S 中文名 英文名 浏览器默认 方正硬笔行书简体 FZYingBiXingShu-S16S 中文名 英文名 浏览器默认 var dataFont = { windows: [{ ch: '宋体', en: 'SimSun' }, { ch: '黑体', en: 'SimHei' }, { ch: '微软雅黑', en: 'Microsoft Yahei' }, { ch: '微软正黑体', en: 'Microsoft JhengHei' }, { ch: '楷体', en: 'KaiTi' }, { ch: '新宋体', en: 'NSimSun' }, { ch: '仿宋', en: 'FangSong' }], 'OS X': [{ ch: '苹方', en: 'PingFang SC' }, { ch: '华文黑体', en: 'STHeiti' }, { ch: '华文楷体', en: 'STKaiti' }, { ch: '华文宋体', en: 'STSong' }, { ch: '华文仿宋', en: 'STFangsong' }, { ch: '华文中宋', en: 'STZhongsong' }, { ch: '华文琥珀', en: 'STHupo' }, { ch: '华文新魏', en: 'STXinwei' }, { ch: '华文隶书', en: 'STLiti' }, { ch: '华文行楷', en: 'STXingkai' }, { ch: '冬青黑体简', en: 'Hiragino Sans GB' }, { ch: '兰亭黑-简', en: 'Lantinghei SC' }, { ch: '翩翩体-简', en: 'Hanzipen SC' }, { ch: '手札体-简', en: 'Hannotate SC' }, { ch: '宋体-简', en: 'Songti SC' }, { ch: '娃娃体-简', en: 'Wawati SC' }, { ch: '魏碑-简', en: 'Weibei SC' }, { ch: '行楷-简', en: 'Xingkai SC' }, { ch: '雅痞-简', en: 'Yapi SC' }, { ch: '圆体-简', en: 'Yuanti SC' }], 'office': [{ ch: '幼圆', en: 'YouYuan' }, { ch: '隶书', en: 'LiSu' }, { ch: '华文细黑', en: 'STXihei' }, { ch: '华文楷体', en: 'STKaiti' }, { ch: '华文宋体', en: 'STSong' }, { ch: '华文仿宋', en: 'STFangsong' }, { ch: '华文中宋', en: 'STZhongsong' }, { ch: '华文彩云', en: 'STCaiyun' }, { ch: '华文琥珀', en: 'STHupo' }, { ch: '华文新魏', en: 'STXinwei' }, { ch: '华文隶书', en: 'STLiti' }, { ch: '华文行楷', en: 'STXingkai' }, { ch: '方正舒体', en: 'FZShuTi' }, { ch: '方正姚体', en: 'FZYaoti' }], 'open': [{ ch: '思源黑体', en: 'Source Han Sans CN' }, { ch: '思源宋体', en: 'Source Han Serif SC' }, { ch: '文泉驿微米黑', en: 'WenQuanYi Micro Hei' }], 'hanyi': [{ ch: '汉仪旗黑', en: 'HYQihei 40S' }, { ch: '汉仪旗黑', en: 'HYQihei 50S' }, { ch: '汉仪旗黑', en: 'HYQihei 60S' }, { ch: '汉仪大宋简', en: 'HYDaSongJ' }, { ch: '汉仪楷体', en: 'HYKaiti' }, { ch: '汉仪家书简', en: 'HYJiaShuJ' }, { ch: '汉仪PP体简', en: 'HYPPTiJ' }, { ch: '汉仪乐喵体简', en: 'HYLeMiaoTi' }, { ch: '汉仪小麦体', en: 'HYXiaoMaiTiJ' }, { ch: '汉仪程行体', en: 'HYChengXingJ' }, { ch: '汉仪黑荔枝', en: 'HYHeiLiZhiTiJ' }, { ch: '汉仪雅酷黑W', en: 'HYYaKuHeiW' }, { ch: '汉仪大黑简', en: 'HYDaHeiJ' }, { ch: '汉仪尚魏手书W', en: 'HYShangWeiShouShuW' }], 'fangzheng': [{ \"ch\": \"方正粗雅宋简体\", \"en\": \"FZYaSongS-B-GB\" }, { \"ch\": \"方正报宋简体\", \"en\": \"FZBaoSong-Z04S\" }, { \"ch\": \"方正粗圆简体\", \"en\": \"FZCuYuan-M03S\" }, { \"ch\": \"方正大标宋简体\", \"en\": \"FZDaBiaoSong-B06S\" }, { \"ch\": \"方正大黑简体\", \"en\": \"FZDaHei-B02S\" }, { \"ch\": \"方正仿宋简体\", \"en\": \"FZFangSong-Z02S\" }, { \"ch\": \"方正黑体简体\", \"en\": \"FZHei-B01S\" }, { \"ch\": \"方正琥珀简体\", \"en\": \"FZHuPo-M04S\" }, { \"ch\": \"方正楷体简体\", \"en\": \"FZKai-Z03S\" }, { \"ch\": \"方正隶变简体\", \"en\": \"FZLiBian-S02S\" }, { \"ch\": \"方正隶书简体\", \"en\": \"FZLiShu-S01S\" }, { \"ch\": \"方正美黑简体\", \"en\": \"FZMeiHei-M07S\" }, { \"ch\": \"方正书宋简体\", \"en\": \"FZShuSong-Z01S\" }, { \"ch\": \"方正舒体简体\", \"en\": \"FZShuTi-S05S\" }, { \"ch\": \"方正水柱简体\", \"en\": \"FZShuiZhu-M08S\" }, { \"ch\": \"方正宋黑简体\", \"en\": \"FZSongHei-B07S\" }, { \"ch\": \"方正宋三简体\", \"en\": \"FZSong\" }, { \"ch\": \"方正魏碑简体\", \"en\": \"FZWeiBei-S03S\" }, { \"ch\": \"方正细等线简体\", \"en\": \"FZXiDengXian-Z06S\" }, { \"ch\": \"方正细黑一简体\", \"en\": \"FZXiHei I-Z08S\" }, { \"ch\": \"方正细圆简体\", \"en\": \"FZXiYuan-M01S\" }, { \"ch\": \"方正小标宋简体\", \"en\": \"FZXiaoBiaoSong-B05S\" }, { \"ch\": \"方正行楷简体\", \"en\": \"FZXingKai-S04S\" }, { \"ch\": \"方正姚体简体\", \"en\": \"FZYaoTi-M06S\" }, { \"ch\": \"方正中等线简体\", \"en\": \"FZZhongDengXian-Z07S\" }, { \"ch\": \"方正准圆简体\", \"en\": \"FZZhunYuan-M02S\" }, { \"ch\": \"方正综艺简体\", \"en\": \"FZZongYi-M05S\" }, { \"ch\": \"方正彩云简体\", \"en\": \"FZCaiYun-M09S\" }, { \"ch\": \"方正隶二简体\", \"en\": \"FZLiShu II-S06S\" }, { \"ch\": \"方正康体简体\", \"en\": \"FZKangTi-S07S\" }, { \"ch\": \"方正超粗黑简体\", \"en\": \"FZChaoCuHei-M10S\" }, { \"ch\": \"方正新报宋简体\", \"en\": \"FZNew BaoSong-Z12S\" }, { \"ch\": \"方正新舒体简体\", \"en\": \"FZNew ShuTi-S08S\" }, { \"ch\": \"方正黄草简体\", \"en\": \"FZHuangCao-S09S\" }, { \"ch\": \"方正少儿简体\", \"en\": \"FZShaoEr-M11S\" }, { \"ch\": \"方正稚艺简体\", \"en\": \"FZZhiYi-M12S\" }, { \"ch\": \"方正细珊瑚简体\", \"en\": \"FZXiShanHu-M13S\" }, { \"ch\": \"方正粗宋简体\", \"en\": \"FZCuSong-B09S\" }, { \"ch\": \"方正平和简体\", \"en\": \"FZPingHe-S11S\" }, { \"ch\": \"方正华隶简体\", \"en\": \"FZHuaLi-M14S\" }, { \"ch\": \"方正瘦金书简体\", \"en\": \"FZShouJinShu-S10S\" }, { \"ch\": \"方正细倩简体\", \"en\": \"FZXiQian-M15S\" }, { \"ch\": \"方正中倩简体\", \"en\": \"FZZhongQian-M16S\" }, { \"ch\": \"方正粗倩简体\", \"en\": \"FZCuQian-M17S\" }, { \"ch\": \"方正胖娃简体\", \"en\": \"FZPangWa-M18S\" }, { \"ch\": \"方正宋一简体\", \"en\": \"FZSongYi-Z13S\" }, { \"ch\": \"方正剪纸简体\", \"en\": \"FZJianZhi-M23S\" }, { \"ch\": \"方正流行体简体\", \"en\": \"FZLiuXingTi-M26S\" }, { \"ch\": \"方正祥隶简体\", \"en\": \"FZXiangLi-S17S\" }, { \"ch\": \"方正粗活意简体\", \"en\": \"FZCuHuoYi-M25S\" }, { \"ch\": \"方正胖头鱼简体\", \"en\": \"FZPangTouYu-M24S\" }, /*{\"ch\":\"方正铁筋隶书简体\",\"en\":\"FZTieJinLiShu-Z14S\"},{\"ch\":\"方正北魏楷书简体\",\"en\":\"FZBeiWeiKaiShu-Z15S\"},*/ { \"ch\": \"方正卡通简体\", \"en\": \"FZKaTong-M19S\" }, { \"ch\": \"方正艺黑简体\", \"en\": \"FZYiHei-M20S\" }, { \"ch\": \"方正水黑简体\", \"en\": \"FZShuiHei-M21S\" }, { \"ch\": \"方正古隶简体\", \"en\": \"FZGuLi-S12S\" }, { \"ch\": \"方正幼线简体\", \"en\": \"FZYouXian-Z09S\" }, { \"ch\": \"方正启体简体\", \"en\": \"FZQiTi-S14S\" }, { \"ch\": \"方正小篆体\", \"en\": \"FZXiaoZhuanTi-S13T\" }, { \"ch\": \"方正硬笔楷书简体\", \"en\": \"FZYingBiKaiShu-S15S\" }, { \"ch\": \"方正毡笔黑简体\", \"en\": \"FZZhanBiHei-M22S\" }, { \"ch\": \"方正硬笔行书简体\", \"en\": \"FZYingBiXingShu-S16S\" }] }; // 系统默认字体 var rootFontFamily = (document.documentElement.currentStyle ? document.documentElement.currentStyle : window.getComputedStyle(document.documentElement)).fontFamily; var eleTables = document.getElementsByTagName('table'); var lenTables = eleTables.length; for (var index = 0; index < lenTables; index++) { var typeFont = eleTables[index].getAttribute('data-type'); var arrDataFont = dataFont[typeFont]; if (arrDataFont && arrDataFont.length) { var html = ''; for (var start = 0; start < arrDataFont.length; start++) { var name = typeFont + start; var fontEn = arrDataFont[start].en, fontCh = arrDataFont[start].ch; // 是否标记为默认字体的处理 var htmlFontEn = fontEn, htmlFontCh = fontCh; if (fontEn.toLowerCase() === rootFontFamily.toLowerCase()) { htmlFontEn += '（浏览器默认）'; } else if (fontCh.toLowerCase() === rootFontFamily.toLowerCase()) { htmlFontCh += '（浏览器默认）'; } html = html + '' + htmlFontCh + '' + htmlFontEn + '' + '中文名' + '英文名' + '浏览器默认' + ''; } eleTables[index].getElementsByTagName('tbody')[0].innerHTML = html; // 复选框事件 eleTables[index].onclick = function(event) { event = event || window.event; var target = event.target; if (target && target.type == 'radio') { target.parentNode.parentNode.parentNode.style.fontFamily = target.value; } }; } } // JavaScript Document"}],"posts":[{"title":"Leetcode_145. 二叉树的后序遍历","slug":"leetcode_145. 二叉树的后序遍历","date":"2019-11-17T03:59:13.000Z","updated":"2019-11-20T10:07:14.865Z","comments":true,"path":"Algorithm/每日一题/leetcode_145. 二叉树的后序遍历/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/leetcode_145. 二叉树的后序遍历/","excerpt":"题目解析：给定一个二叉树，返回它的 后序 遍历。 示例示例 1:12345678输入: [1,null,2,3] 1 \\ 2 / 3 输出: [3,2,1] 说明&amp;&amp;进阶:1234 递归算法很简单，你可以通过迭代算法完成吗？前序排列的顺序是左，右，父。","text":"题目解析：给定一个二叉树，返回它的 后序 遍历。 示例示例 1:12345678输入: [1,null,2,3] 1 \\ 2 / 3 输出: [3,2,1] 说明&amp;&amp;进阶:1234 递归算法很简单，你可以通过迭代算法完成吗？前序排列的顺序是左，右，父。 解题思路递归，递归判断条件，该节点左右节点是否为null，递归时先左后右。 跟前序遍历唯一的差别是最后再push。 解答12345678910111213141516171819202122232425/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */ let postorderArr = []; let addNode = (root) =&gt; &#123; root.left &amp;&amp; addNode(root.left); root.right &amp;&amp; addNode(root.right); postorderArr.push(root.val) // 唯一的差别 &#125; let postorderTraversal = (root) =&gt; &#123; postorderArr = []; if (!root) &#123; return postorderArr; &#125; addNode(root); return postorderArr; &#125;; 解题思路二 迭代法，基于栈的特性将递推出来的节点压进栈中。然后遵循先进后出的原则，直至将栈排空。 后序遍历的迭代法比较前序遍历要复杂一些。 我的思路是打表，已经遍历过的节点需要标记（截断）。 解答二12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */let postorderArr = [], nodeList = [], nowNode;let postorderTraversal = (root) =&gt; &#123; postorderArr = []; if (!root) &#123; return postorderArr; &#125; nodeList = [], nowNode = root; while(nodeList.length &gt; 0 || nowNode) &#123; while (nowNode) &#123; nowNode.flag = true; // 标记该节点已经进入过数组 nodeList.push(nowNode); //如果该节点的左节点已经遍历过了就不需要遍历了 先左 if (nowNode.left &amp;&amp; !nowNode.left.flag) &#123; nowNode = nowNode.left; //如果该节点的右节点已经遍历过了就不需要遍历了 后右 &#125; else if (nowNode.right &amp;&amp; !nowNode.right.flag) &#123; nowNode = nowNode.right; &#125; else &#123; //左右节点都遍历过的相当于叶节点（度为0，没有子节点） nowNode = null; &#125; &#125; // 从栈中取值 nowNode = nodeList.pop(); // 用来区分是否为叶节点 若为叶则赋值null，遍历下一轮。 if (!nowNode.right || nowNode.right.flag) &#123; postorderArr.push(nowNode.val); nowNode = null; &#125; &#125; return postorderArr;&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"Leetcode_144. 二叉树的前序遍历","slug":"leetcode_144. 二叉树的前序遍历","date":"2019-10-17T03:59:13.000Z","updated":"2019-10-17T10:08:30.354Z","comments":true,"path":"Algorithm/每日一题/leetcode_144. 二叉树的前序遍历/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/leetcode_144. 二叉树的前序遍历/","excerpt":"题目解析：给定一个二叉树，返回它的 前序 遍历。 示例示例 1:12345678输入: [1,null,2,3] 1 \\ 2 / 3 输出: [1,2,3] 说明&amp;&amp;进阶:1234 递归算法很简单，你可以通过迭代算法完成吗？前序排列的顺序是父节点在前，然后遍历左树，然后遍历右树。","text":"题目解析：给定一个二叉树，返回它的 前序 遍历。 示例示例 1:12345678输入: [1,null,2,3] 1 \\ 2 / 3 输出: [1,2,3] 说明&amp;&amp;进阶:1234 递归算法很简单，你可以通过迭代算法完成吗？前序排列的顺序是父节点在前，然后遍历左树，然后遍历右树。 解题思路递归，递归判断条件，该节点左右节点是否为null，递归时先左后右。 解答12345678910111213141516171819202122232425/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */let frontArr = [];let addNode = (root) =&gt; &#123; frontArr.push(root.val) root.left &amp;&amp; addNode(root.left); root.right &amp;&amp; addNode(root.right);&#125;let preorderTraversal = (root) =&gt; &#123; frontArr = []; if (!root) &#123; return frontArr; &#125; addNode(root); return frontArr;&#125;; 解题思路二 迭代法，基于栈的特性将递推出来的节点压进栈中。然后遵循先进后出的原则，直至将栈排空。 解答二123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */let frontArr = [], nodeList = [], nowNode;let preorderTraversal = (root) =&gt; &#123; frontArr = []; if (!root) &#123; return frontArr; &#125; nodeList = [root]; while(nodeList.length &gt; 0) &#123; nowNode = nodeList.pop(); frontArr.push(nowNode.val); nowNode.right &amp;&amp; nodeList.push(nowNode.right); nowNode.left &amp;&amp; nodeList.push(nowNode.left); &#125; return frontArr;&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"Leetcode_94. 二叉树的中序遍历","slug":"leetcode_94. 二叉树的中序遍历","date":"2019-10-17T03:59:13.000Z","updated":"2019-11-20T10:18:04.324Z","comments":true,"path":"Algorithm/每日一题/leetcode_94. 二叉树的中序遍历/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/leetcode_94. 二叉树的中序遍历/","excerpt":"题目解析：给定一个二叉树，返回它的 中序 遍历。 示例示例 1:12345678输入: [1,null,2,3] 1 \\ 2 / 3 输出: [1,3,2] 说明&amp;&amp;进阶:1234 递归算法很简单，你可以通过迭代算法完成吗？前序排列的顺序是左，父，右。","text":"题目解析：给定一个二叉树，返回它的 中序 遍历。 示例示例 1:12345678输入: [1,null,2,3] 1 \\ 2 / 3 输出: [1,3,2] 说明&amp;&amp;进阶:1234 递归算法很简单，你可以通过迭代算法完成吗？前序排列的顺序是左，父，右。 解题思路递归，递归判断条件，该节点左右节点是否为null，递归时先左后右。 解答12345678910111213141516171819202122232425/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */var addNode = function (root) &#123; root.left &amp;&amp; addNode(root.left); inorderArr.push(root.val); // 前，中序遍历唯一区别 root.right &amp;&amp; addNode(root.right);&#125;let inorderArr = [];var inorderTraversal = function(root) &#123; inorderArr = []; if (!root) &#123; return inorderArr; &#125; addNode(root); return inorderArr&#125;; 解题思路二 迭代法，基于栈的特性将递推出来的节点压进栈中。然后遵循先进后出的原则，直至将栈排空。 解答二123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */let inorderArr = [], nodeList = [], nowNode;var inorderTraversal = function(root) &#123; inorderArr = [], nodeList = [], nowNode = root; if (!root) &#123; return inorderArr; &#125; while(nodeList.length &gt; 0 || nowNode) &#123; while (nowNode) &#123; nodeList.push(nowNode); nowNode = nowNode.left; &#125; nowNode = nodeList.pop(); inorderArr.push(nowNode.val); nowNode = nowNode.right; &#125; return inorderArr&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"Leetcode_264. 丑数 II","slug":"leetcode_264. 丑数 II","date":"2019-10-12T03:59:13.000Z","updated":"2019-10-12T02:43:59.379Z","comments":true,"path":"Algorithm/每日一题/leetcode_264. 丑数 II/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/leetcode_264. 丑数 II/","excerpt":"题目解析：编写一个程序，找出第 n 个丑数。 丑数就是只包含质因数 2, 3, 5 的正整数。 示例示例 1:123输入: n = 10输出: 12解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 提示：121 是丑数。n 不超过1690。","text":"题目解析：编写一个程序，找出第 n 个丑数。 丑数就是只包含质因数 2, 3, 5 的正整数。 示例示例 1:123输入: n = 10输出: 12解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 提示：121 是丑数。n 不超过1690。 解题思路方法一暴力循环（毫无疑问超时了） 解答12345678910111213141516171819202122232425var isUgly = function(num) &#123; if (num &lt; 1) &#123; return false; &#125; while(num % 2 == 0) &#123; num/=2 &#125; while(num % 3 == 0) &#123; num/=3 &#125; while(num % 5 == 0) &#123; num/=5 &#125; return (num == 1) ? true : false;&#125;; var nthUglyNumber = function(n) &#123; var ugly = 1; for (var i = 0; i &lt; n; ugly++) &#123; if (isUgly(ugly)) &#123; i++; &#125; &#125; return ugly;&#125;; 解题思路二1. 根据题目的意思，我们首先知道丑数的因子只能是(2, 3, 5). 当我们要从[1],推算出[1,2,3,4,5,6,8,9...]丑数序列时,过程如下 var arr = [1]; 推算第二个数：比较arr[0]*2 和 arr[0]*3 和arr[0]*5 中取最小的一个arr[0]*2 放进数组中： [1, arr[0]*2]。 依次类推下次比较：arr[1]*2 和 arr[0]*3 和 arr[0]*5 中取最小arr[0]*3 放进数组中： [1, arr[0]*2, arr[0]*3] 依次类推下次比较：arr[1]*2 和 arr[1]*3 和 arr[0]*5 中取最小arr[1]*2 放进数组中： [1, arr[0]*2, arr[0]*3, arr[1]*2] 等等。。 2. 由上可以看出，我们需要丑数组arr, 还有2,3,5三个质因数分别乘到了arr的第几个数。 拿2作例子：我们需要知道数组的前多少个已经乘过2了。当arr[0]*2 之后， 下次就该arr[1]*2跟其他的作比较了。 即这2，3，5需要三个标记。在上面举例中第三次之后的下标为：[2, 1, 0]. 即下次比较应该用arr[2]*2 和 arr[1]*3 和arr[0]*5 来比较哪个小。 3. 中间会遇到比如 arr[2]*2 == arr[1]*3 这样的情况。 此时把2，3 的下标都+1即可. 最后依次求到目标数组arr的第n个数即为答案。 解答二1234567891011121314151617181920var nthUglyNumber = function(n) &#123; var arr = [1], indexArr = [0, 0, 0],v2,v3,v5,temp; for(var i = 0; i &lt;= n; i++) &#123; v2 = arr[indexArr[0]] * 2; v3 = arr[indexArr[1]] * 3; v5 = arr[indexArr[2]] * 5; temp = Math.min(v2,Math.min(v3,v5)); // 判断最小 if (temp == v2) &#123; indexArr[0]++; &#125; if (temp == v3) &#123; indexArr[1]++; &#125; if (temp == v5) &#123; indexArr[2]++; &#125; arr.push(temp); &#125; return arr[n-1];&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"Leetcode_26. 删除排序数组中的重复项","slug":"leetcode_26. 删除排序数组中的重复项","date":"2019-09-27T03:59:13.000Z","updated":"2019-09-27T07:12:55.017Z","comments":true,"path":"Algorithm/每日一题/leetcode_26. 删除排序数组中的重复项/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/leetcode_26. 删除排序数组中的重复项/","excerpt":"题目解析：给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例示例 1:12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2:12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 提示： 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125;","text":"题目解析：给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例示例 1:12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2:12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 提示： 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解题思路题目中原地的意思大概就是要在原数组中操作不能开辟新的数组空间。 题目简单，就是去除数组中的重复元素。 首先想到的是删除数组中的重复元素，用到了splice。 解答123456789var removeDuplicates = function(nums) &#123; for (var i = 0; i &lt; nums.length; i++) &#123; if (nums.includes(nums[i], i + 1)) &#123; nums.splice(i, 1); i--; &#125; &#125; return nums.length;&#125;; 解题思路二由于第一种方法用到了splice，所以其实时空间复杂度还是比较高的。 所以，根据题目要求我们其实只需要保证数组的前面排列的是我们需要的就可以了。超过的部分我可以忽略不计。 那其实就是依次从头填充数组就可以了！直到遍历完数组的最后一位。 双指针就解决了。一个用来遍历数组，一个用来从头修改数组。 由于题目告诉为排序数组，所以我们可以用i，i+1判断。 解答二12345678910var removeDuplicates = function(nums) &#123; var next = 0; for (var i = 0; i &lt; nums.length; i++) &#123; if (nums[i] != nums[i+1]) &#123; nums[next] = nums[i]; next++; &#125; &#125; return next;&#125;; 解题思路三了解一下ES6的array.includes(searchEle, fromIndex); 判断数组种是否含有searchEle。(true / false); searchEle为搜索的元素（必填），fromIndex为从数组的哪一位开始搜索。 使用includes同时可以判断非排序的数组 解答三12345678910var removeDuplicates = function(nums) &#123; var j = 0; for (var i = 0; i &lt; nums.length; i++) &#123; if (!nums.includes(nums[i], i + 1)) &#123; nums[j] = nums[i]; j++; &#125; &#125; return j;&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"Leetcode_5198. 丑数 III","slug":"leetcode_5198. 丑数 III","date":"2019-09-26T03:59:13.000Z","updated":"2019-09-27T02:05:07.686Z","comments":true,"path":"Algorithm/每日一题/leetcode_5198. 丑数 III/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/leetcode_5198. 丑数 III/","excerpt":"题目解析：请你帮忙设计一个程序，用来找出第 n 个丑数。 丑数是可以被 a 或 b 或 c 整除的 正整数。 示例示例 1:123输入：n = 3, a = 2, b = 3, c = 5输出：4解释：丑数序列为 2, 3, 4, 5, 6, 8, 9, 10... 其中第 3 个是 4。 示例 2:123输入：n = 4, a = 2, b = 3, c = 4输出：6解释：丑数序列为 2, 3, 4, 6, 8, 9, 12... 其中第 4 个是 6。 示例 3:123输入：n = 5, a = 2, b = 11, c = 13输出：10解释：丑数序列为 2, 4, 6, 8, 10, 11, 12, 13... 其中第 5 个是 10。 示例 4:12输入：n = 1000000000, a = 2, b = 217983653, c = 336916467输出：1999999984 提示：1231 &lt;= n, a, b, c &lt;= 10^91 &lt;= a * b * c &lt;= 10^18本题结果在 [1, 2 * 10^9] 的范围内","text":"题目解析：请你帮忙设计一个程序，用来找出第 n 个丑数。 丑数是可以被 a 或 b 或 c 整除的 正整数。 示例示例 1:123输入：n = 3, a = 2, b = 3, c = 5输出：4解释：丑数序列为 2, 3, 4, 5, 6, 8, 9, 10... 其中第 3 个是 4。 示例 2:123输入：n = 4, a = 2, b = 3, c = 4输出：6解释：丑数序列为 2, 3, 4, 6, 8, 9, 12... 其中第 4 个是 6。 示例 3:123输入：n = 5, a = 2, b = 11, c = 13输出：10解释：丑数序列为 2, 4, 6, 8, 10, 11, 12, 13... 其中第 5 个是 10。 示例 4:12输入：n = 1000000000, a = 2, b = 217983653, c = 336916467输出：1999999984 提示：1231 &lt;= n, a, b, c &lt;= 10^91 &lt;= a * b * c &lt;= 10^18本题结果在 [1, 2 * 10^9] 的范围内 解题思路方法一暴力循环（毫无疑问超时了） 解答123456789 var nthUglyNumber = function(n, a, b, c) &#123; var num = 1; for (var i = 1; i &lt;= n; num++) &#123; if (num % a == 0 || num % b == 0 || num % c == 0) &#123; i++; &#125; &#125; return num - 1;&#125;; 解题思路二1.找出该数可能存在的范围，首先可以思考判断得出最小的值为n ，最大为min(a,b,c) * n 2.假设最终结果为finalValue，求出该值的序列长度nums。 例如：下面的例子中finalValue为6，而其序列就为[2, 3, 4, 6],长度为4===n。 123输入：n = 4, a = 2, b = 3, c = 4输出：6解释：丑数序列为 2, 3, 4, 6, 8, 9, 12... 其中第 4 个是 6。 3.通过二分法查找finalValue 4.判断条件为: nums.length === n ? ，如果相等即为该值。 ** 注意：finalValue必须符合是a，b，c的倍数，且是所有符合条件的值中最小的一个。 ** 解答二123456789101112131415161718192021222324252627282930313233343536373839//最大公约数 ：a和 a%b 的最大公约数 和 a 和 b 的最大公约数一致var maxComFn = function(a, b) &#123; if (a % b === 0) &#123; return b; &#125; else &#123; return maxComFn(b, a % b); &#125;&#125;//最小公倍数 公式法： a*b === a和b的最大公约数 * a和b的最小公倍数var minComFn = function(a, b) &#123; var maxC = maxComFn(a, b) return a * b / maxC;&#125;//值的序列长度 容斥定理， 含有a，b，c的个数 - ab，ac，bc的公倍数的个数 + abc公倍数的个数var inNumsFn = function(a, b, c, num) &#123; return Math.floor(num / a) + Math.floor(num / b) + Math.floor(num / c) - Math.floor(num / minComFn(a, b)) - Math.floor(num / minComFn(a, c)) - Math.floor(num / minComFn(c, b)) + Math.floor(num / minComFn(c, minComFn(a, b)));&#125;var nthUglyNumber = function(n, a, b, c) &#123; var maxCom = maxComFn(a, maxComFn(b, c)); let mid, left = n, right = n * Math.min(a, b, c); while (left &lt; right) &#123; mid = Math.floor((left + right) / 2); if (inNumsFn(a, b, c, mid) &lt; n) &#123; left = mid + 1; &#125; else &#123; right = mid; //一直求到最小。 &#125; &#125; return right;&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"Leetcode_1189. “气球” 的最大数量","slug":"leetcode_1189. “气球” 的最大数量","date":"2019-09-25T03:59:13.000Z","updated":"2019-09-25T07:45:45.639Z","comments":true,"path":"Algorithm/每日一题/leetcode_1189. “气球” 的最大数量/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/leetcode_1189. “气球” 的最大数量/","excerpt":"题目解析：给你一个字符串 text，你需要使用 text 中的字母来拼凑尽可能多的单词 “balloon”（气球）。 字符串 text 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 “balloon”。 示例示例 1:12输入：text = &quot;nlaebolko&quot;输出：1 示例 2:12输入：text = &quot;loonbalxballpoon&quot;输出：2 提示：121 &lt;= text.length &lt;= 10^4text 全部由小写英文字母组成","text":"题目解析：给你一个字符串 text，你需要使用 text 中的字母来拼凑尽可能多的单词 “balloon”（气球）。 字符串 text 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 “balloon”。 示例示例 1:12输入：text = &quot;nlaebolko&quot;输出：1 示例 2:12输入：text = &quot;loonbalxballpoon&quot;输出：2 提示：121 &lt;= text.length &lt;= 10^4text 全部由小写英文字母组成 解题思路先找出各个字母的个数，然后找出其中的最小值(o,l数量除以2)。 用match正则检测字符串中符合条件的字母，其长度即为该字母在字符串中的个数。 解答123456789101112var maxNumberOfBalloons = function(text) &#123; let regexp, singleNum, min = text.length; for (let i in &quot;balon&quot;) &#123; regexp = new RegExp(&quot;balon&quot;[i], &apos;g&apos;); singleNum = text.match(regexp).length; if (&quot;balon&quot;[i]) == &apos;o&apos; || &quot;balon&quot;[i]) == &apos;l&apos;) &#123; singleNum = Math.floor(singleNum / 2) &#125; min = (min &lt;= singleNum) ? min : singleNum; &#125; return min;&#125;; 解题思路二用split分割字符串，分割之后的数组长度-1 就是该字符(分隔符)在该字符串中的个数。 解答二1234567891011var maxNumberOfBalloons = function(text) &#123; let singleNum, min = text.length; for (let i in &quot;balon&quot;) &#123; singleNum = text.split(&quot;balon&quot;[i]).length - 1; if (&quot;balon&quot;[i]) == &apos;o&apos; || &quot;balon&quot;[i]) == &apos;l&apos;) &#123; singleNum = Math.floor(singleNum / 2) &#125; min = (min &lt;= singleNum) ? min : singleNum; &#125; return min;&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"Leetcode_14. 最长公共前缀","slug":"leetcode_14. 最长公共前缀","date":"2019-09-20T03:59:13.000Z","updated":"2019-09-25T07:45:45.577Z","comments":true,"path":"Algorithm/每日一题/leetcode_14. 最长公共前缀/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/leetcode_14. 最长公共前缀/","excerpt":"题目解析：编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot;。 示例示例 1:12输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot; 示例 2:123输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。","text":"题目解析：编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot;。 示例示例 1:12输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot; 示例 2:123输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。 解题思路依序判断所有字符串的第N位字符是否一致。一致就加入共同前缀，不一致就跳出返回之前的前缀。 解答12345678910111213141516171819202122232425var longestCommonPrefix = function(strs) &#123; // 首先判断一下边界情况： // 1. 当长度为0时，结果必然为&quot;&quot;; // 2. 当长度为1时，结果必然为&quot;strs[0]&quot;; if (!strs.length) &#123;return &quot;&quot;;&#125;; if (strs.length == 1) &#123;return strs[0]&#125;; // 定义公共前缀 let comStr = &quot;&quot;; // 循环每个字符串的每个字母,以第一个字符串的长度为准 for (let i = 0; i &lt; strs[0].length; i++) &#123; // 定义每次循环的第一个字符串的字母 当其字符串长度不够时，取值为undefined,所以会判断为不相等跳出循环。 let item = strs[0][i]; // 循环数组 for (let j = 0; j &lt; strs.length; j++) &#123; //判断所有字符串的第i个字母是否一致，不一致返回原来的共同前缀。 if (strs[j][i] != item) &#123; return comStr; &#125; &#125; //一致的话将该字母加入共同前缀 comStr += item; &#125; // 回共同前缀 当所有字符串都一致的情况下才会在此处返回。 return comStr;&#125;; 解题思路二对数组中的字符串排序，然后比较最大和最小的字符串的公共前缀。即为数组的公共前缀 解答二123456789101112var longestCommonPrefix = function(strs) &#123; if (!strs.length) &#123;return &quot;&quot;;&#125;; if (strs.length == 1) &#123;return strs[0]&#125;; let comStr = &quot;&quot;; strs.sort(); for (let i = 0; i &lt; strs[0].length; i++) &#123; if (strs[0][i] != strs[strs.length - 1][i]) &#123; return strs[0].slice(0, (i + 1)); &#125; &#125; return strs[0];&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"Leetcode_35. 搜索插入位置","slug":"leetcode_35. 搜索插入位置","date":"2019-09-20T03:59:13.000Z","updated":"2019-09-25T07:45:45.455Z","comments":true,"path":"Algorithm/每日一题/leetcode_35. 搜索插入位置/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/leetcode_35. 搜索插入位置/","excerpt":"题目解析：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例示例 1:12输入: [1,3,5,6], 5输出: 2 示例 2:12输入: [1,3,5,6], 0输出: 0","text":"题目解析：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例示例 1:12输入: [1,3,5,6], 5输出: 2 示例 2:12输入: [1,3,5,6], 0输出: 0 解题思路利用findIndex函数遍历数组。 解答123456var findFuc = function(el, index, arr) &#123; return el &gt;= this&#125;var searchInsert = function(nums, target) &#123; return nums.findIndex(findFuc, target) == -1 ? nums.length : nums.findIndex(findFuc, target)&#125;; 解题思路二利用二分法遍历数组。 解答二1234567891011121314151617181920var searchInsert = function(nums, target) &#123; if (nums[0] &gt;= target) &#123; return 0; &#125; if (nums[nums.length - 1] &lt; target) &#123; return nums.length; &#125; let left = 0, right = nums.length - 1, mid = parseInt((nums.length - 1)/2); while(left &lt; (right-1)) &#123; if (nums[mid] &gt; target) &#123; right = mid; &#125; else if (nums[mid] &lt; target) &#123; left = mid; &#125; else &#123; return mid; &#125; mid = parseInt((left + right) / 2); &#125; return right;&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"HTML5 Drag & Drop 拖拽与拖放","slug":"HTML5 drag & drop 拖拽与拖放","date":"2019-09-07T03:09:34.000Z","updated":"2019-09-20T07:42:48.991Z","comments":true,"path":"JavaScript/HTML5 drag & drop 拖拽与拖放/","link":"","permalink":"http://www.zsfmyz.top/JavaScript/HTML5 drag & drop 拖拽与拖放/","excerpt":"拖拽与拖放 drop &amp; drag 是html5自带的拖拽与拖放的api 语法：所有需要被拖动的元素都要加上draggable属性，默认除了a，img等标签外不可拖动。 123456// html 行内绑定&lt;element ondrag=&quot;myScript&quot;&gt;// js 绑定元素object.ondrag=function()&#123;&#125;;// 全局监听object.addEventListener(&quot;drag&quot;, myScript);","text":"拖拽与拖放 drop &amp; drag 是html5自带的拖拽与拖放的api 语法：所有需要被拖动的元素都要加上draggable属性，默认除了a，img等标签外不可拖动。 123456// html 行内绑定&lt;element ondrag=&quot;myScript&quot;&gt;// js 绑定元素object.ondrag=function()&#123;&#125;;// 全局监听object.addEventListener(&quot;drag&quot;, myScript); 相关重点api 拖拽元素上触发的事件（事件target是拖拽元素） dragstart 被拖拽元素开始被拖拽时触发。 drag 被拖拽元素拖拽中触发 dragend 完成拖动时触发。 拖拽目标容器上的事件（事件target是目标容器） dragenter 被拖拽元素在进入其原始容器内的时候触发。 dragleave 跟enter相对应。 dragover 在另一容器内时触发（实测，只要我开始拖动之后就一直触发，且该事件需要阻止浏览器默认事件，因为在其他容器内都是默认不能拖动的。） drop 释放鼠标时候触发 DataTransfer 是拖拽元素的一个媒介对象，可以设置一些功能 dataTransfer.dropEffect：设置或返回拖放目标上允许发生的拖放行为。如果此设置的拖放行为不在effectAllowed属性设置的多种拖放行为之内，拖放操作将会失败。该属性值只允许none、copy、link、move值之一。 dataTransfer.effectAllowed：设置或返回被拖动元素允许发生的拖动行为。该属性值可设置为none、copy、copyLink、copyMove、link、linkMove、move、all、uninitialized。 dataTransfer.items：该属性返回DataTransferItems对象，该对象代表了拖动数据。 dataTransfer.setDragImage(element x,y)：设置拖放操作的自定义图标。其中element设置自定义图标，x设置图标与鼠标在水平方向的距离；y设置图标与鼠标在垂直方向的距离。 dataTransfer.addElement(element)：添加自定义图标。 dataTransfer.types：该属性返回一个DOMStringList对象，该对象包括了存入dataTransfer中数据的所有类型。 dataTransfer.getData(format)：获取DataTransfer对象中设置format格式的数据。其中format代表数据格式，data代表数据。 dataTransfer.clearData([format])：清除DataTransfer对象中format格式的数据，如果省略format格式，则意味着清除DataTransfer对象中的全部数据。 例子12345678910111213141516&lt;span draggable=&quot;true&quot; &gt;&lt;/span&gt; // 所有需要被拖动的元素都要加上draggable属性，默认除了a，img等标签外不可拖动。//start drag end 中 event都是被拖拽的元素document.addEventListener(&quot;dragstart&quot;, function (event) &#123; var id = $(event.target).prop(&apos;id&apos;); event.dataTransfer.dropEffect = &apos;move&apos; //设置拖动样式&#125;);//dragover dragleave dragenter drop 中event都代表拖放的容器元素 document.addEventListener(&quot;dragover&quot;, function(event) &#123; // drop 阻止浏览器默认事件 event.preventDefault(); console.log(&quot;容器内&quot;);&#125;); 下一章：","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zsfmyz.top/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zsfmyz.top/tags/JavaScript/"}]},{"title":"Font-Family字体对照表及效果展示","slug":"font-family字体对照表及效果展示","date":"2019-08-30T07:37:09.000Z","updated":"2019-09-20T07:42:49.042Z","comments":true,"path":"Css/font-family字体对照表及效果展示/","link":"","permalink":"http://www.zsfmyz.top/Css/font-family字体对照表及效果展示/","excerpt":"","text":"Demo直接进demo演示页面查看吧。 demo演示地址","categories":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/categories/Css/"}],"tags":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/tags/Css/"}]},{"title":"Video截图功能实现","slug":"Video截图功能实现","date":"2019-08-30T07:37:09.000Z","updated":"2019-09-24T02:59:58.562Z","comments":true,"path":"JavaScript/Video截图功能实现/","link":"","permalink":"http://www.zsfmyz.top/JavaScript/Video截图功能实现/","excerpt":"背景 因为所在公司业务为视频编解码，所以项目大多数是围绕视频展开的，之前做了一个快编项目，可以当作一个web端的小型视频编辑器。当中就需要对视频当前帧图进行截取，然后后续当作视频的封面或者海报图。 那么我就需要实现这么一个视频截图的功能。","text":"背景 因为所在公司业务为视频编解码，所以项目大多数是围绕视频展开的，之前做了一个快编项目，可以当作一个web端的小型视频编辑器。当中就需要对视频当前帧图进行截取，然后后续当作视频的封面或者海报图。 那么我就需要实现这么一个视频截图的功能。 API简介 首先视频截图在我们大前端实现，就要借助canvas的drawImage()这个api了。 drawImage 该api的功能简单讲就是将一张图片(Source image)绘制在canvas(Destination canvas)上. 语法： void ctx.drawImage(image, dx, dy);void ctx.drawImage(image, dx, dy, dWidth, dHeight);void ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight); image： 原图片Element. sx, sy, sWidth, sHeight : 需要在原图取起点x，y，宽，高； dx, dy, dWidth, dHeight：在目标canvas上绘制的起点x，y，宽，高。 image，dx，dy为必填 当我们截取并绘制完图片之后，就需要将在canvas上绘制的图片转化为图片了，那就需要 toDataURL(‘image/png’) 将其转换。 该方法返回一个用作展示的图片地址。 语法： canvas.toDataURL(type, encoderOptions); type: 默认为 image/png， 可选 image/jpeg或者image/webp encoderOptions：当type为 jpeg或者webp 时，可以选择0-1区间内的值作为输出的图片质量。 MDN HTMLCanvasElement.toDataURL() CanvasRenderingContext2D.drawImage() 回到正题，函数实现 代码实现HTML12345&lt;video id=&quot;video&quot; controls=&quot;controls&quot;&gt; &lt;source src=&quot;../videos/xxx.mp4&quot; /&gt;&lt;/video&gt;&lt;button id=&quot;capture&quot;&gt;Capture&lt;/button&gt;&lt;div id=&quot;output&quot;&gt;&lt;/div&gt; Script1234567891011121314151617181920212223242526(function() &#123; var video, $output; var scale = 0.25; var initialize = function() &#123; $output = $(&quot;#output&quot;); video = $(&quot;#video&quot;).get(0); $(&quot;#capture&quot;).click(captureImage); &#125;; var captureImage = function() &#123; var canvas = document.createElement(&quot;canvas&quot;); canvas.width = video.videoWidth * scale; canvas.height = video.videoHeight * scale; canvas.getContext(&apos;2d&apos;).drawImage(video, 0, 0, canvas.width, canvas.height); var img = document.createElement(&quot;img&quot;); img.src = canvas.toDataURL(&apos;image/png&apos;); $output.prepend(img); &#125;; $(initialize);&#125;()); Demodemo演示地址 大家可以用webstrom内置的服务器进行测试。 使用chrome浏览器需要一个服务器环境，否则canvas的toDataURL方法会报错。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zsfmyz.top/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zsfmyz.top/tags/JavaScript/"}]},{"title":"Border-Radius(圆角)失效了？","slug":"border-radius(圆角)失效了？","date":"2019-08-29T02:53:27.000Z","updated":"2019-09-20T07:42:48.974Z","comments":true,"path":"Css/border-radius(圆角)失效了？/","link":"","permalink":"http://www.zsfmyz.top/Css/border-radius(圆角)失效了？/","excerpt":"今天涉及两个属性： overscroll: scroll-y / scroll-x / scroll; border-radius: 10px;","text":"今天涉及两个属性： overscroll: scroll-y / scroll-x / scroll; border-radius: 10px; 原本这两个属性是没有什么联系的，但是当同时出现在同一个元素上时，就会发生圆角效果被滑动条覆盖的情况。例如： 1234567&lt;style&gt; div &#123; border-radius:10px; overflow:scroll-y; &#125;&lt;/style&gt;&lt;div&gt;&lt;/div&gt; 这种情况下，div的右上角和右下角都会因为滚动条的存在而显示的是直角。其实div的四个角确实已经有了圆角的效果，但是滚动条属于div内部的元素，层级高，所以将div的圆角遮挡住了。那么我们解决这种情况的方法也很简单。 123456789101112&lt;style&gt; div &#123; border-radius: 10px; overflow: hidden; &#125; ul &#123; overflow: scroll-y; &#125;&lt;/style&gt;&lt;div&gt; &lt;ul&gt;&lt;/ul&gt;&lt;/div&gt; 我们在原本需要滚动的盒子内部加上一层滚动元素，将滚动的效果放在内部的滚动元素上，外部div加上overflow: hidden;并设置圆角，就可以达到我们需要的效果。 同样的我们也可以在当前元素的外层加上圆角遮罩，最终效果同上。 如有其他情况欢迎补充","categories":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/categories/Css/"}],"tags":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/tags/Css/"}]},{"title":"Hexo搭建配置总结","slug":"Hexo搭建配置总结","date":"2019-08-27T10:14:27.000Z","updated":"2019-10-18T03:19:40.770Z","comments":true,"path":"Hexo/Hexo搭建配置总结/","link":"","permalink":"http://www.zsfmyz.top/Hexo/Hexo搭建配置总结/","excerpt":"主题是material-x 简介： Hexo 添加Favicon Hexo 添加百度统计 Hexo RSS订阅 Hexo 添加看板娘 Hexo 网站地图 Hexo 评论系统 gitalk","text":"主题是material-x 简介： Hexo 添加Favicon Hexo 添加百度统计 Hexo RSS订阅 Hexo 添加看板娘 Hexo 网站地图 Hexo 评论系统 gitalk Hexo 添加Favicon根目录_config.yml 根目录为public的时候,图片放在source下面的img里面就可以，没有的话创建个img文件夹。 1favicon: https://www.xxx.com/img/favicon.ico Hexo 添加百度统计 首先肯定是要去百度统计注册一下了。。百度统计注册完成之后生成统计代码，备用。 在主题配置文件_config.yml里面添加一行 12# Analyticscnzz: true 找到 \\hexo\\themes\\pacman\\layout_partial,在这个文件夹中创建一个cnzz.ejs的文件然后将下面内容复制进去，记得替换中间的script 1234567891011 &lt;% if (theme.cnzz)&#123; %&gt;&lt;!-- 将中间这一块script替换成你的统计代码 --&gt;&lt;script type=&quot;text/javascript&quot;&gt; var cnzz_protocol = ((&quot;https:&quot; == document.location.protocol) ? &quot; https://&quot;: &quot; http://&quot;); document.write(unescape(&quot;%3Cspan id=&apos;cnzz_stat_icon_1000543074&apos;%3E%3C/span%3E%3Cscript src=&apos;&quot; + cnzz_protocol + &quot;s19.cnzz.com/z_stat.php%3Fid%3D1000543074%26show%3Dpic&apos; type=&apos;text/javascript&apos;%3E%3C/script%3E&quot;));&lt;/script&gt;&lt;% &#125; %&gt; 在 \\hexo\\themes\\pacman\\layout_partial\\footer.ejs中加一行下面的代码，然后就结束了。重启生效就可以了。然后在百度中心检测代码有没有安装成功，生效了就可以看报告了。这个过程需要一定的时间。 1&lt;%- partial(&apos;cnzz&apos;) %&gt; Hexo RSS订阅 进入hexo目录 1npm install hexo-generator-feed 根目录_config.yml中添加 12345678#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed:type: atompath: atom.xmllimit: 20 主题目录下_config.yml中添加1rss: /atom.xml Hexo 添加看板娘 进入hexo目录 1npm install --save hexo-helper-live2d 根目录_config.yml中添加 12345678910111213141516171819#看板娘live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false log: false model: use: live2d-widget-model-wanko #可选择不同的看板娘名称 display: position: right width: 150 height: 300 mobile: show: true react: opacity: 0.7 可以添加看板娘列表中添加12345678910111213141516171819202122live2d-widget-model-chitoselive2d-widget-model-epsilon2_1live2d-widget-model-gflive2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru)live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru)live2d-widget-model-harutolive2d-widget-model-hibikilive2d-widget-model-hijikilive2d-widget-model-izumilive2d-widget-model-koharulive2d-widget-model-mikulive2d-widget-model-ni-jlive2d-widget-model-nicolive2d-widget-model-nietzschelive2d-widget-model-nipsilonlive2d-widget-model-nitolive2d-widget-model-shizukulive2d-widget-model-tororolive2d-widget-model-tsumikilive2d-widget-model-unitychanlive2d-widget-model-wankolive2d-widget-model-z16 想用哪个就 npm install –save xxx ， 然后在配置文件use: xxx 进行修改就好了。 取消看板娘 1npm uninstall hexo-helper-live2d 然后去掉配置文件里面的配置就好了 Hexo 网站地图 添加sitemap 12npm install hexo-generator-sitemap --save #sitemap.xml适合提交给谷歌搜素引擎npm install hexo-generator-baidu-sitemap --save #baidusitemap.xml适合提交百度搜索引擎 然后在站点配置文件_config.yml中添加以下代码 自动生成sitemap,在根目录_config.yml中添加 sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 最后修改根目录_config.yml中的url url: http://你的网站 然后hexo g, 会在/public目录下生成sitemap.xml和baidusitemap.xml 网站地图。 Hexo 评论系统 gitalk 创建评论仓库 首先到github中创建repository，库名称可以叫XXXtalk，因为这个仓库是用来存储我们的评论内容的。 创建好之后，进入这个仓库的settings界面找到issues选项，确保它的勾选着的。 注册Github Application 到github中创建Github Application。 名称和描述可以随意填写，两个URL填写你的博客地址就可以了。注册之后就可以看到Client ID 和 Client Secret。这两个是我们需要的东西。 根目录下配置gitalk 将下面的代码赋值到根目录下 123456gitalk: clientID: 你的clientID clientSecret: 你的clientSecret repo: 你的repo名 //xxxtalk 刚才我们创建的仓库名 owner: 你的GitHub名 admin: [你的GitHub名称] 接下来hexo g 执行之后，你会发现你的文章下面会出现评论了。 错误处理 第一次添加gitalk出现了 Error:Validation Failed 这样的错误具体原因是因为Github 限制 labal 长度不能超过 50引起的。 解决办法是使用md5对id进行加密。 解决方案：首先将下面的内容保存为md5.js放在 themes/material-X/source/js/ 下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788! function(n) &#123; &quot;use strict&quot;; function t(n, t) &#123; var r = (65535 &amp; n) + (65535 &amp; t); return (n &gt;&gt; 16) + (t &gt;&gt; 16) + (r &gt;&gt; 16) &lt;&lt; 16 | 65535 &amp; r &#125; function r(n, t) &#123; return n &lt;&lt; t | n &gt;&gt;&gt; 32 - t &#125; function e(n, e, o, u, c, f) &#123; return t(r(t(t(e, n), t(u, f)), c), o) &#125; function o(n, t, r, o, u, c, f) &#123; return e(t &amp; r | ~t &amp; o, n, t, u, c, f) &#125; function u(n, t, r, o, u, c, f) &#123; return e(t &amp; o | r &amp; ~o, n, t, u, c, f) &#125; function c(n, t, r, o, u, c, f) &#123; return e(t ^ r ^ o, n, t, u, c, f) &#125; function f(n, t, r, o, u, c, f) &#123; return e(r ^ (t | ~o), n, t, u, c, f) &#125; function i(n, r) &#123; n[r &gt;&gt; 5] |= 128 &lt;&lt; r % 32, n[14 + (r + 64 &gt;&gt;&gt; 9 &lt;&lt; 4)] = r; var e, i, a, d, h, l = 1732584193, g = -271733879, v = -1732584194, m = 271733878; for (e = 0; e &lt; n.length; e += 16) i = l, a = g, d = v, h = m, g = f(g = f(g = f(g = f(g = c(g = c(g = c(g = c(g = u(g = u(g = u(g = u(g = o(g = o(g = o(g = o(g, v = o(v, m = o(m, l = o(l, g, v, m, n[e], 7, -680876936), g, v, n[e + 1], 12, -389564586), l, g, n[e + 2], 17, 606105819), m, l, n[e + 3], 22, -1044525330), v = o(v, m = o(m, l = o(l, g, v, m, n[e + 4], 7, -176418897), g, v, n[e + 5], 12, 1200080426), l, g, n[e + 6], 17, -1473231341), m, l, n[e + 7], 22, -45705983), v = o(v, m = o(m, l = o(l, g, v, m, n[e + 8], 7, 1770035416), g, v, n[e + 9], 12, -1958414417), l, g, n[e + 10], 17, -42063), m, l, n[e + 11], 22, -1990404162), v = o(v, m = o(m, l = o(l, g, v, m, n[e + 12], 7, 1804603682), g, v, n[e + 13], 12, -40341101), l, g, n[e + 14], 17, -1502002290), m, l, n[e + 15], 22, 1236535329), v = u(v, m = u(m, l = u(l, g, v, m, n[e + 1], 5, -165796510), g, v, n[e + 6], 9, -1069501632), l, g, n[e + 11], 14, 643717713), m, l, n[e], 20, -373897302), v = u(v, m = u(m, l = u(l, g, v, m, n[e + 5], 5, -701558691), g, v, n[e + 10], 9, 38016083), l, g, n[e + 15], 14, -660478335), m, l, n[e + 4], 20, -405537848), v = u(v, m = u(m, l = u(l, g, v, m, n[e + 9], 5, 568446438), g, v, n[e + 14], 9, -1019803690), l, g, n[e + 3], 14, -187363961), m, l, n[e + 8], 20, 1163531501), v = u(v, m = u(m, l = u(l, g, v, m, n[e + 13], 5, -1444681467), g, v, n[e + 2], 9, -51403784), l, g, n[e + 7], 14, 1735328473), m, l, n[e + 12], 20, -1926607734), v = c(v, m = c(m, l = c(l, g, v, m, n[e + 5], 4, -378558), g, v, n[e + 8], 11, -2022574463), l, g, n[e + 11], 16, 1839030562), m, l, n[e + 14], 23, -35309556), v = c(v, m = c(m, l = c(l, g, v, m, n[e + 1], 4, -1530992060), g, v, n[e + 4], 11, 1272893353), l, g, n[e + 7], 16, -155497632), m, l, n[e + 10], 23, -1094730640), v = c(v, m = c(m, l = c(l, g, v, m, n[e + 13], 4, 681279174), g, v, n[e], 11, -358537222), l, g, n[e + 3], 16, -722521979), m, l, n[e + 6], 23, 76029189), v = c(v, m = c(m, l = c(l, g, v, m, n[e + 9], 4, -640364487), g, v, n[e + 12], 11, -421815835), l, g, n[e + 15], 16, 530742520), m, l, n[e + 2], 23, -995338651), v = f(v, m = f(m, l = f(l, g, v, m, n[e], 6, -198630844), g, v, n[e + 7], 10, 1126891415), l, g, n[e + 14], 15, -1416354905), m, l, n[e + 5], 21, -57434055), v = f(v, m = f(m, l = f(l, g, v, m, n[e + 12], 6, 1700485571), g, v, n[e + 3], 10, -1894986606), l, g, n[e + 10], 15, -1051523), m, l, n[e + 1], 21, -2054922799), v = f(v, m = f(m, l = f(l, g, v, m, n[e + 8], 6, 1873313359), g, v, n[e + 15], 10, -30611744), l, g, n[e + 6], 15, -1560198380), m, l, n[e + 13], 21, 1309151649), v = f(v, m = f(m, l = f(l, g, v, m, n[e + 4], 6, -145523070), g, v, n[e + 11], 10, -1120210379), l, g, n[e + 2], 15, 718787259), m, l, n[e + 9], 21, -343485551), l = t(l, i), g = t(g, a), v = t(v, d), m = t(m, h); return [l, g, v, m] &#125; function a(n) &#123; var t, r = &quot;&quot;, e = 32 * n.length; for (t = 0; t &lt; e; t += 8) r += String.fromCharCode(n[t &gt;&gt; 5] &gt;&gt;&gt; t % 32 &amp; 255); return r &#125; function d(n) &#123; var t, r = []; for (r[(n.length &gt;&gt; 2) - 1] = void 0, t = 0; t &lt; r.length; t += 1) r[t] = 0; var e = 8 * n.length; for (t = 0; t &lt; e; t += 8) r[t &gt;&gt; 5] |= (255 &amp; n.charCodeAt(t / 8)) &lt;&lt; t % 32; return r &#125; function h(n) &#123; return a(i(d(n), 8 * n.length)) &#125; function l(n, t) &#123; var r, e, o = d(n), u = [], c = []; for (u[15] = c[15] = void 0, o.length &gt; 16 &amp;&amp; (o = i(o, 8 * n.length)), r = 0; r &lt; 16; r += 1) u[r] = 909522486 ^ o[r], c[r] = 1549556828 ^ o[r]; return e = i(u.concat(d(t)), 512 + 8 * t.length), a(i(c.concat(e), 640)) &#125; function g(n) &#123; var t, r, e = &quot;&quot;; for (r = 0; r &lt; n.length; r += 1) t = n.charCodeAt(r), e += &quot;0123456789abcdef&quot;.charAt(t &gt;&gt;&gt; 4 &amp; 15) + &quot;0123456789abcdef&quot;.charAt(15 &amp; t); return e &#125; function v(n) &#123; return unescape(encodeURIComponent(n)) &#125; function m(n) &#123; return h(v(n)) &#125; function p(n) &#123; return g(m(n)) &#125; function s(n, t) &#123; return l(v(n), v(t)) &#125; function C(n, t) &#123; return g(s(n, t)) &#125; function A(n, t, r) &#123; return t ? r ? s(t, n) : C(t, n) : r ? m(n) : p(n) &#125; &quot;function&quot; == typeof define &amp;&amp; define.amd ? define(function() &#123; return A &#125;) : &quot;object&quot; == typeof module &amp;&amp; module.exports ? module.exports = A : n.md5 = A&#125;(this); 保存之后，修改主题目录下 layout/_partial/scripts.ejs 138行，修改如下 123456789101112131415161718192021&lt;% if (enableGitalk) &#123; %&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css&quot;&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/js/md5.js&quot;&gt;&lt;/script&gt; // 添加！！！！ &lt;script type=&quot;text/javascript&quot;&gt; var gitalk = new Gitalk(&#123; clientID: &quot;&lt;%- config.gitalk.clientID %&gt;&quot;, clientSecret: &quot;&lt;%- config.gitalk.clientSecret %&gt;&quot;, repo: &quot;&lt;%- config.gitalk.repo %&gt;&quot;, owner: &quot;&lt;%- config.gitalk.owner %&gt;&quot;, admin: &quot;&lt;%- config.gitalk.admin %&gt;&quot;, &lt;% if(page.gitalk &amp;&amp; page.gitalk.id) &#123; %&gt; id: &quot;&lt;%= page.gitalk.id %&gt;&quot;, &lt;% &#125; else &#123; %&gt; id: md5(location.pathname), // 修改！！！！ &lt;% &#125; %&gt; distractionFreeMode: false // Facebook-like distraction free mode &#125;); gitalk.render(&apos;gitalk-container&apos;); &lt;/script&gt;&lt;% &#125; %&gt; 如上一处添加，一处修改，当然也可以将这块代码完全替换了也可以，然后hexo g 之后问题应该就解决了。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.zsfmyz.top/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.zsfmyz.top/tags/Hexo/"}]},{"title":"Z-Index失效了？","slug":"z-index失效了？ ","date":"2019-08-27T10:14:27.000Z","updated":"2019-09-20T07:42:49.124Z","comments":true,"path":"Css/z-index失效了？ /","link":"","permalink":"http://www.zsfmyz.top/Css/z-index失效了？ /","excerpt":"背景 我们在使用z-index的时候，有时候会发现，无论怎么样增大z-index的值，都无法改变目标元素的层级。 其实是这几种情况在作怪 position float opcity","text":"背景 我们在使用z-index的时候，有时候会发现，无论怎么样增大z-index的值，都无法改变目标元素的层级。 其实是这几种情况在作怪 position float opcity 父盒子的层级问题 父盒子的层级问题，当你的父盒子层级小于另一个父盒子层级的时候，你子元素的z-index再高都是没有用的。该元素的层级只在该元素所在的容器内起作用。该种情况大家应该容易理解，不过也可以看下面的例子。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;style type=&quot;text/css&quot;&gt; .a1&#123; position:relative; z-index: 2; width:400px; height:400px; background: black; border:1px solid #eee; margin-bottom: -100px; &#125; .a&#123; position:relative; z-index: 1; width:400px; height:400px; background: yellow; left:0; border:1px solid #eee; &#125; .b&#123; position:absolute; left:0; top:0; z-index: 50; width:200px; height:200px; background: red; &#125; .c&#123; position: absolute; left:0; top:0; z-index:1111; width:100px; height:100px; background: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;a1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;a&quot;&gt; &lt;div class=&quot;b&quot;&gt;&lt;/div&gt; &lt;div class=&quot;c&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt; opcity属性 opcity属性，当你要设置两个元素的z-index值的时候，要注意是否给其中一个元素添加了opcity属性，如果添加了，那么添加了opcity属性的元素将一直在最上层，这个我在另一篇文章中讲过。 opcity引发的元素层级变化 position影响 还有就是比较普遍的，我们设置层级一般都是因为设置了position，当你设置的两个子元素，一个有position属性，另一个没有position的时候，拥有position属性的元素将一直在其他元素上方。如下面的例子 123456789101112131415161718192021222324252627282930313233343536&lt;style type=&quot;text/css&quot;&gt; .a&#123; position:relative; z-index: 1; width:400px; height:400px; background: yellow; left:0; border:1px solid #eee; &#125; .b&#123; position:absolute; left:0; top:0; z-index: 50; width:200px; height:200px; background: red; &#125; .c&#123; z-index:100; width:100px; height:100px; background: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;a&quot;&gt; &lt;div class=&quot;b&quot;&gt;&lt;/div&gt; &lt;div class=&quot;c&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt; 需要给c也加上position属性才让bc可以先同处一级，然后z-index才会起作用。 float影响 那如果我把子元素的position都去掉呢？当父盒子有position而所有子元素都没有position属性的时候，z-index一样全部失效，后面的盒子将会覆盖前面的盒子，z-index无效。 同样的我们两个都加上浮动的效果跟上面的效果是一样的，后覆盖前，z-index无效 一个加float另一个不加，则是加float的元素一直浮动在最上层。 12345678910111213141516171819202122232425262728293031323334&lt;style type=&quot;text/css&quot;&gt; .a&#123; position:absolute; z-index: 1; width:400px; height:400px; background: yellow; left:0; border:1px solid #eee; &#125; .b&#123; z-index: -10; width:200px; height:200px; background: red; margin-bottom: -100px; &#125; .c&#123; z-index:101; width:100px; height:100px; background: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;a&quot;&gt; &lt;div class=&quot;b&quot;&gt;&lt;/div&gt; &lt;div class=&quot;c&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt; 其他情况欢迎补充。","categories":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/categories/Css/"}],"tags":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/tags/Css/"}]},{"title":"V-Model","slug":"v-model","date":"2019-08-26T08:59:13.000Z","updated":"2019-09-20T07:42:49.164Z","comments":true,"path":"Vue/v-model/","link":"","permalink":"http://www.zsfmyz.top/Vue/v-model/","excerpt":"最近学习vue，从最基础的文档看起。到目前基础已经看完。有两个问题很迷茫。 vue的动态参数（2.6新增）。demo一直报错。分析原因是因为vue不允许动态添加根一级的变量。（不理解） 组件中v-model的使用文档中说的让我有点绕。不过已经顺过来了，所以来分享一下。","text":"最近学习vue，从最基础的文档看起。到目前基础已经看完。有两个问题很迷茫。 vue的动态参数（2.6新增）。demo一直报错。分析原因是因为vue不允许动态添加根一级的变量。（不理解） 组件中v-model的使用文档中说的让我有点绕。不过已经顺过来了，所以来分享一下。 官方给出的例子是这样。(可以直接使用)1234567891011121314HTML:&lt;custom-input v-model=&quot;searchText&quot;&gt;&lt;/custom-input&gt;JS:Vue.component(&apos;custom-input&apos;, &#123; props: [&apos;value&apos;], template: ` &lt;input v-bind:value=&quot;value&quot; v-on:input=&quot;$emit(&apos;input&apos;, $event.target.value)&quot; &gt; `&#125;) v-model可以改写为这种形式，两者完全等价。1234567&lt;input v-model=&quot;searchText&quot;&gt;等价于：&lt;input v-bind:value=&quot;searchText&quot; v-on:input=&quot;searchText = $event.target.value&quot;&gt; //（ $event.target.value为事件当前目标上的value值。） 第二种写法： 在input上绑定了input事件，通过触发input事件，执行给searchText赋值语句。 v-bind将searchText赋值给input标签的value属性。 再看官方的例子：1&lt;custom-input v-model=&quot;searchText&quot;&gt;&lt;/custom-input&gt; 等价于：1234&lt;custom-input v-bind:value=&quot;searchText&quot; v-on:input=&quot;searchText = $event&quot; //$event 为组件内部抛出来的值。（这个如果不明白可以看组件的自定义事件部分）&gt;&lt;/custom-input&gt; 再加上官方的js写法： 123456789Vue.component(&apos;custom-input&apos;, &#123; props: [&apos;value&apos;], template: ` &lt;input v-bind:value=&quot;value&quot; v-on:input=&quot;$emit(&apos;input&apos;, $event.target.value)&quot; &gt; `&#125;) 我们在组件内的input上监听了input事件，并且用该input事件对组件上的（自定义）input事件进行触发（searchText = $event”）； 将$ event.target.value作为参数传给 v-on:input=”searchText = $ event “，$ event === $ event.target.value。执行语句searchText被赋值。 组件上的v-bind:value = “searchText” 是将searchText的值绑定到组件内部的props里的value上。 组件内部将props中的value 绑定到input的value上。就这样完成了一次双向绑定。 而根据官方v-model的两种写法，组件上转换回v-modal的写法。就完成了。最终结果就如开头所示。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://www.zsfmyz.top/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.zsfmyz.top/tags/Vue/"}]},{"title":"Leetcode_7. 整数反转","slug":"leetcode_7. 整数反转","date":"2019-07-27T09:59:13.000Z","updated":"2019-09-26T10:19:30.469Z","comments":true,"path":"Algorithm/每日一题/leetcode_7. 整数反转/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/leetcode_7. 整数反转/","excerpt":"题目解析：给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例示例 1: 输入: 123 输出: 321 示例 2: 输入: -123 输出: -321示例 3: 输入: 120 输出: 21 注意假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。","text":"题目解析：给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例示例 1: 输入: 123 输出: 321 示例 2: 输入: -123 输出: -321示例 3: 输入: 120 输出: 21 注意假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 解题思路题目就是反转，问题在于反转过程中是否溢出。 先判断正负。 10位以内直接反转。 接下来就是10位数字的反转，反转过程中判断是否会溢出。（不能反转后再判断是否溢出，因为环境只能存储32位有符号整数，所以反转之后的如果真的溢出是保存不了的）解答 12345678910111213141516var max;var flag;var reverse = function(x) &#123; x &lt; 0 ? (flag = &apos;-&apos;, max = &apos;2147483648&apos;) : (flag = &apos;+&apos;, max = &apos;2147483647&apos;); var val = (Math.abs(x) + &apos;&apos;).split(&apos;&apos;); if (val.length &lt; 10) &#123; return ((flag + val.reverse().join(&apos;&apos;)) - 0) &#125; if (val.length = 10) &#123; for (var i = 0; i &lt; 10; i++) &#123; if (val[9 - i] &gt; max[i]) &#123; return 0; &#125; else if (val[9 - i] &lt; max[i]) &#123; return ((flag + val.reverse().join(&apos;&apos;)) - 0) &#125; &#125; &#125;&#125;; 题目很简单，肯定还是可以优化的，如果有更好的办法可以留言。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"Leetcode_2. 两数相加","slug":"leetcode_2. 两数相加","date":"2019-06-27T09:59:13.000Z","updated":"2019-09-30T09:58:51.422Z","comments":true,"path":"Algorithm/每日一题/leetcode_2. 两数相加/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/每日一题/leetcode_2. 两数相加/","excerpt":"给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例：123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807","text":"给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例：123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 题目解析： 该题给出两个链表，求出两个链表各个结点的和，那首先我们需要知道链表是什么样子。 1234567/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; */ 如上，链表的每个结点就是这个样子，next指向下一个结点，当然这是在js中简单的实现了链表。 然后知道了链表，那么就开始各位相加吧~，这个题唯一的难点就是在于各个结点相加的时候可能会产生进位。比如9+2=11，那么就需要进一位，本位取10的余数为值，然后我们就需要在下一个结点相加时把前两位可能产生的进位也算进去。 如下是我的js解答： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; l1 * @param &#123;ListNode&#125; l2 * @return &#123;ListNode&#125; * y 为进位值 * i 代表和的位 * n 代表了和的每一位的值 * arr 代表和（我们用数组表示更方便一点） */var addTwoNumbers = function(l1, l2) &#123; var arr = [], i = 0, n = 0, y = 0; //初始化 //因为链表不一定同样长的，所以只要有一个链表的结点不为空，我们都需要继续计算； //同时我们也要考虑进位，即使两个链表结束了，如果有进位的话，那我们还是需要再计算一次的。 while (l1 !== null || l2 !== null || y !== 0) &#123; //判断链表l1的该结点是否为null，如果为null初始化成值为0的结点，方便运算。 l1 = l1 ? l1 : new ListNode(0); // 同理 l2 l2 = l2 ? l2 : new ListNode(0); // 计算该位的两个结点的和，同时要加上前两位的进位。 var num = l1.val + l2.val + y; // 判断该位是否需要进位，需要进位的话就该位取10的余数，然后进一位（y = 1），反之初始化进位值为0。 num &gt; 9 ? (y = 1, n = num - 10) : (n = num, y = 0); arr[i] = n; //给和的每一位赋值 i++; //进入下一次循环 l1 = l1.next; // 进入l1下一个结点 l2 = l2.next; // 进入l2下一个结点 &#125; //这里反转一下，原本是[7, 0, 8]反转为[8, 0, 7],方便后面生成链表。 arr = arr.reverse(); //取第一个值创建第一个结点（也是最终链表的最后一个结点） let listNode = new ListNode(arr.shift()) //取第一个值创建第一个结点（也是最终链表的最后一个结点） return arr.reduce((ori,cur)=&gt;&#123; let ln = new ListNode(cur) //生成当前结点 ln.next = ori //将当前结点的next指向之前生成的链表的第一个结点 return ln //返回新的链表（赋值给了 ori ） &#125;, listNode) // listNode是初始值。 // 即链表末端的第一个值，我们之所以从最后一个开始创建链表也是因为方便。 // 因为我们要操作结点的next，所以用新结点的next指向原来的链表，要比找到链表的最后一个结点的next指向新结点要方便一些。 // 即从后往前生成链。&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"},{"name":"每日一题","slug":"Algorithm/每日一题","permalink":"http://www.zsfmyz.top/categories/Algorithm/每日一题/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"完全背包问题","slug":"完全背包问题","date":"2019-04-30T07:10:03.000Z","updated":"2019-09-20T07:34:23.275Z","comments":true,"path":"Algorithm/完全背包问题/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/完全背包问题/","excerpt":"题目描述 这里借用一个题目的描述来说明要解决问题的背景。 LiYuxiang是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同种类的草药，采每一种都需要一些时间，每一种也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。” 如果你是LiYuxiang，你能完成这个任务吗？ 此题和原题的不同点： 1.每种草药可以无限制地疯狂采摘。 2.药的种类眼花缭乱，采药时间好长好长啊！师傅等得菊花都谢了！ 一、 什么是背包算法背包算法的基础标准描述为：当前有N件商品，每件商品都有不同的价值v和重量w。我们要把这些商品放在容量为L的背包中，实现背包中的价值最大化。（第i件商品的价值为v[i]，重量为w[i])。上面的题目中的条件之一：草药无限（每件商品可以重复放入背包）即表明了该问题是完全背包问题。","text":"题目描述 这里借用一个题目的描述来说明要解决问题的背景。 LiYuxiang是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同种类的草药，采每一种都需要一些时间，每一种也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。” 如果你是LiYuxiang，你能完成这个任务吗？ 此题和原题的不同点： 1.每种草药可以无限制地疯狂采摘。 2.药的种类眼花缭乱，采药时间好长好长啊！师傅等得菊花都谢了！ 一、 什么是背包算法背包算法的基础标准描述为：当前有N件商品，每件商品都有不同的价值v和重量w。我们要把这些商品放在容量为L的背包中，实现背包中的价值最大化。（第i件商品的价值为v[i]，重量为w[i])。上面的题目中的条件之一：草药无限（每件商品可以重复放入背包）即表明了该问题是完全背包问题。 二、 背包算法的应用背包算法在我看来是一种“性价比”算法。即我们在有限的条件下得到最大的收获。例如曾经有个节目可以让嘉宾在有限的时间内选购满满购物车的货品。这个场景及其符合背包算法。或者例如我们在考试的时侯，都会尽可能的选择简单并且分数又多的题先做。同时我们也可以应用到其他问题上去。比如在选择购买多种原材料时，尽可能的缩小原材料成本。投资时对多种投资产品的选择组合。 三、 背包算法的原理背包问题需要用到动态规划算法。当我们装一个商品的时侯需要判断几个条件： 该商品的重量和背包大小的关系。如果背包的总容量小于商品的重量，那就GG，根本不用考虑了。 商品的重量小于背包剩余容量。即背包中之前装入的商品不需要拿出来就可以把当前商品装下，那也不用考虑，直接装就好了。 商品的重量小于背包总容量，但是剩余空间不够装了。那我们就需要考虑衡量一下，拿出来原有的一部分商品，装入现在的商品是不是划算的。 从上面的三个条件可以看出最重要的就是第三条，我们需要判断价值。假设我们背包可以装8kg东西，现在有三个商品（商品都是以袋为单位销售不可拆分）： 苹果 香蕉 草莓 3kg 2kg 5kg ￥45 ￥20 ￥150 我们以1kg为单位打表:第一次打表 0kg 1kg 2kg 3kg 4kg 5kg 6kg 7kg 8kg 无 0 0 0 0 0 0 0 0 0 苹果 0 0 0 ￥45 ￥45 ￥45 ￥90 ￥90 ￥90 香蕉 0 0 0 0 0 0 0 0 0 草莓 0 0 0 0 0 0 0 0 0 第二次打表 0kg 1kg 2kg 3kg 4kg 5kg 6kg 7kg 8kg 无 0 0 0 0 0 0 0 0 0 苹果 0 0 0 ￥45 ￥45 ￥45 ￥90 ￥90 ￥90 香蕉 0 0 ￥20 ￥45 ￥45 ￥65 ￥90 ￥90 ￥110 草莓 0 0 0 0 0 0 0 0 0 最终打表结果： 0kg 1kg 2kg 3kg 4kg 5kg 6kg 7kg 8kg 无 0 0 0 0 0 0 0 0 0 苹果 0 0 0 ￥45 ￥45 ￥45 ￥90 ￥90 ￥90 香蕉 0 0 ￥20 ￥45 ￥45 ￥65 ￥90 ￥90 ￥110 草莓 0 0 ￥20 ￥45 ￥45 ￥150 ￥150 ￥170 ￥195 如表我们的最终排列结果。 核心判断为：bag[i-1][j] 和bag[i-1][j-k*w[i]] + k*v[i] 的价值哪个大。我来说明上面的变量都代表了什么： bag[i][j] 代表了我们在看到第i个商品时，背包容量占用了jkg时，背包内物品的价值。 那么bag[i-1][j] 就代表了我们在看到第i-1个商品时，背包容量占用了jkg时，背包内装的价值。 v[i]代表了当前商品的价值，k*v[i]代表了k个v[i]的价值（商品不限量）。 w[i]代表了当前商品的重量，k*w[i]代表了k个w[i]的重量。 bag[i-1][j-k*w[i]]就代表了上一个情况下，背包装了k个i商品时，余下空间在上一状态的最大价值。 所以，我们的核心判断种需要 上一个情况下的背包的所有状态。当我们把背包中 k*w[i]的空间腾出来用来装k个i商品，加上剩余空间可以装的商品的最大价值。如果它小于上一个状态下bag[i-1][j]所装货品的价值，那么我们就没必要替换这部分空间了。 12345678910//两个循环for (3) //3个商品 for (8) // 8种占用空间的情况（1kg-8kg）// 核心判断if (bag[i-1][j] &gt; bag[i-1][j-k*w[i]] + k*v[i]) &#123; bag[i][j] = bag[i-1][j];&#125; else &#123; bag[i][j] = bag[i-1][j-k*w[i]] + k*v[i];&#125; 其实回到生活上，我们的想法跟这个是一样的，当我们有个背包要装满的时侯，我们先看到了苹果，那么当然的，我们要尽可能多的把苹果装到包包里。如果有剩余空间装不下那也只能浪费着。然后我们发现了香蕉，我们会开始想着怎么用香蕉代替一部分苹果把空间填满。在这个思考的过程中，我们会一直比较什么样的组合价值最大。草莓也是一样。 其实如开头所说，我说这是“性价比”。上面我们商品出现的顺序是随机的。其实我们装东西判断价值，其实就是装性价比最高的物品。 不过同时需要考虑到空间的利用率。如果我们事先把性价比高的物品排在前面，那么效率会提高不少。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"ES6 对象数组查找某一个对象 findIndex","slug":"ES6 对象数组查找某一个对象 findIndex","date":"2019-01-27T09:50:34.000Z","updated":"2019-09-20T07:42:49.042Z","comments":true,"path":"JavaScript/ES6 对象数组查找某一个对象 findIndex/","link":"","permalink":"http://www.zsfmyz.top/JavaScript/ES6 对象数组查找某一个对象 findIndex/","excerpt":"查找数组特定元素需要用到的方法就是findIndex()。 用法与定义 findIndex() 方法返回传入一个测试条件（函数）符合条件的数组第一个元素位置。 findIndex() 方法为数组中的每个元素都调用一次函数执行： 当数组中的元素在测试条件时返回 true 时, findIndex() 返回符合条件的元素的索引位置，之后的值不会再调用 执行函数。如果没有符合条件的元素返回 -1","text":"查找数组特定元素需要用到的方法就是findIndex()。 用法与定义 findIndex() 方法返回传入一个测试条件（函数）符合条件的数组第一个元素位置。 findIndex() 方法为数组中的每个元素都调用一次函数执行： 当数组中的元素在测试条件时返回 true 时, findIndex() 返回符合条件的元素的索引位置，之后的值不会再调用 执行函数。如果没有符合条件的元素返回 -1 以上是比较官方的对于findIndex()的定义 接下来我结合实例来进行自己的解释. 第一条的意思如下:当条件函数返回true的时候，findindex会跳出，然后返回当前元素的下标。123456789101112131415161718192021222324252627282930//首先是普通数组var dataArr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];function fn(num, numIndex, nums)&#123; //该函数的三个参数，num代表当前项，numIndex代表当前项下标，nums代表该数组。 return num &gt; 5;&#125;dataArr.findIndex(fn);//值为5(即6的下标)------------------------分割线-----------------------------//同样的假如你的数组是个对象数组：var objArr = [&#123; name: &apos;小王&apos;, age: 14&#125;,&#123; name: &apos;大王&apos;, age: 41&#125;,&#123; name: &apos;老王&apos;, age: 61&#125;] function objFn(obj, objIndex, objs)&#123; return num.age &gt; 20;&#125;objArr .findIndex(objFn);//值为1(即大王的下标) 第二条的意思就更好理解了，因为findindex只返回第一个符合条件的元素下标，所以在找到第一个符合条件的元素之后，他会跳出该函数，之后的数组内的元素将不再调用，相当于加了个break； 实际用法举例 假如我们要在所有人里面挑选队友，但是不想重复。在我们通过id查找的时候，就可以这么写12345678910111213141516171819202122232425var allPeple = [&#123; name: &apos;小王&apos;, id: 14&#125;,&#123; name: &apos;大王&apos;, id: 41&#125;,&#123; name: &apos;老王&apos;, id: 61&#125;] var myTeamArr = [&#123; name: &apos;小王&apos;, id: 14&#125;] var PId = 14; //假如这个是要添加的人的IDfunction pFn(p)&#123;return p.id == PId ;&#125;//判断myteam里是不是有这个队员，如果==-1 代表没有，在allPeople中找到他，添加入我的队伍myTeamArr.findIndex(pFn) == -1 ? myTeamArr.push(allPeple.find(pFn)) : alert(&apos;已存在该人员&apos;);//这样写可以将两个for循环直接总结成一行代码 另外需要补充的一点 与其相对应的有find()函数，用法一致，只不过返回的是元素本身，而不是元素的下标。 兼容性 因为是es6的所以使用的时候要注意兼容性问题，ie11及之前的版本都不可兼容。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zsfmyz.top/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zsfmyz.top/tags/JavaScript/"}]},{"title":"Call，apply，bind的区别及实现","slug":"call，apply，bind的区别及实现","date":"2019-01-11T07:10:03.000Z","updated":"2019-09-20T07:42:48.974Z","comments":true,"path":"JavaScript/call，apply，bind的区别及实现/","link":"","permalink":"http://www.zsfmyz.top/JavaScript/call，apply，bind的区别及实现/","excerpt":"call，apply，bind的区别这三个函数的左右都是为了指定当前的this。 不同点： call，apply 两者都是对函数的直接调用，bind的返回值仍然是一个函数。 举例：a.call(b) 或者 a.apply(b) 而bind需要 a.bind(b)()这样才能执行 call和apply的传参方式不同，第一个值都是this的指向，第二个举例","text":"call，apply，bind的区别这三个函数的左右都是为了指定当前的this。 不同点： call，apply 两者都是对函数的直接调用，bind的返回值仍然是一个函数。 举例：a.call(b) 或者 a.apply(b) 而bind需要 a.bind(b)()这样才能执行 call和apply的传参方式不同，第一个值都是this的指向，第二个举例 123456a.call(b, 参数1，参数2，参数3)a.apply(b, [参数1，参数2，参数3])//同样的bind的传参方式和call相同，但又因为bind返回的是函数，所以我们可以像正常函数传参一样a.bind(b)(参数1，参数2，参数3) 以上就是三者的差别。 接下来我们实现他们的功能函数。 call： call的传入参数是（ctx,…[]） 1234567891011Function.prototype.mycall = funciton (ctx) &#123; if (typeof this != &quot;function&quot;) &#123; throw new TypeError(&apos;error&apos;); &#125; ctx = ctx || window; ctx.fn = this; var args = ...arguments.splice(1); var result = ctx.fn(args); delete ctx.fn; return result;&#125; apply: apply的传入参数跟call不同，第二个参数是数组。 1234567891011121314Function.prototype.myapply = funciton (ctx) &#123; if (typeof this != &apos;function&apos;) &#123; throw new TypeError(&apos;error&apos;); &#125; ctx = ctx || window; ctx.fn = this; var result; if (arguments[1]) &#123; result = ctx.fn(arguments[1]); &#125; else &#123; result = ctx.fn(); &#125; return result;&#125; bind 返回的是个函数 bind 返回的是个函数，同样可以执行传参 ，我们可以用myapply实现 12345Funtion.prototype.myBind = function(ctx,...args1)&#123; return (...args2) =&gt; &#123; this.myapply(ctx, args1.concat(args2)) &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zsfmyz.top/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zsfmyz.top/tags/JavaScript/"}]},{"title":"Git入门篇","slug":"Git入门篇","date":"2018-11-15T07:14:27.000Z","updated":"2019-11-26T09:01:06.141Z","comments":true,"path":"Git/Git入门篇/","link":"","permalink":"http://www.zsfmyz.top/Git/Git入门篇/","excerpt":"","text":"开始 首先我们需要去github官网申请git账号。git官网 申请之后，我们进入自己的linux服务器 1234// 生成keyssh-keygen//查看公钥 cat ~/.ssh/id_rsa.pub 然后在GitHub上加入这个公钥 配置公钥 设置git命令的简写模式（alias） 1234git config --global alias.co checkoutgit config --global alias.br branchgit config --global alias.ci commitgit config --global alias.st status 设置自己的名字和邮箱 12git config --global user.name &quot;your name&quot;git config --global user.email &quot;your email @.com&quot; 开始 fork 如果你想使用别人的项目，就需要fork。 clone 进入一个你想存放项目的文件夹。如图复制ssh地址。1git clone git@github.com:xxx/xxx.git 然后就可以对代码进行修改和提交了。 checkout 项目有不同的分支。一般本地主分支为master。自己的远程分支为 origin/master如果是合作项目，可能还会有一个公共仓库 xxx/master 可以用以下命令查看。1git br -va 创建本地新分支: new_master 为你创建的新分支名，xxx/master为你要以哪条分支为基准创建new_master1git co -b new_master xxx/master 将新分支推送至自己的远程分支。 1git push origin new_master commit 当我们修改某个文件，使用git st就可以看到哪些文件被修改了。然后使用 git add 可以将我们修改过的文件添加进暂存区123git stgit add xxx.html commit为某次修改的描述，是阶段性的。我们每完成一个功能，或者每修复一个bug，最好都进行一次提交。 1git ci -m &apos;描述&apos; 最后将代码push到我们的远程分支 1git push origin master(分支名) reset有时候我们会后悔添加了文件。那么可以用reset 返回 1git reset xxx.html 这样就可以返回add之前的文件状态。 同样的我们如果已经push到远程分支了 想要回到我们push之前的状态，或者再之前的某个版本。 12git refloggit reset --hard 版本号 以上两个步骤，第一步是查看我们这个分支的所有版本号。 复制你想要回退的版本号，然后执行第二步，就可以了。 fetch/merge push之后我们的远程分支就会和本地分支的内容一样了。 但是如果我们是一个公共项目，那就需要并入公共仓库。 这个就需要管理员来操作了。 等管理员合并了之后，别人就需要fetch并且merge你的代码，以此来使大家的代码都是同步的。 123git fetch --allgit merge xxx/master 每次push之前我们都应该先merge一下公共仓库的代码。以免我们在旧代码上修改提交导致冲突。","categories":[{"name":"Git","slug":"Git","permalink":"http://www.zsfmyz.top/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.zsfmyz.top/tags/Git/"}]},{"title":"Opacity引发的元素层级变化","slug":"Opcity引发的元素层级变化","date":"2018-06-29T10:14:27.000Z","updated":"2019-09-20T07:42:49.059Z","comments":true,"path":"Css/Opcity引发的元素层级变化/","link":"","permalink":"http://www.zsfmyz.top/Css/Opcity引发的元素层级变化/","excerpt":"背景 发现这个问题是在图片上定位了一个删除按钮，当我用opacity属性对图片进行透明化处理的时候，发现删除按钮不管用了，最后发现删除按钮是被图片覆盖了，究其原因是因为opacity这个属性造成的层级变化。 我发现含有opacity属性的元素层级会比其他元素的层级高，这时候z-index是不起作用的，opacity会一直高于其他元素的层级。 给其他元素加上position属性，会使该元素跟opacity处在同一层级之上，这时候你再给元素附加z-index就可以起作用了。","text":"背景 发现这个问题是在图片上定位了一个删除按钮，当我用opacity属性对图片进行透明化处理的时候，发现删除按钮不管用了，最后发现删除按钮是被图片覆盖了，究其原因是因为opacity这个属性造成的层级变化。 我发现含有opacity属性的元素层级会比其他元素的层级高，这时候z-index是不起作用的，opacity会一直高于其他元素的层级。 给其他元素加上position属性，会使该元素跟opacity处在同一层级之上，这时候你再给元素附加z-index就可以起作用了。 总结和解决方案 总结：当你使用opacity的时候会对元素层级造成影响 解决办法：加上position和z-index可以对opacity元素进行覆盖 1234567891011121314151617181920212223.box&#123; width: 200px; height: 200px; background-color: red; color: #fff; cursor: pointer; &#125; .box1&#123; opacity: 0.8; &#125; .box2&#123; background-color: blue; margin-left: 30px; margin-top: -160px; position: relative; z-index: 100; &#125; .box3&#123; background-color: green; margin-left: 60px; margin-top: -160px; opacity: 0.7; &#125; 如上：box2的层级是最高的。","categories":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/categories/Css/"}],"tags":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/tags/Css/"}]},{"title":"Linux压缩命令常用：tar，tgz，gzip，zip","slug":"linux压缩命令常用：tar，tgz，gzip，zip","date":"2018-06-02T10:14:27.000Z","updated":"2019-09-20T07:42:49.105Z","comments":true,"path":"Linux/linux压缩命令常用：tar，tgz，gzip，zip/","link":"","permalink":"http://www.zsfmyz.top/Linux/linux压缩命令常用：tar，tgz，gzip，zip/","excerpt":"linux压缩命令常用的有三个：tar，tgz，gzip，zip","text":"linux压缩命令常用的有三个：tar，tgz，gzip，zip 一，tar（一） tar压缩命令 12345678910tar -cvf examples.tar files|dir#说明：-c, --create create a new archive 创建一个归档文件-v, --verbose verbosely list files processed 显示创建归档文件的进程-f, --file=ARCHIVE use archive file or device ARCHIVE 后面要立刻接被处理的档案名,比如--file=examples.tar#举例：tar -cvf file.tar file1 #file1文件tar -cvf file.tar file1 file2 #file1，file2文件tar -cvf file.tar dir #dir目录 （二） tar 解压命令 123456789tar -xvf examples.tar （解压至当前目录下）tar -xvf examples.tar -C /path (/path 解压至其它路径)#说明：-x, --extract, extract files from an archive 从一个归档文件中提取文件#举例：tar -xvf file.tartar -xvf file.tar -C /temp #解压到temp目录下 二，tgz（一） tgz压缩命令（tar.gz,tgz格式是相同的，命名不同而已） 1234567tar -zcvf examples.tgz examples (examples当前执行路径下的目录)说明：-z, --gzip filter the archive through gzip 通过gzip压缩的形式对文件进行归档举例：tar -zcvf file.tgz dir #dir目录 （二） tgz 解压命令 123456tar -zxvf examples.tar （解压至当前执行目录下）tar -zxvf examples.tar -C /path (/path 解压至其它路径)举例：tar -zcvf file.tgztar -zcvf file.tgz -C /temp 三，gzip（一）gzip压缩： 1gzip -d examples.gz examples （二）gzip解压： 1gunzip examples.gz 四，zip zip 格式是开放且免费的，所以广泛使用在 Windows、Linux、MacOS 平台，要说 zip有什么缺点的话，就是它的压缩率并不是很高，不如 rar及 tar.gz 等格式。 压缩： 1zip -r examples.zip examples (examples为目录) 解压： 1zip examples.zip 六 .rar压缩： 1rar -a examples.rar examples 解压： 1rar -x examples.rar","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.zsfmyz.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.zsfmyz.top/tags/Linux/"}]},{"title":"Css3 + Js：有趣的图片马赛克~ (高斯模糊)","slug":"css3 + Js：有趣的图片马赛克~ (高斯模糊)","date":"2018-05-21T08:59:13.000Z","updated":"2019-09-27T01:20:09.721Z","comments":true,"path":"Css/css3 + Js：有趣的图片马赛克~ (高斯模糊)/","link":"","permalink":"http://www.zsfmyz.top/Css/css3 + Js：有趣的图片马赛克~ (高斯模糊)/","excerpt":"前两篇文介绍了css3的过滤器filter用来实现图片的高斯模糊效果，还有js拖拽的功能。 要实现局部模糊就要把两者结合起来，计算位移就可以了。 *实现原理** 原理其实很简单，就是两张图的叠加。底部一张清晰的图，上面一个高斯模糊过的图，将高斯模糊的图当作上层元素的背景，利用背景定位使其只显示一部分，然后把这个高斯模糊的窗口放置在高清图的上层，背景图片的位置与下面的图片位置一致，这样看起来就像一张高清的图片打上了马赛克一样。讲起来不是很清楚，大家可以看一下代码。","text":"前两篇文介绍了css3的过滤器filter用来实现图片的高斯模糊效果，还有js拖拽的功能。 要实现局部模糊就要把两者结合起来，计算位移就可以了。 *实现原理** 原理其实很简单，就是两张图的叠加。底部一张清晰的图，上面一个高斯模糊过的图，将高斯模糊的图当作上层元素的背景，利用背景定位使其只显示一部分，然后把这个高斯模糊的窗口放置在高清图的上层，背景图片的位置与下面的图片位置一致，这样看起来就像一张高清的图片打上了马赛克一样。讲起来不是很清楚，大家可以看一下代码。 基础版本HTML1234567891011121314151617181920212223242526272829303132333435&lt;style type=&quot;text/css&quot;&gt; #css_box &#123; position: relative; width: 100%; height: 500px; background: url(&apos;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1567844929804&amp;di=75928af77a3db7ff54cd4eab49361bc0&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fblog%2F201307%2F19%2F20130719082039_k2NHG.jpeg&apos;) no-repeat; &#125; #css_target &#123; position: absolute; left: 0px; top: 0px; width: 200px; height: 200px; background: inherit; filter: blur(10px); /* 继承父元素的background属性 */ &#125;&lt;/style&gt;&lt;div class=&quot;demo post white-box article-type-post&quot;&gt; &lt;div id=&quot;css_box&quot;&gt; &lt;div id=&quot;css_target&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var bar = document.getElementById(&quot;css_box&quot;); var target = document.getElementById(&quot;css_target&quot;); startDrag(bar, target, function(x, y) &#123; target.style.backgroundPosition = (-1 * x) + &quot;px &quot; + (-1 * y) + &quot;px&quot;; &#125;);&lt;/script&gt; JS (当作JS文件引入)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586var getCss = function(o, key) &#123; return o.currentStyle ? o.currentStyle[key] : document.defaultView.getComputedStyle(o, false)[key];&#125;;// 拖拽var startDrag = function(bar, target, callback) &#123; maxX = parseInt(getCss(bar, &quot;width&quot;)) - parseInt(getCss(target, &quot;width&quot;)); maxY = parseInt(getCss(bar, &quot;height&quot;)) - parseInt(getCss(target, &quot;height&quot;)); var resX = 0, resY = 0; var params = &#123; left: 0, top: 0, currentX: 0, currentY: 0, flag: false &#125;; if (getCss(target, &quot;left&quot;) !== &quot;auto&quot;) &#123; params.left = getCss(target, &quot;left&quot;); &#125; if (getCss(target, &quot;top&quot;) !== &quot;auto&quot;) &#123; params.top = getCss(target, &quot;top&quot;); &#125; target.onmousedown = function(event) &#123; params.flag = true; if (!event) &#123; event = window.event; bar.onselectstart = function() &#123; return false; &#125; &#125; var e = event; params.currentX = e.clientX; params.currentY = e.clientY; &#125;; document.onmouseup = function() &#123; params.flag = false; if (getCss(target, &quot;left&quot;) !== &quot;auto&quot;) &#123; params.left = getCss(target, &quot;left&quot;); &#125; if (getCss(target, &quot;top&quot;) !== &quot;auto&quot;) &#123; params.top = getCss(target, &quot;top&quot;); &#125; &#125;; document.onmousemove = function(event) &#123; var e = event ? event : window.event; if (params.flag) &#123; var nowX = e.clientX, nowY = e.clientY; var disX = nowX - params.currentX, disY = nowY - params.currentY; if ((parseInt(params.left) + disX) &gt; maxX) &#123; resX = maxX; &#125; else if ((parseInt(params.left) + disX) &lt; 0) &#123; resX = 0; &#125; else &#123; resX = parseInt(params.left) + disX; &#125; if ((parseInt(params.top) + disY) &gt; maxY) &#123; resY = maxY; &#125; else if ((parseInt(params.top) + disY) &lt; 0) &#123; resY = 0; &#125; else &#123; resY = parseInt(params.top) + disY; &#125; target.style.left = resX + &apos;px&apos; target.style.top = resY + &apos;px&apos; if (typeof callback == &quot;function&quot;) &#123; callback(resX, resY); &#125; if (event.preventDefault) &#123; event.preventDefault(); &#125; return false; &#125; &#125;&#125;; 兼容移动端优化版本HTML12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;style type=&quot;text/css&quot;&gt; #css_box &#123; position: relative; touch-action: none; width: 100%; height: 500px; background: url(&apos;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1567844929804&amp;di=75928af77a3db7ff54cd4eab49361bc0&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fblog%2F201307%2F19%2F20130719082039_k2NHG.jpeg&apos;) no-repeat; background-size: contain; &#125; #css_target &#123; position: absolute; left: 0px; top: 0px; background: inherit; filter: blur(10px); touch-action: none; /* 继承父元素的background属性 */ &#125;&lt;/style&gt;&lt;div class=&quot;demo post white-box article-type-post&quot;&gt; &lt;h2 class=&quot;title&quot;&gt;mosaic Demo &lt;a style=&quot;color: #bd4117;&quot; href=&quot;http://www.zsfmyz.top/Css/Css3%20+%20Js%EF%BC%9A%E5%9B%BE%E7%89%87%E7%9A%84%E5%B1%80%E9%83%A8%E6%A8%A1%E7%B3%8A%EF%BC%88%E9%A9%AC%E8%B5%9B%E5%85%8B%EF%BC%89/&quot;&gt;传送门&lt;/a&gt;&lt;/h2&gt; &lt;div id=&quot;css_box&quot;&gt; &lt;div id=&quot;css_target&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;p id=&quot;position_img&quot;&gt;X: 0 px Y: 0 px&lt;/p&gt;&lt;/div&gt;&lt;script&gt; $(document).ready(function() &#123; var bar = document.getElementById(&quot;css_box&quot;); var target = document.getElementById(&quot;css_target&quot;); var p_img = document.getElementById(&quot;position_img&quot;); // 兼容分辨率 bar.style.height = (parseInt(getCss(bar, &quot;width&quot;)) * 636 / 900) + &apos;px&apos;; target.style.backgroundSize = parseInt(getCss(bar, &quot;width&quot;)) + &apos;px &apos; + (parseInt(getCss(bar, &quot;width&quot;)) * 636 / 900) + &apos;px&apos;; startDrag(bar, target, function(x, y) &#123; target.style.backgroundPosition = (-1 * x) + &quot;px &quot; + (-1 * y) + &quot;px&quot;; p_img.innerText = &quot;X: &quot; + target.style.left + &quot; Y: &quot; + target.style.top; &#125;);&#125;)&lt;/script&gt; JS (当作JS文件引入)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118&lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 拖拽 var startDrag = function(bar, target, callback) &#123; var getCss = function(o, key) &#123; return o.currentStyle ? o.currentStyle[key] : document.defaultView.getComputedStyle(o, false)[key]; &#125;; var down = function(event) &#123; // 兼容分辨率 bar.style.height = (parseInt(getCss(bar, &quot;width&quot;)) * 636 / 900) + &apos;px&apos;; target.style.backgroundSize = parseInt(getCss(bar, &quot;width&quot;)) + &apos;px &apos; + (parseInt(getCss(bar, &quot;width&quot;)) * 636 / 900) + &apos;px&apos;; params.flag = true; if (!event) &#123; event = window.event; bar.onselectstart = function() &#123; return false; &#125; &#125; var e = event; params.currentX = e.clientX || e.changedTouches[0].clientX; params.currentY = e.clientY || e.changedTouches[0].clientY; &#125;; var up = function() &#123; params.flag = false; if (getCss(target, &quot;left&quot;) !== &quot;auto&quot;) &#123; params.left = getCss(target, &quot;left&quot;); &#125; if (getCss(target, &quot;top&quot;) !== &quot;auto&quot;) &#123; params.top = getCss(target, &quot;top&quot;); &#125; &#125;; var move = function(event) &#123; var e = event ? event : window.event; if (params.flag) &#123; var nowX = e.clientX || e.changedTouches[0].clientX, nowY = e.clientY || e.changedTouches[0].clientY; var disX = nowX - params.currentX, disY = nowY - params.currentY; if ((parseInt(params.left) + disX) &gt; maxX) &#123; resX = maxX; &#125; else if ((parseInt(params.left) + disX) &lt; 0) &#123; resX = 0; &#125; else &#123; resX = parseInt(params.left) + disX; &#125; if ((parseInt(params.top) + disY) &gt; maxY) &#123; resY = maxY; &#125; else if ((parseInt(params.top) + disY) &lt; 0) &#123; resY = 0; &#125; else &#123; resY = parseInt(params.top) + disY; &#125; target.style.left = resX + &apos;px&apos; target.style.top = resY + &apos;px&apos; if (typeof callback == &quot;function&quot;) &#123; callback(resX, resY); &#125; if (event.preventDefault) &#123; event.preventDefault(); &#125; return false; &#125; &#125; var resX = 0, resY = 0; var params = &#123; left: 0, top: 0, currentX: 0, currentY: 0, flag: false &#125;; if (getCss(target, &quot;left&quot;) !== &quot;auto&quot;) &#123; params.left = getCss(target, &quot;left&quot;); &#125; if (getCss(target, &quot;top&quot;) !== &quot;auto&quot;) &#123; params.top = getCss(target, &quot;top&quot;); &#125; if ((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) &#123; console.log(&quot;mobile&quot;); target.style.width = &apos;100px&apos;; target.style.height = &apos;100px&apos;; maxX = parseInt(getCss(bar, &quot;width&quot;)) - parseInt(getCss(target, &quot;width&quot;)); maxY = parseInt(getCss(bar, &quot;height&quot;)) - parseInt(getCss(target, &quot;height&quot;)); target.ontouchstart = down document.ontouchend = up document.ontouchmove = move &#125; else &#123; console.log(&quot;pc&quot;); target.style.width = &apos;150px&apos;; target.style.height = &apos;150px&apos;; maxX = parseInt(getCss(bar, &quot;width&quot;)) - parseInt(getCss(target, &quot;width&quot;)); maxY = parseInt(getCss(bar, &quot;height&quot;)) - parseInt(getCss(target, &quot;height&quot;)); target.onmousedown = down document.onmouseup = up document.onmousemove = move &#125; &#125;;&lt;/script&gt; 以上就是局部模糊的实现方法。可以直接套用。将JS部分当作文件引入。否则要把初始化函数放在函数声明的后面。 最后可查看实际效果：demo演示地址 借鉴于张大神","categories":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/categories/Css/"}],"tags":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/tags/Css/"}]},{"title":"CSS3：图片的高斯模糊效果","slug":"CSS3：图片的高斯模糊效果","date":"2018-05-18T08:59:13.000Z","updated":"2019-09-20T07:42:48.991Z","comments":true,"path":"Css/CSS3：图片的高斯模糊效果/","link":"","permalink":"http://www.zsfmyz.top/Css/CSS3：图片的高斯模糊效果/","excerpt":"CSS3：图片的高斯模糊效果 最近项目中需要预览视频中加马赛克的效果（高斯模糊），于是找到了css3的一个属性filter来进行高斯模糊","text":"CSS3：图片的高斯模糊效果 最近项目中需要预览视频中加马赛克的效果（高斯模糊），于是找到了css3的一个属性filter来进行高斯模糊 filter（滤镜） 可以用来定义图片或者div的饱和度，模糊程度，亮度等一系列。具体参考 CSS3：filter 属性 兼容性 兼容性方案123//高斯模糊-webkit-filter：blur(10px);filter:blur(10px); 高斯模糊的这个属性是对整个元素进行高斯模糊。如果你需要局部模糊，需要结合背景定位。原理就是两层图片叠加，底层清晰，上层模糊。接下来我会结合拖拽和背景定位实现图片的局部模糊。下一篇传送门：js拖拽实现","categories":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/categories/Css/"}],"tags":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/tags/Css/"}]},{"title":"HTML5 Video 全屏","slug":"HTML5 video 全屏","date":"2018-04-13T10:14:27.000Z","updated":"2019-09-20T07:42:49.104Z","comments":true,"path":"JavaScript/HTML5 video 全屏/","link":"","permalink":"http://www.zsfmyz.top/JavaScript/HTML5 video 全屏/","excerpt":"当我们使用video标签的时候，有时候因为更多的需要，我们要自己自定义控制栏，而进入和退出全屏也是其中的一部分 不同的浏览器有不同的实现方法1234567891011// Webkitelement.webkitRequestFullScreen();//进入全屏document.webkitCancelFullScreen();//退出全屏// Firefoxelement.mozRequestFullScreen();document.mozCancelFullScreen(); // W3C element.requestFullscreen();document.exitFullscreen();","text":"当我们使用video标签的时候，有时候因为更多的需要，我们要自己自定义控制栏，而进入和退出全屏也是其中的一部分 不同的浏览器有不同的实现方法1234567891011// Webkitelement.webkitRequestFullScreen();//进入全屏document.webkitCancelFullScreen();//退出全屏// Firefoxelement.mozRequestFullScreen();document.mozCancelFullScreen(); // W3C element.requestFullscreen();document.exitFullscreen(); 一般兼容性写法，我们先使用w3c标准的方法，如果不可以在兼容不同浏览器。 12345678910111213141516171819202122//进入全屏function FullScreen() &#123; var ele = document.documentElement; if (ele .requestFullscreen) &#123; ele .requestFullscreen(); &#125; else if (ele .mozRequestFullScreen) &#123; ele .mozRequestFullScreen(); &#125; else if (ele .webkitRequestFullScreen) &#123; ele .webkitRequestFullScreen(); &#125;&#125;//退出全屏function exitFullscreen() &#123; var de = document; if (de.exitFullscreen) &#123; de.exitFullscreen(); &#125; else if (de.mozCancelFullScreen) &#123; de.mozCancelFullScreen(); &#125; else if (de.webkitCancelFullScreen) &#123; de.webkitCancelFullScreen(); &#125;&#125; 接下来是用例 1234$(ele).on(&apos;click&apos;,function()&#123; FullScreen(); // exitFullscreen();&#125;);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zsfmyz.top/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zsfmyz.top/tags/JavaScript/"}]},{"title":"Angular 的 uiRouter 的 方法$state.includes （判断当前激活路由）","slug":"angular 的 uiRouter 的 方法$state.includes （判断当前激活路由）","date":"2018-02-27T10:08:30.000Z","updated":"2019-09-20T07:42:48.922Z","comments":true,"path":"Angular/angular 的 uiRouter 的 方法$state.includes （判断当前激活路由）/","link":"","permalink":"http://www.zsfmyz.top/Angular/angular 的 uiRouter 的 方法$state.includes （判断当前激活路由）/","excerpt":"angular 的 uiRouter 的 方法$state.includes （判断当前激活路由）作用： 该方法用于判断当前激活的也就是地址栏的路由地址是哪个路由。 比如 $state.includes(‘app’) 那么如果页面地址为“www.baidu.com#/app” 或者 “www.baidu.com#/app/xxx” 的时候，该方法的值会返回true。（一般我们定义的路由和地址栏地址是相互对应的，方便管理。举例也是在app.xxx对应app/xxx这样设置路由的情况下） 如激活的路由为 app.page.page1 那么 123$state.includes(&apos;app&apos;) //返回 true$state.includes(&apos;app.page&apos;) //返回 true$state.includes(&apos;app.page.page1&apos;) //返回 true","text":"angular 的 uiRouter 的 方法$state.includes （判断当前激活路由）作用： 该方法用于判断当前激活的也就是地址栏的路由地址是哪个路由。 比如 $state.includes(‘app’) 那么如果页面地址为“www.baidu.com#/app” 或者 “www.baidu.com#/app/xxx” 的时候，该方法的值会返回true。（一般我们定义的路由和地址栏地址是相互对应的，方便管理。举例也是在app.xxx对应app/xxx这样设置路由的情况下） 如激活的路由为 app.page.page1 那么 123$state.includes(&apos;app&apos;) //返回 true$state.includes(&apos;app.page&apos;) //返回 true$state.includes(&apos;app.page.page1&apos;) //返回 true 用法： 知道了它的作用，接下来看看它的使用背景。 我们可以用来激活当前menu的状态。即使当前路由对应的菜单高亮或激活状态。 举例： 123456789101112131415161718192021&lt;div ng-init=&quot;menu_flag= !($state.includes(&apos;app.page1&apos;) || $state.includes(&apos;app.page2&apos;))&quot;&gt; 主菜单&lt;/div&gt;&lt;div ng-hide=&quot;menu_flag&quot;&gt; &lt;div ng-class=&quot;&#123;active: $state.includes(&apos;app.page1&apos;)&#125;&quot;&gt; &lt;a href=&quot;javascript:;&quot; ui-sref=&quot;app.page1&quot;&gt;子菜单一&lt;/a&gt; &lt;/div&gt; &lt;div ng-class=&quot;&#123;active: $state.includes(&apos;app.page2&apos;)&#125;&quot;&gt; &lt;a href=&quot;javascript:;&quot; ui-sref=&quot;app.page2&quot;&gt;子菜单二&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;// ...... n个类似结构组成的菜单&lt;div ng-init=&quot;menu_flag1= !($state.includes(&apos;app.page3&apos;) || $state.includes(&apos;app.page4&apos;))&quot;&gt; 主菜单&lt;/div&gt;&lt;div ng-hide=&quot;menu_flag1&quot;&gt; &lt;div ng-class=&quot;&#123;active: $state.includes(&apos;app.page3&apos;)&#125;&quot;&gt; &lt;a href=&quot;javascript:;&quot; ui-sref=&quot;app.page1&quot;&gt;子菜单一&lt;/a&gt; &lt;/div&gt; &lt;div ng-class=&quot;&#123;active: $state.includes(&apos;app.page4&apos;)&#125;&quot;&gt; &lt;a href=&quot;javascript:;&quot; ui-sref=&quot;app.page2&quot;&gt;子菜单二&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; 如上我们的菜单构成是由若干个类似结构构成，主menu控制若干个子menu。active是我们定义的激活菜单的css类名，当我们选中某个菜单时激活该菜单。即可借用$state.includes()来实现该功能。 同时，当我们的主menu要控制闭合和展开的话，当我们刷新的时候，我们通过判断($state.includes(&#39;app.page3&#39;) || $state.includes(&#39;app.page4&#39;)) 的值来在刷新之后判断该主菜单是否闭合。 当然我们也可以这样定义我们的路由。当然我们也可以这样定义我们的路由。例如： 一层菜单为 app.menu1 , 该主菜单下路由定义为 路由名称 一级路由定义 二级路由定义 一层菜单 app.menu1 二层菜单 app.menu1.menu1_1 二层菜单 app.menu1.menu1_2 这样的话我们在主菜单闭合上只需要判断 $state.includes(app.menu1) 即可。","categories":[{"name":"Angular","slug":"Angular","permalink":"http://www.zsfmyz.top/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://www.zsfmyz.top/tags/Angular/"}]},{"title":"文本的水平垂直居中","slug":"文本文字在DIV中垂直水平居中显示","date":"2018-01-17T08:59:13.000Z","updated":"2019-09-20T07:42:48.784Z","comments":true,"path":"Css/文本文字在DIV中垂直水平居中显示/","link":"","permalink":"http://www.zsfmyz.top/Css/文本文字在DIV中垂直水平居中显示/","excerpt":"#文字居中 ##垂直居中（vertical-align）我们都知道有这么一个属性可以让图片，文本等在元素中垂直居中1vertical-align:middle; vertical-align值有很多，常用的就是middle，bottom，text-bottom等，我们先说middle。","text":"#文字居中 ##垂直居中（vertical-align）我们都知道有这么一个属性可以让图片，文本等在元素中垂直居中1vertical-align:middle; vertical-align值有很多，常用的就是middle，bottom，text-bottom等，我们先说middle。 vertical-align时而没效果然而真实使用的时候，我们会发现这个属性“时灵时不灵”，有些情况下我们加了这个属性之后仍然不见img或者text有任何的变化。那是因为vertical-align只作用在inline-block或者inline，还有table-cell等元素内。同时这两种还有有所不同。 vertical-align并不是在高度内居中，而是对齐在行高内的middle线上。 所以我总结了两种使用vertical-align居中的方法： 第一种 1234&lt;div style=&quot;vertical-align: middle;display: table-cell;&quot;&gt; &lt;img src=&quot;02.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;文本居中&lt;/p&gt;&lt;/div&gt; 这种情况下图片和文字可以分行显示文字在图片下面同时图片和文字作为整体在元素内垂直居中。 第二种 1234&lt;div style=&quot;height:180px;line-height:180px;&quot;&gt; &lt;img src=&quot;02.jpg&quot; alt=&quot;图片&quot; style=&quot;vertical-align:middle;&quot; /&gt; 这是文本内容.&lt;/div&gt; 这种情况下文字是因为line-height属性而居中，跟vertical-align属性没有关系。同时img对齐在middle线上，但是如果父盒子去掉了line-height属性的话那么将会不起作用。（可以试试bottom和text-bottom的不同。） ##水平居中 1text-align:center; over","categories":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/categories/Css/"}],"tags":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/tags/Css/"}]},{"title":"Angular中ng-Repeat的track by 的使用（$Index）","slug":"angular中ng-repeat的track by 的使用（$index）","date":"2017-11-27T10:14:27.000Z","updated":"2019-09-20T07:42:48.905Z","comments":true,"path":"Angular/angular中ng-repeat的track by 的使用（$index）/","link":"","permalink":"http://www.zsfmyz.top/Angular/angular中ng-repeat的track by 的使用（$index）/","excerpt":"在angular中使用ng-repeat时数组中有重复元素 当我们在循环的数组中存在有重复的元素时候，angular的ng-repeat就会报错，那是因为其不允许collection有相同的id（相同的元素会形成相同的id）出现。而基本的数据类型它的id就是它自身的值。","text":"在angular中使用ng-repeat时数组中有重复元素 当我们在循环的数组中存在有重复的元素时候，angular的ng-repeat就会报错，那是因为其不允许collection有相同的id（相同的元素会形成相同的id）出现。而基本的数据类型它的id就是它自身的值。 我们要避免这种情况通常会使用track by $index 来让其生成自己不同的id，这样是最常用的直接通过索引来生成id。我们也可以通过自己设置业务上的id，然后用其进行遍历track by item.id. 总结一下，解决重复问题的方法就是item in items track by $index 使用$index会出现的问题。 我们使用$index不仅仅是为了避免重复元素的问题，有时候会被使用$index的索引来进行一部分操作，这里有一个坑需要注意。 当我们使用$index的时候，下列情况会出现$index跟原序列不匹配的情况 当我们改变列表的顺序的时候 当我们在列表中插入或者删除的时候 由于$index会跟随item上移下移，或者随之被删除。（例如你把列表第二条和第一条位置互换，这时候列表现在第一条的$index依旧为2，第二条还是原来的1）这时候你再使用$index传值就不在是新数组的索引了，不再匹配。 所以使用$index的时候要特别注意这些问题","categories":[{"name":"Angular","slug":"Angular","permalink":"http://www.zsfmyz.top/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://www.zsfmyz.top/tags/Angular/"}]},{"title":"Angular 的Http请求回调（success 和 Error）","slug":"angular 的http请求回调（success 和 error）","date":"2017-11-27T08:59:13.000Z","updated":"2019-09-20T07:42:48.855Z","comments":true,"path":"Angular/angular 的http请求回调（success 和 error）/","link":"","permalink":"http://www.zsfmyz.top/Angular/angular 的http请求回调（success 和 error）/","excerpt":"前面有文章写过angular的$http请求的简单书写和使用。回顾一下： 12345678910111213141516171819202122232425262728293031var Server = angular.module(&quot;Server&quot;, []);Server.service(&quot;Api&quot;, [&quot;$http&quot;, function ($http) &#123; return &#123; getTest : function (params, callback) &#123; $http(&#123; url: &apos;www.baidu.com?name=xxx&amp;passwd=xxx&apos;, method: &apos;GET&apos; &#125;).success(callback); &#125;, postTest : function (data, callback) &#123; $http(&#123; url: &apos;www.baidu.com&apos;, data: data, method: &apos;POST&apos; &#125;).success(callback); &#125;&#125;]);var App = angular.module(&quot;App&quot;, [ &quot;Server&quot;]);App.controller(&apos;Ctrl&apos;, [&apos;$scope&apos;, &apos;Api&apos;, function($scope, Api) &#123; Api.getTest(&quot;?name=xxx&amp;passwd=xxx&quot;, function(res)&#123; //res为返回值 alert(&quot;请求成功！&quot;) &#125;); Api.postTest(&#123;name: xxx, passwd: xxx&#125;, function(res)&#123; //res为返回值 alert(&quot;请求成功！&quot;) &#125;); &#125;]);","text":"前面有文章写过angular的$http请求的简单书写和使用。回顾一下： 12345678910111213141516171819202122232425262728293031var Server = angular.module(&quot;Server&quot;, []);Server.service(&quot;Api&quot;, [&quot;$http&quot;, function ($http) &#123; return &#123; getTest : function (params, callback) &#123; $http(&#123; url: &apos;www.baidu.com?name=xxx&amp;passwd=xxx&apos;, method: &apos;GET&apos; &#125;).success(callback); &#125;, postTest : function (data, callback) &#123; $http(&#123; url: &apos;www.baidu.com&apos;, data: data, method: &apos;POST&apos; &#125;).success(callback); &#125;&#125;]);var App = angular.module(&quot;App&quot;, [ &quot;Server&quot;]);App.controller(&apos;Ctrl&apos;, [&apos;$scope&apos;, &apos;Api&apos;, function($scope, Api) &#123; Api.getTest(&quot;?name=xxx&amp;passwd=xxx&quot;, function(res)&#123; //res为返回值 alert(&quot;请求成功！&quot;) &#125;); Api.postTest(&#123;name: xxx, passwd: xxx&#125;, function(res)&#123; //res为返回值 alert(&quot;请求成功！&quot;) &#125;); &#125;]); 这里以GET和POST请求为例。首先我们需要在APP中注入Server这个模块，才能使用里面的service服务Api，如上代码所示，注入Server之后我们就可以在控制器Ctl里面注入Api服务，然后使用我们之前定义好的接口。 GET请求中params 代表了？之后的参数，即 params == ‘?name=xxx&amp;passwd=xxx’,这样就可以通过传参的方式把参数加入到地址上，callback是请求成功后的回调，是个function，我们可以在里面打印出请求成功的返回值。 POST请求中data代表请求参数，传入之后直接请求即可，其他跟get请求类似。 error还有一点需要说的是http请求有时候会失败，当我们http请求失败的时候，将不会再调用success回调函数，而是会进入error回调，下面我就写一下http请求的success和error同时存在的写法。 123456789101112131415161718192021222324var Server = angular.module(&quot;Server&quot;, []);Server.service(&quot;Api&quot;, [&quot;$http&quot;, function ($http) &#123; return &#123; getTest : function (params, successCallback, errorCallback) &#123; $http(&#123; url: &apos;www.baidu.com?name=xxx&amp;passwd=xxx&apos;, method: &apos;GET&apos; &#125;).then(successCallback, errorCallback); &#125;&#125;]);var App = angular.module(&quot;App&quot;, [ &quot;Server&quot;]);App.controller(&apos;Ctrl&apos;, [&apos;$scope&apos;, &apos;Api&apos;, function($scope, Api) &#123; Api.getTest(&quot;?name=xxx&amp;passwd=xxx&quot;, function(res)&#123; //res为返回值 alert(&quot;请求成功！&quot;) &#125;, function(res)&#123; //res为返回值 alert(&quot;请求失败！&quot;) &#125;); &#125;]); 用法几乎一样，只不过把success(callback)改成了then(callback1, callback2).然后在调用的时候再加入一个function即可。 最简单的get写法 1234$http(&#123; url: &apos;www.baidu.com?name=xxx&amp;passwd=xxx&apos;, method: &apos;GET&apos; &#125;).success(callback);","categories":[{"name":"Angular","slug":"Angular","permalink":"http://www.zsfmyz.top/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://www.zsfmyz.top/tags/Angular/"}]}]}