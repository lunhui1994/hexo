{"meta":{"title":"Eighteen Blog","subtitle":"Eighteen Blog","description":"好学力行，明德任责。一起分享芝士。","author":"赵十八","url":"http://www.zsfmyz.top","root":"/"},"pages":[{"title":"about","date":"2019-08-27T09:38:13.000Z","updated":"2019-08-27T10:07:48.358Z","comments":true,"path":"about/index.html","permalink":"http://www.zsfmyz.top/about/index.html","excerpt":"","text":"好学力行，明德任责 目前正慢慢从CSDN迁移过来一些。 一个萝卜一个坑儿。 LH_ZSF"},{"title":"我的朋友们","date":"2019-08-28T08:33:59.476Z","updated":"2019-08-28T08:33:59.477Z","comments":true,"path":"friends/index.html","permalink":"http://www.zsfmyz.top/friends/index.html","excerpt":"","text":""},{"title":"","date":"2019-08-28T08:32:13.061Z","updated":"2019-08-28T08:32:13.061Z","comments":true,"path":"mylist/index.html","permalink":"http://www.zsfmyz.top/mylist/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2019-08-28T08:31:41.001Z","updated":"2019-08-28T08:31:41.001Z","comments":true,"path":"categories/index.html","permalink":"http://www.zsfmyz.top/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-08-28T08:32:37.717Z","updated":"2019-08-28T08:32:37.719Z","comments":true,"path":"tags/index.html","permalink":"http://www.zsfmyz.top/tags/index.html","excerpt":"","text":""},{"title":"Demo演示列表","date":"2019-08-27T09:38:13.000Z","updated":"2019-09-03T06:44:53.909Z","comments":true,"path":"demo/index.html","permalink":"http://www.zsfmyz.top/demo/index.html","excerpt":"","text":"Video截图功能实现 font-family字体对照表效果"},{"title":"404 Not Found","date":"2019-08-30T09:13:57.568Z","updated":"2019-08-30T09:13:57.568Z","comments":true,"path":"404.html","permalink":"http://www.zsfmyz.top/404.html","excerpt":"","text":"404 Not Found 很抱歉，您访问的页面不存在可能是输入地址有误或该地址已被删除"}],"posts":[{"title":"Font-Family字体对照表及效果展示","slug":"font-family字体对照表及效果展示","date":"2019-08-30T07:37:09.000Z","updated":"2019-09-03T06:59:00.956Z","comments":true,"path":"Css/font-family字体对照表及效果展示/","link":"","permalink":"http://www.zsfmyz.top/Css/font-family字体对照表及效果展示/","excerpt":"","text":"Demo直接进demo演示页面查看吧。 demo演示地址","categories":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/categories/Css/"}],"tags":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/tags/Css/"}]},{"title":"Video截图功能实现","slug":"Video截图功能实现","date":"2019-08-30T07:37:09.000Z","updated":"2019-08-30T08:28:50.440Z","comments":true,"path":"JavaScript/Video截图功能实现/","link":"","permalink":"http://www.zsfmyz.top/JavaScript/Video截图功能实现/","excerpt":"背景 因为所在公司业务为视频编解码，所以项目大多数是围绕视频展开的，之前做了一个快编项目，可以当作一个web端的小型视频编辑器。当中就需要对视频当前帧图进行截取，然后后续当作视频的封面或者海报图。 那么我就需要实现这么一个视频截图的功能。","text":"背景 因为所在公司业务为视频编解码，所以项目大多数是围绕视频展开的，之前做了一个快编项目，可以当作一个web端的小型视频编辑器。当中就需要对视频当前帧图进行截取，然后后续当作视频的封面或者海报图。 那么我就需要实现这么一个视频截图的功能。 API简介 首先视频截图在我们大前端实现，就要借助canvas的drawImage()这个api了。 drawImage 该api的功能简单讲就是将一张图片(Source image)绘制在canvas(Destination canvas)上. 语法： void ctx.drawImage(image, dx, dy);void ctx.drawImage(image, dx, dy, dWidth, dHeight);void ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight); image： 原图片Element. sx, sy, sWidth, sHeight : 需要在原图取起点x，y，宽，高； dx, dy, dWidth, dHeight：在目标canvas上绘制的起点x，y，宽，高。 image，dx，dy为必填 当我们截取并绘制完图片之后，就需要将在canvas上绘制的图片转化为图片了，那就需要 toDataURL(‘image/png’) 将其转换。 该方法返回一个用作展示的图片地址。 语法： canvas.toDataURL(type, encoderOptions); type: 默认为 image/png， 可选 image/jpeg或者image/webp encoderOptions：当type为 jpeg或者webp 时，可以选择0-1区间内的值作为输出的图片质量。 MDN HTMLCanvasElement.toDataURL() CanvasRenderingContext2D.drawImage() 回到正题，函数实现 代码实现HTML12345&lt;video id=&quot;video&quot; controls=&quot;controls&quot;&gt; &lt;source src=&quot;../videos/xxx.mp4&quot; /&gt;&lt;/video&gt;&lt;button id=&quot;capture&quot;&gt;Capture&lt;/button&gt;&lt;div id=&quot;output&quot;&gt;&lt;/div&gt; Script1234567891011121314151617181920212223242526(function() &#123; var video, $output; var scale = 0.25; var initialize = function() &#123; $output = $(&quot;#output&quot;); video = $(&quot;#video&quot;).get(0); $(&quot;#capture&quot;).click(captureImage); &#125;; var captureImage = function() &#123; var canvas = document.createElement(&quot;canvas&quot;); canvas.width = video.videoWidth * scale; canvas.height = video.videoHeight * scale; canvas.getContext(&apos;2d&apos;).drawImage(video, 0, 0, canvas.width, canvas.height); var img = document.createElement(&quot;img&quot;); img.src = canvas.toDataURL(&apos;image/png&apos;); $output.prepend(img); &#125;; $(initialize);&#125;()); Demodemo演示地址 大家可以用webstrom内置的服务器进行测试。 使用chrome浏览器需要一个服务器环境，否则canvas的toDataURL方法会报错。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zsfmyz.top/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zsfmyz.top/tags/JavaScript/"}]},{"title":"Border-Radius(圆角)失效了？","slug":"border-radius(圆角)失效了？","date":"2019-08-29T02:53:27.000Z","updated":"2019-08-29T02:55:20.099Z","comments":true,"path":"Css/border-radius(圆角)失效了？/","link":"","permalink":"http://www.zsfmyz.top/Css/border-radius(圆角)失效了？/","excerpt":"今天涉及两个属性： overscroll: scroll-y / scroll-x / scroll; border-radius: 10px;","text":"今天涉及两个属性： overscroll: scroll-y / scroll-x / scroll; border-radius: 10px; 原本这两个属性是没有什么联系的，但是当同时出现在同一个元素上时，就会发生圆角效果被滑动条覆盖的情况。例如： 1234567&lt;style&gt; div &#123; border-radius:10px; overflow:scroll-y; &#125;&lt;/style&gt;&lt;div&gt;&lt;/div&gt; 这种情况下，div的右上角和右下角都会因为滚动条的存在而显示的是直角。其实div的四个角确实已经有了圆角的效果，但是滚动条属于div内部的元素，层级高，所以将div的圆角遮挡住了。那么我们解决这种情况的方法也很简单。 123456789101112&lt;style&gt; div &#123; border-radius: 10px; overflow: hidden; &#125; ul &#123; overflow: scroll-y; &#125;&lt;/style&gt;&lt;div&gt; &lt;ul&gt;&lt;/ul&gt;&lt;/div&gt; 我们在原本需要滚动的盒子内部加上一层滚动元素，将滚动的效果放在内部的滚动元素上，外部div加上overflow: hidden;并设置圆角，就可以达到我们需要的效果。 同样的我们也可以在当前元素的外层加上圆角遮罩，最终效果同上。 如有其他情况欢迎补充","categories":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/categories/Css/"}],"tags":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/tags/Css/"}]},{"title":"Z-Index失效了？","slug":"z-index失效了？ ","date":"2019-08-27T10:14:27.000Z","updated":"2019-08-30T09:36:48.328Z","comments":true,"path":"Css/z-index失效了？ /","link":"","permalink":"http://www.zsfmyz.top/Css/z-index失效了？ /","excerpt":"背景 我们在使用z-index的时候，有时候会发现，无论怎么样增大z-index的值，都无法改变目标元素的层级。 其实是这几种情况在作怪 position float opcity","text":"背景 我们在使用z-index的时候，有时候会发现，无论怎么样增大z-index的值，都无法改变目标元素的层级。 其实是这几种情况在作怪 position float opcity 父盒子的层级问题 父盒子的层级问题，当你的父盒子层级小于另一个父盒子层级的时候，你子元素的z-index再高都是没有用的。该元素的层级只在该元素所在的容器内起作用。该种情况大家应该容易理解，不过也可以看下面的例子。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;style type=&quot;text/css&quot;&gt; .a1&#123; position:relative; z-index: 2; width:400px; height:400px; background: black; border:1px solid #eee; margin-bottom: -100px; &#125; .a&#123; position:relative; z-index: 1; width:400px; height:400px; background: yellow; left:0; border:1px solid #eee; &#125; .b&#123; position:absolute; left:0; top:0; z-index: 50; width:200px; height:200px; background: red; &#125; .c&#123; position: absolute; left:0; top:0; z-index:1111; width:100px; height:100px; background: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;a1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;a&quot;&gt; &lt;div class=&quot;b&quot;&gt;&lt;/div&gt; &lt;div class=&quot;c&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt; opcity属性 opcity属性，当你要设置两个元素的z-index值的时候，要注意是否给其中一个元素添加了opcity属性，如果添加了，那么添加了opcity属性的元素将一直在最上层，这个我在另一篇文章中讲过。 opcity引发的元素层级变化 position影响 还有就是比较普遍的，我们设置层级一般都是因为设置了position，当你设置的两个子元素，一个有position属性，另一个没有position的时候，拥有position属性的元素将一直在其他元素上方。如下面的例子 123456789101112131415161718192021222324252627282930313233343536&lt;style type=&quot;text/css&quot;&gt; .a&#123; position:relative; z-index: 1; width:400px; height:400px; background: yellow; left:0; border:1px solid #eee; &#125; .b&#123; position:absolute; left:0; top:0; z-index: 50; width:200px; height:200px; background: red; &#125; .c&#123; z-index:100; width:100px; height:100px; background: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;a&quot;&gt; &lt;div class=&quot;b&quot;&gt;&lt;/div&gt; &lt;div class=&quot;c&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt; 需要给c也加上position属性才让bc可以先同处一级，然后z-index才会起作用。 float影响 那如果我把子元素的position都去掉呢？当父盒子有position而所有子元素都没有position属性的时候，z-index一样全部失效，后面的盒子将会覆盖前面的盒子，z-index无效。 同样的我们两个都加上浮动的效果跟上面的效果是一样的，后覆盖前，z-index无效 一个加float另一个不加，则是加float的元素一直浮动在最上层。 12345678910111213141516171819202122232425262728293031323334&lt;style type=&quot;text/css&quot;&gt; .a&#123; position:absolute; z-index: 1; width:400px; height:400px; background: yellow; left:0; border:1px solid #eee; &#125; .b&#123; z-index: -10; width:200px; height:200px; background: red; margin-bottom: -100px; &#125; .c&#123; z-index:101; width:100px; height:100px; background: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;a&quot;&gt; &lt;div class=&quot;b&quot;&gt;&lt;/div&gt; &lt;div class=&quot;c&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt; 其他情况欢迎补充。","categories":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/categories/Css/"}],"tags":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/tags/Css/"}]},{"title":"Hexo搭建配置总结","slug":"Hexo搭建配置总结","date":"2019-08-27T10:14:27.000Z","updated":"2019-08-30T10:22:56.253Z","comments":true,"path":"Hexo/Hexo搭建配置总结/","link":"","permalink":"http://www.zsfmyz.top/Hexo/Hexo搭建配置总结/","excerpt":"","text":"主题是material-x Hexo添加Favicon根目录_config.yml 根目录为public的时候,图片放在source下面的img里面就可以，没有的话创建个img文件夹。 https://www.xxx.com/img/favicon.ico ```12345678### Hexo 添加百度统计1. 首先肯定是要去百度统计注册一下了。。[百度统计](https://tongji.baidu.com/web/)注册完成之后生成统计代码，备用。2. 在**主题配置文件_config.yml**里面添加一行``` # Analytics cnzz: true 找到 \\hexo\\themes\\pacman\\layout_partial,在这个文件夹中创建一个cnzz.ejs的文件然后将下面内容复制进去，记得替换中间的script 1234567891011 &lt;% if (theme.cnzz)&#123; %&gt;&lt;!-- 将中间这一块script替换成你的统计代码 --&gt;&lt;script type=&quot;text/javascript&quot;&gt; var cnzz_protocol = ((&quot;https:&quot; == document.location.protocol) ? &quot; https://&quot;: &quot; http://&quot;); document.write(unescape(&quot;%3Cspan id=&apos;cnzz_stat_icon_1000543074&apos;%3E%3C/span%3E%3Cscript src=&apos;&quot; + cnzz_protocol + &quot;s19.cnzz.com/z_stat.php%3Fid%3D1000543074%26show%3Dpic&apos; type=&apos;text/javascript&apos;%3E%3C/script%3E&quot;));&lt;/script&gt;&lt;% &#125; %&gt; 在 \\hexo\\themes\\pacman\\layout_partial\\footer.ejs中加一行下面的代码，然后就结束了。重启生效就可以了。然后在百度中心检测代码有没有安装成功，生效了就可以看报告了。这个过程需要一定的时间。 1&lt;%- partial(&apos;cnzz&apos;) %&gt; Hexo RSS订阅 进入hexo目录 1npm install hexo-generator-feed 根目录_config.yml中添加 12345678#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed:type: atompath: atom.xmllimit: 20 主题目录下_config.yml中添加1rss: /atom.xml Hexo 网站地图 添加sitemap 12npm install hexo-generator-sitemap --save #sitemap.xml适合提交给谷歌搜素引擎npm install hexo-generator-baidu-sitemap --save #baidusitemap.xml适合提交百度搜索引擎 然后在站点配置文件_config.yml中添加以下代码 自动生成sitemap,在根目录_config.yml中添加 sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 最后修改根目录_config.yml中的url url: http://你的网站 然后hexo g, 会在/public目录下生成sitemap.xml和baidusitemap.xml 网站地图。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.zsfmyz.top/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.zsfmyz.top/tags/Hexo/"}]},{"title":"V-Model","slug":"v-model","date":"2019-08-26T08:59:13.000Z","updated":"2019-08-29T10:25:50.222Z","comments":true,"path":"Vue/v-model/","link":"","permalink":"http://www.zsfmyz.top/Vue/v-model/","excerpt":"最近学习vue，从最基础的文档看起。到目前基础已经看完。有两个问题很迷茫。 vue的动态参数（2.6新增）。demo一直报错。分析原因是因为vue不允许动态添加根一级的变量。（不理解） 组件中v-model的使用文档中说的让我有点绕。不过已经顺过来了，所以来分享一下。","text":"最近学习vue，从最基础的文档看起。到目前基础已经看完。有两个问题很迷茫。 vue的动态参数（2.6新增）。demo一直报错。分析原因是因为vue不允许动态添加根一级的变量。（不理解） 组件中v-model的使用文档中说的让我有点绕。不过已经顺过来了，所以来分享一下。 官方给出的例子是这样。(可以直接使用)1234567891011121314HTML:&lt;custom-input v-model=&quot;searchText&quot;&gt;&lt;/custom-input&gt;JS:Vue.component(&apos;custom-input&apos;, &#123; props: [&apos;value&apos;], template: ` &lt;input v-bind:value=&quot;value&quot; v-on:input=&quot;$emit(&apos;input&apos;, $event.target.value)&quot; &gt; `&#125;) v-model可以改写为这种形式，两者完全等价。1234567&lt;input v-model=&quot;searchText&quot;&gt;等价于：&lt;input v-bind:value=&quot;searchText&quot; v-on:input=&quot;searchText = $event.target.value&quot;&gt; //（ $event.target.value为事件当前目标上的value值。） 第二种写法： 在input上绑定了input事件，通过触发input事件，执行给searchText赋值语句。 v-bind将searchText赋值给input标签的value属性。 再看官方的例子：1&lt;custom-input v-model=&quot;searchText&quot;&gt;&lt;/custom-input&gt; 等价于：1234&lt;custom-input v-bind:value=&quot;searchText&quot; v-on:input=&quot;searchText = $event&quot; //$event 为组件内部抛出来的值。（这个如果不明白可以看组件的自定义事件部分）&gt;&lt;/custom-input&gt; 再加上官方的js写法： 123456789Vue.component(&apos;custom-input&apos;, &#123; props: [&apos;value&apos;], template: ` &lt;input v-bind:value=&quot;value&quot; v-on:input=&quot;$emit(&apos;input&apos;, $event.target.value)&quot; &gt; `&#125;) 我们在组件内的input上监听了input事件，并且用该input事件对组件上的（自定义）input事件进行触发（searchText = $event”）； 将$ event.target.value作为参数传给 v-on:input=”searchText = $ event “，$ event === $ event.target.value。执行语句searchText被赋值。 组件上的v-bind:value = “searchText” 是将searchText的值绑定到组件内部的props里的value上。 组件内部将props中的value 绑定到input的value上。就这样完成了一次双向绑定。 而根据官方v-model的两种写法，组件上转换回v-modal的写法。就完成了。最终结果就如开头所示。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://www.zsfmyz.top/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.zsfmyz.top/tags/Vue/"}]},{"title":"Leetcode_2. 两数相加","slug":"leetcode_2. 两数相加","date":"2019-06-27T09:59:13.000Z","updated":"2019-08-28T09:49:21.395Z","comments":true,"path":"Algorithm/leetcode_2. 两数相加/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/leetcode_2. 两数相加/","excerpt":"给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出：7 -&gt; 0 -&gt; 8 原因：342 + 465 = 807","text":"给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出：7 -&gt; 0 -&gt; 8 原因：342 + 465 = 807 题目解析： 该题给出两个链表，求出两个链表各个结点的和，那首先我们需要知道链表是什么样子。 1234567/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; */ 如上，链表的每个结点就是这个样子，next指向下一个结点，当然这是在js中简单的实现了链表。 然后知道了链表，那么就开始各位相加吧~，这个题唯一的难点就是在于各个结点相加的时候可能会产生进位。比如9+2=11，那么就需要进一位，本位取10的余数为值，然后我们就需要在下一个结点相加时把前两位可能产生的进位也算进去。 如下是我的js解答： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; l1 * @param &#123;ListNode&#125; l2 * @return &#123;ListNode&#125; * y 为进位值 * i 代表和的位 * n 代表了和的每一位的值 * arr 代表和（我们用数组表示更方便一点） */var addTwoNumbers = function(l1, l2) &#123; var arr = [], i = 0, n = 0, y = 0; //初始化 //因为链表不一定同样长的，所以只要有一个链表的结点不为空，我们都需要继续计算；同时我们也要考虑进位，即使两个链表结束了，如果有进位的话，那我们还是需要再计算一次的。 while (l1 !== null || l2 !== null || y !== 0) &#123; l1 = l1 ? l1 : new ListNode(0); //判断链表l1的该结点是否为null，如果为null初始化成值为0的结点，方便运算。 l2 = l2 ? l2 : new ListNode(0); // 同理 var num = l1.val + l2.val + y; // 计算该位的两个结点的和，同时要加上前两位的进位。 num &gt; 9 ? (y = 1, n = num - 10) : (n = num, y = 0); // 判断该位是否需要进位，需要进位的话就该位取10的余数，然后进一位（y = 1），反之初始化进位值为0。 arr[i] = n; //给和的每一位赋值 i++; //进入下一次循环 l1 = l1.next; // 进入l1下一个结点 l2 = l2.next; // 进入l2下一个结点 &#125; arr = arr.reverse(); //这里反转一下，原本是[7, 0, 8]反转为[8, 0, 7],方便后面生成链表。 let listNode = new ListNode(arr.shift()) //取第一个值创建第一个结点（是最终链表的最后一个结点） return arr.reduce((ori,cur)=&gt;&#123; let ln = new ListNode(cur) //生成当前结点 ln.next = ori //将当前结点的next指向之前生成的链表的第一个结点 return ln //返回新的链表（赋值给了 ori ） &#125;,listNode)// listNode是初始值。即链表末端的第一个值，我们之所以从最后一个开始创建链表也是因为方便。因为我们要操作结点的next，所以将新结点的next指向原来的链表，要比找到链表的最后一个结点的next指向新结点要方便一些。&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"完全背包问题","slug":"完全背包问题","date":"2019-04-30T07:10:03.000Z","updated":"2019-09-03T06:54:17.778Z","comments":true,"path":"Algorithm/完全背包问题/","link":"","permalink":"http://www.zsfmyz.top/Algorithm/完全背包问题/","excerpt":"题目描述 这里借用一个题目的描述来说明要解决问题的背景。 LiYuxiang是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同种类的草药，采每一种都需要一些时间，每一种也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。” 如果你是LiYuxiang，你能完成这个任务吗？ 此题和原题的不同点： 1.每种草药可以无限制地疯狂采摘。 2.药的种类眼花缭乱，采药时间好长好长啊！师傅等得菊花都谢了！ 一、 什么是背包算法背包算法的基础标准描述为：当前有N件商品，每件商品都有不同的价值v和重量w。我们要把这些商品放在容量为L的背包中，实现背包中的价值最大化。（第i件商品的价值为v[i]，重量为w[i])。上面的题目中的条件之一：草药无限（每件商品可以重复放入背包）即表明了该问题是完全背包问题。","text":"题目描述 这里借用一个题目的描述来说明要解决问题的背景。 LiYuxiang是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同种类的草药，采每一种都需要一些时间，每一种也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。” 如果你是LiYuxiang，你能完成这个任务吗？ 此题和原题的不同点： 1.每种草药可以无限制地疯狂采摘。 2.药的种类眼花缭乱，采药时间好长好长啊！师傅等得菊花都谢了！ 一、 什么是背包算法背包算法的基础标准描述为：当前有N件商品，每件商品都有不同的价值v和重量w。我们要把这些商品放在容量为L的背包中，实现背包中的价值最大化。（第i件商品的价值为v[i]，重量为w[i])。上面的题目中的条件之一：草药无限（每件商品可以重复放入背包）即表明了该问题是完全背包问题。 二、 背包算法的应用背包算法在我看来是一种“性价比”算法。即我们在有限的条件下得到最大的收获。例如曾经有个节目可以让嘉宾在有限的时间内选购满满购物车的货品。这个场景及其符合背包算法。或者例如我们在考试的时侯，都会尽可能的选择简单并且分数又多的题先做。同时我们也可以应用到其他问题上去。比如在选择购买多种原材料时，尽可能的缩小原材料成本。投资时对多种投资产品的选择组合。 三、 背包算法的原理背包问题需要用到动态规划算法。当我们装一个商品的时侯需要判断几个条件： 该商品的重量和背包大小的关系。如果背包的总容量小于商品的重量，那就GG，根本不用考虑了。 商品的重量小于背包剩余容量。即背包中之前装入的商品不需要拿出来就可以把当前商品装下，那也不用考虑，直接装就好了。 商品的重量小于背包总容量，但是剩余空间不够装了。那我们就需要考虑衡量一下，拿出来原有的一部分商品，装入现在的商品是不是划算的。 从上面的三个条件可以看出最重要的就是第三条，我们需要判断价值。假设我们背包可以装8kg东西，现在有三个商品（商品都是以袋为单位销售不可拆分）： 苹果 香蕉 草莓 3kg 2kg 5kg ￥45 ￥20 ￥150 我们以1kg为单位打表:第一次打表 0kg 1kg 2kg 3kg 4kg 5kg 6kg 7kg 8kg 无 0 0 0 0 0 0 0 0 0 苹果 0 0 0 ￥45 ￥45 ￥45 ￥90 ￥90 ￥90 香蕉 0 0 0 0 0 0 0 0 0 草莓 0 0 0 0 0 0 0 0 0 第二次打表 0kg 1kg 2kg 3kg 4kg 5kg 6kg 7kg 8kg 无 0 0 0 0 0 0 0 0 0 苹果 0 0 0 ￥45 ￥45 ￥45 ￥90 ￥90 ￥90 香蕉 0 0 ￥20 ￥45 ￥45 ￥65 ￥90 ￥90 ￥110 草莓 0 0 0 0 0 0 0 0 0 最终打表结果： 0kg 1kg 2kg 3kg 4kg 5kg 6kg 7kg 8kg 无 0 0 0 0 0 0 0 0 0 苹果 0 0 0 ￥45 ￥45 ￥45 ￥90 ￥90 ￥90 香蕉 0 0 ￥20 ￥45 ￥45 ￥65 ￥90 ￥90 ￥110 草莓 0 0 ￥20 ￥45 ￥45 ￥150 ￥150 ￥170 ￥195 如表我们的最终排列结果。 核心判断为：bag[i-1][j] 和bag[i-1][j-k*w[i]] + k*v[i] 的价值哪个大。我来说明上面的变量都代表了什么： bag[i][j] 代表了我们在看到第i个商品时，背包容量占用了jkg时，背包内物品的价值。 那么bag[i-1][j] 就代表了我们在看到第i-1个商品时，背包容量占用了jkg时，背包内装的价值。 v[i]代表了当前商品的价值，k*v[i]代表了k个v[i]的价值（商品不限量）。 w[i]代表了当前商品的重量，k*w[i]代表了k个w[i]的重量。 bag[i-1][j-k*w[i]]就代表了上一个情况下，背包装了k个i商品时，余下空间在上一状态的最大价值。 所以，我们的核心判断种需要 上一个情况下的背包的所有状态。当我们把背包中 k*w[i]的空间腾出来用来装k个i商品，加上剩余空间可以装的商品的最大价值。如果它小于上一个状态下bag[i-1][j]所装货品的价值，那么我们就没必要替换这部分空间了。 12345678910//两个循环for (3) //3个商品 for (8) // 8种占用空间的情况（1kg-8kg）// 核心判断if (bag[i-1][j] &gt; bag[i-1][j-k*w[i]] + k*v[i]) &#123; bag[i][j] = bag[i-1][j];&#125; else &#123; bag[i][j] = bag[i-1][j-k*w[i]] + k*v[i];&#125; 其实回到生活上，我们的想法跟这个是一样的，当我们有个背包要装满的时侯，我们先看到了苹果，那么当然的，我们要尽可能多的把苹果装到包包里。如果有剩余空间装不下那也只能浪费着。然后我们发现了香蕉，我们会开始想着怎么用香蕉代替一部分苹果把空间填满。在这个思考的过程中，我们会一直比较什么样的组合价值最大。草莓也是一样。 其实如开头所说，我说这是“性价比”。上面我们商品出现的顺序是随机的。其实我们装东西判断价值，其实就是装性价比最高的物品。 不过同时需要考虑到空间的利用率。如果我们事先把性价比高的物品排在前面，那么效率会提高不少。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zsfmyz.top/tags/Algorithm/"}]},{"title":"ES6 对象数组查找某一个对象 findIndex","slug":"ES6 对象数组查找某一个对象 findIndex","date":"2019-01-27T09:50:34.000Z","updated":"2019-08-28T10:17:57.575Z","comments":true,"path":"JavaScript/ES6 对象数组查找某一个对象 findIndex/","link":"","permalink":"http://www.zsfmyz.top/JavaScript/ES6 对象数组查找某一个对象 findIndex/","excerpt":"查找数组特定元素需要用到的方法就是findIndex()。 用法与定义 findIndex() 方法返回传入一个测试条件（函数）符合条件的数组第一个元素位置。 findIndex() 方法为数组中的每个元素都调用一次函数执行： 当数组中的元素在测试条件时返回 true 时, findIndex() 返回符合条件的元素的索引位置，之后的值不会再调用 执行函数。如果没有符合条件的元素返回 -1","text":"查找数组特定元素需要用到的方法就是findIndex()。 用法与定义 findIndex() 方法返回传入一个测试条件（函数）符合条件的数组第一个元素位置。 findIndex() 方法为数组中的每个元素都调用一次函数执行： 当数组中的元素在测试条件时返回 true 时, findIndex() 返回符合条件的元素的索引位置，之后的值不会再调用 执行函数。如果没有符合条件的元素返回 -1 以上是比较官方的对于findIndex()的定义 接下来我结合实例来进行自己的解释. 第一条的意思如下:当条件函数返回true的时候，findindex会跳出，然后返回当前元素的下标。123456789101112131415161718192021222324252627282930//首先是普通数组var dataArr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];function fn(num, numIndex, nums)&#123; //该函数的三个参数，num代表当前项，numIndex代表当前项下标，nums代表该数组。 return num &gt; 5;&#125;dataArr.findIndex(fn);//值为5(即6的下标)------------------------分割线-----------------------------//同样的假如你的数组是个对象数组：var objArr = [&#123; name: &apos;小王&apos;, age: 14&#125;,&#123; name: &apos;大王&apos;, age: 41&#125;,&#123; name: &apos;老王&apos;, age: 61&#125;] function objFn(obj, objIndex, objs)&#123; return num.age &gt; 20;&#125;objArr .findIndex(objFn);//值为1(即大王的下标) 第二条的意思就更好理解了，因为findindex只返回第一个符合条件的元素下标，所以在找到第一个符合条件的元素之后，他会跳出该函数，之后的数组内的元素将不再调用，相当于加了个break； 实际用法举例 假如我们要在所有人里面挑选队友，但是不想重复。在我们通过id查找的时候，就可以这么写12345678910111213141516171819202122232425var allPeple = [&#123; name: &apos;小王&apos;, id: 14&#125;,&#123; name: &apos;大王&apos;, id: 41&#125;,&#123; name: &apos;老王&apos;, id: 61&#125;] var myTeamArr = [&#123; name: &apos;小王&apos;, id: 14&#125;] var PId = 14; //假如这个是要添加的人的IDfunction pFn(p)&#123;return p.id == PId ;&#125;//判断myteam里是不是有这个队员，如果==-1 代表没有，在allPeople中找到他，添加入我的队伍myTeamArr.findIndex(pFn) == -1 ? myTeamArr.push(allPeple.find(pFn)) : alert(&apos;已存在该人员&apos;);//这样写可以将两个for循环直接总结成一行代码 另外需要补充的一点 与其相对应的有find()函数，用法一致，只不过返回的是元素本身，而不是元素的下标。 兼容性 因为是es6的所以使用的时候要注意兼容性问题，ie11及之前的版本都不可兼容。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zsfmyz.top/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zsfmyz.top/tags/JavaScript/"}]},{"title":"Call，apply，bind的区别及实现","slug":"call，apply，bind的区别及实现","date":"2019-01-11T07:10:03.000Z","updated":"2019-08-28T10:13:04.908Z","comments":true,"path":"JavaScript/call，apply，bind的区别及实现/","link":"","permalink":"http://www.zsfmyz.top/JavaScript/call，apply，bind的区别及实现/","excerpt":"call，apply，bind的区别这三个函数的左右都是为了指定当前的this。 不同点： call，apply 两者都是对函数的直接调用，bind的返回值仍然是一个函数。 举例：a.call(b) 或者 a.apply(b) 而bind需要 a.bind(b)()这样才能执行 call和apply的传参方式不同，第一个值都是this的指向，第二个举例","text":"call，apply，bind的区别这三个函数的左右都是为了指定当前的this。 不同点： call，apply 两者都是对函数的直接调用，bind的返回值仍然是一个函数。 举例：a.call(b) 或者 a.apply(b) 而bind需要 a.bind(b)()这样才能执行 call和apply的传参方式不同，第一个值都是this的指向，第二个举例 123456a.call(b, 参数1，参数2，参数3)a.apply(b, [参数1，参数2，参数3])//同样的bind的传参方式和call相同，但又因为bind返回的是函数，所以我们可以像正常函数传参一样a.bind(b)(参数1，参数2，参数3) 以上就是三者的差别。 接下来我们实现他们的功能函数。 call： call的传入参数是（ctx,…[]） 1234567891011Function.prototype.mycall = funciton (ctx) &#123; if (typeof this != &quot;function&quot;) &#123; throw new TypeError(&apos;error&apos;); &#125; ctx = ctx || window; ctx.fn = this; var args = ...arguments.splice(1); var result = ctx.fn(args); delete ctx.fn; return result;&#125; apply: apply的传入参数跟call不同，第二个参数是数组。 1234567891011121314Function.prototype.myapply = funciton (ctx) &#123; if (typeof this != &apos;function&apos;) &#123; throw new TypeError(&apos;error&apos;); &#125; ctx = ctx || window; ctx.fn = this; var result; if (arguments[1]) &#123; result = ctx.fn(arguments[1]); &#125; else &#123; result = ctx.fn(); &#125; return result;&#125; bind 返回的是个函数 bind 返回的是个函数，同样可以执行传参 ，我们可以用myapply实现 12345Funtion.prototype.myBind = function(ctx,...args1)&#123; return (...args2) =&gt; &#123; this.myapply(ctx, args1.concat(args2)) &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zsfmyz.top/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zsfmyz.top/tags/JavaScript/"}]},{"title":"Opcity引发的元素层级变化","slug":"Opcity引发的元素层级变化","date":"2018-06-29T10:14:27.000Z","updated":"2019-08-30T08:34:02.841Z","comments":true,"path":"Css/Opcity引发的元素层级变化/","link":"","permalink":"http://www.zsfmyz.top/Css/Opcity引发的元素层级变化/","excerpt":"背景 发现这个问题是在图片上定位了一个删除按钮，当我用opcity属性对图片进行透明化处理的时候，发现删除按钮不管用了，最后发现删除按钮是被图片覆盖了，究其原因是因为opcity这个属性造成的层级变化。 我发现含有opcity属性的元素层级会比其他元素的层级高，这时候z-index是不起作用的，opcity会一直高于其他元素的层级。 给其他元素加上position属性，会使该元素跟opcity处在同一层级之上，这时候你再给元素附加z-index就可以起作用了。","text":"背景 发现这个问题是在图片上定位了一个删除按钮，当我用opcity属性对图片进行透明化处理的时候，发现删除按钮不管用了，最后发现删除按钮是被图片覆盖了，究其原因是因为opcity这个属性造成的层级变化。 我发现含有opcity属性的元素层级会比其他元素的层级高，这时候z-index是不起作用的，opcity会一直高于其他元素的层级。 给其他元素加上position属性，会使该元素跟opcity处在同一层级之上，这时候你再给元素附加z-index就可以起作用了。 总结和解决方案 总结：当你使用opcity的时候会对元素层级造成影响 解决办法：加上position和z-index可以对opcity元素进行覆盖 1234567891011121314151617181920212223.box&#123; width: 200px; height: 200px; background-color: red; color: #fff; cursor: pointer; &#125; .box1&#123; opacity: 0.8; &#125; .box2&#123; background-color: blue; margin-left: 30px; margin-top: -160px; position: relative; z-index: 100; &#125; .box3&#123; background-color: green; margin-left: 60px; margin-top: -160px; opacity: 0.7; &#125; 如上：box2的层级是最高的。","categories":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/categories/Css/"}],"tags":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/tags/Css/"}]},{"title":"Linux压缩命令常用：tar，tgz，gzip，zip","slug":"linux压缩命令常用：tar，tgz，gzip，zip","date":"2018-06-02T10:14:27.000Z","updated":"2019-08-28T10:17:47.425Z","comments":true,"path":"Linux/linux压缩命令常用：tar，tgz，gzip，zip/","link":"","permalink":"http://www.zsfmyz.top/Linux/linux压缩命令常用：tar，tgz，gzip，zip/","excerpt":"linux压缩命令常用的有三个：tar，tgz，gzip，zip","text":"linux压缩命令常用的有三个：tar，tgz，gzip，zip 一，tar（一） tar压缩命令 12345678910tar -cvf examples.tar files|dir#说明：-c, --create create a new archive 创建一个归档文件-v, --verbose verbosely list files processed 显示创建归档文件的进程-f, --file=ARCHIVE use archive file or device ARCHIVE 后面要立刻接被处理的档案名,比如--file=examples.tar#举例：tar -cvf file.tar file1 #file1文件tar -cvf file.tar file1 file2 #file1，file2文件tar -cvf file.tar dir #dir目录 （二） tar 解压命令 123456789tar -xvf examples.tar （解压至当前目录下）tar -xvf examples.tar -C /path (/path 解压至其它路径)#说明：-x, --extract, extract files from an archive 从一个归档文件中提取文件#举例：tar -xvf file.tartar -xvf file.tar -C /temp #解压到temp目录下 二，tgz（一） tgz压缩命令（tar.gz,tgz格式是相同的，命名不同而已） 1234567tar -zcvf examples.tgz examples (examples当前执行路径下的目录)说明：-z, --gzip filter the archive through gzip 通过gzip压缩的形式对文件进行归档举例：tar -zcvf file.tgz dir #dir目录 （二） tgz 解压命令 123456tar -zxvf examples.tar （解压至当前执行目录下）tar -zxvf examples.tar -C /path (/path 解压至其它路径)举例：tar -zcvf file.tgztar -zcvf file.tgz -C /temp 三，gzip（一）gzip压缩： 1gzip -d examples.gz examples （二）gzip解压： 1gunzip examples.gz 四，zip zip 格式是开放且免费的，所以广泛使用在 Windows、Linux、MacOS 平台，要说 zip有什么缺点的话，就是它的压缩率并不是很高，不如 rar及 tar.gz 等格式。 压缩： 1zip -r examples.zip examples (examples为目录) 解压： 1zip examples.zip 六 .rar压缩： 1rar -a examples.rar examples 解压： 1rar -x examples.rar","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.zsfmyz.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.zsfmyz.top/tags/Linux/"}]},{"title":"HTML5 Video 全屏","slug":"HTML5 video 全屏","date":"2018-04-13T10:14:27.000Z","updated":"2019-08-28T10:13:04.796Z","comments":true,"path":"JavaScript/HTML5 video 全屏/","link":"","permalink":"http://www.zsfmyz.top/JavaScript/HTML5 video 全屏/","excerpt":"当我们使用video标签的时候，有时候因为更多的需要，我们要自己自定义控制栏，而进入和退出全屏也是其中的一部分 不同的浏览器有不同的实现方法1234567891011// Webkitelement.webkitRequestFullScreen();//进入全屏document.webkitCancelFullScreen();//退出全屏// Firefoxelement.mozRequestFullScreen();document.mozCancelFullScreen(); // W3C element.requestFullscreen();document.exitFullscreen();","text":"当我们使用video标签的时候，有时候因为更多的需要，我们要自己自定义控制栏，而进入和退出全屏也是其中的一部分 不同的浏览器有不同的实现方法1234567891011// Webkitelement.webkitRequestFullScreen();//进入全屏document.webkitCancelFullScreen();//退出全屏// Firefoxelement.mozRequestFullScreen();document.mozCancelFullScreen(); // W3C element.requestFullscreen();document.exitFullscreen(); 一般兼容性写法，我们先使用w3c标准的方法，如果不可以在兼容不同浏览器。 12345678910111213141516171819202122//进入全屏function FullScreen() &#123; var ele = document.documentElement; if (ele .requestFullscreen) &#123; ele .requestFullscreen(); &#125; else if (ele .mozRequestFullScreen) &#123; ele .mozRequestFullScreen(); &#125; else if (ele .webkitRequestFullScreen) &#123; ele .webkitRequestFullScreen(); &#125;&#125;//退出全屏function exitFullscreen() &#123; var de = document; if (de.exitFullscreen) &#123; de.exitFullscreen(); &#125; else if (de.mozCancelFullScreen) &#123; de.mozCancelFullScreen(); &#125; else if (de.webkitCancelFullScreen) &#123; de.webkitCancelFullScreen(); &#125;&#125; 接下来是用例 1234$(ele).on(&apos;click&apos;,function()&#123; FullScreen(); // exitFullscreen();&#125;);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zsfmyz.top/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zsfmyz.top/tags/JavaScript/"}]},{"title":"Angular 的 uiRouter 的 方法$state.includes （判断当前激活路由）","slug":"angular 的 uiRouter 的 方法$state.includes （判断当前激活路由）","date":"2018-02-27T10:08:30.000Z","updated":"2019-08-28T10:18:21.626Z","comments":true,"path":"Angular/angular 的 uiRouter 的 方法$state.includes （判断当前激活路由）/","link":"","permalink":"http://www.zsfmyz.top/Angular/angular 的 uiRouter 的 方法$state.includes （判断当前激活路由）/","excerpt":"angular 的 uiRouter 的 方法$state.includes （判断当前激活路由）作用： 该方法用于判断当前激活的也就是地址栏的路由地址是哪个路由。 比如 $state.includes(‘app’) 那么如果页面地址为“www.baidu.com#/app” 或者 “www.baidu.com#/app/xxx” 的时候，该方法的值会返回true。（一般我们定义的路由和地址栏地址是相互对应的，方便管理。举例也是在app.xxx对应app/xxx这样设置路由的情况下） 如激活的路由为 app.page.page1 那么 123$state.includes(&apos;app&apos;) //返回 true$state.includes(&apos;app.page&apos;) //返回 true$state.includes(&apos;app.page.page1&apos;) //返回 true","text":"angular 的 uiRouter 的 方法$state.includes （判断当前激活路由）作用： 该方法用于判断当前激活的也就是地址栏的路由地址是哪个路由。 比如 $state.includes(‘app’) 那么如果页面地址为“www.baidu.com#/app” 或者 “www.baidu.com#/app/xxx” 的时候，该方法的值会返回true。（一般我们定义的路由和地址栏地址是相互对应的，方便管理。举例也是在app.xxx对应app/xxx这样设置路由的情况下） 如激活的路由为 app.page.page1 那么 123$state.includes(&apos;app&apos;) //返回 true$state.includes(&apos;app.page&apos;) //返回 true$state.includes(&apos;app.page.page1&apos;) //返回 true 用法： 知道了它的作用，接下来看看它的使用背景。 我们可以用来激活当前menu的状态。即使当前路由对应的菜单高亮或激活状态。 举例： 123456789101112131415161718192021&lt;div ng-init=&quot;menu_flag= !($state.includes(&apos;app.page1&apos;) || $state.includes(&apos;app.page2&apos;))&quot;&gt; 主菜单&lt;/div&gt;&lt;div ng-hide=&quot;menu_flag&quot;&gt; &lt;div ng-class=&quot;&#123;active: $state.includes(&apos;app.page1&apos;)&#125;&quot;&gt; &lt;a href=&quot;javascript:;&quot; ui-sref=&quot;app.page1&quot;&gt;子菜单一&lt;/a&gt; &lt;/div&gt; &lt;div ng-class=&quot;&#123;active: $state.includes(&apos;app.page2&apos;)&#125;&quot;&gt; &lt;a href=&quot;javascript:;&quot; ui-sref=&quot;app.page2&quot;&gt;子菜单二&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;// ...... n个类似结构组成的菜单&lt;div ng-init=&quot;menu_flag1= !($state.includes(&apos;app.page3&apos;) || $state.includes(&apos;app.page4&apos;))&quot;&gt; 主菜单&lt;/div&gt;&lt;div ng-hide=&quot;menu_flag1&quot;&gt; &lt;div ng-class=&quot;&#123;active: $state.includes(&apos;app.page3&apos;)&#125;&quot;&gt; &lt;a href=&quot;javascript:;&quot; ui-sref=&quot;app.page1&quot;&gt;子菜单一&lt;/a&gt; &lt;/div&gt; &lt;div ng-class=&quot;&#123;active: $state.includes(&apos;app.page4&apos;)&#125;&quot;&gt; &lt;a href=&quot;javascript:;&quot; ui-sref=&quot;app.page2&quot;&gt;子菜单二&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; 如上我们的菜单构成是由若干个类似结构构成，主menu控制若干个子menu。active是我们定义的激活菜单的css类名，当我们选中某个菜单时激活该菜单。即可借用$state.includes()来实现该功能。 同时，当我们的主menu要控制闭合和展开的话，当我们刷新的时候，我们通过判断($state.includes(&#39;app.page3&#39;) || $state.includes(&#39;app.page4&#39;)) 的值来在刷新之后判断该主菜单是否闭合。 当然我们也可以这样定义我们的路由。当然我们也可以这样定义我们的路由。例如： 一层菜单为 app.menu1 , 该主菜单下路由定义为 路由名称 一级路由定义 二级路由定义 一层菜单 app.menu1 二层菜单 app.menu1.menu1_1 二层菜单 app.menu1.menu1_2 这样的话我们在主菜单闭合上只需要判断 $state.includes(app.menu1) 即可。","categories":[{"name":"Angular","slug":"Angular","permalink":"http://www.zsfmyz.top/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://www.zsfmyz.top/tags/Angular/"}]},{"title":"文本的水平垂直居中","slug":"文本文字在DIV中垂直水平居中显示","date":"2018-01-17T08:59:13.000Z","updated":"2019-08-28T09:53:56.634Z","comments":true,"path":"Css/文本文字在DIV中垂直水平居中显示/","link":"","permalink":"http://www.zsfmyz.top/Css/文本文字在DIV中垂直水平居中显示/","excerpt":"#文字居中 ##垂直居中（vertical-align）我们都知道有这么一个属性可以让图片，文本等在元素中垂直居中1vertical-align:middle; vertical-align值有很多，常用的就是middle，bottom，text-bottom等，我们先说middle。","text":"#文字居中 ##垂直居中（vertical-align）我们都知道有这么一个属性可以让图片，文本等在元素中垂直居中1vertical-align:middle; vertical-align值有很多，常用的就是middle，bottom，text-bottom等，我们先说middle。 vertical-align时而没效果然而真实使用的时候，我们会发现这个属性“时灵时不灵”，有些情况下我们加了这个属性之后仍然不见img或者text有任何的变化。那是因为vertical-align只作用在inline-block或者inline，还有table-cell等元素内。同时这两种还有有所不同。 vertical-align并不是在高度内居中，而是对齐在行高内的middle线上。 所以我总结了两种使用vertical-align居中的方法： 第一种 1234&lt;div style=&quot;vertical-align: middle;display: table-cell;&quot;&gt; &lt;img src=&quot;02.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;文本居中&lt;/p&gt;&lt;/div&gt; 这种情况下图片和文字可以分行显示文字在图片下面同时图片和文字作为整体在元素内垂直居中。 第二种 1234&lt;div style=&quot;height:180px;line-height:180px;&quot;&gt; &lt;img src=&quot;02.jpg&quot; alt=&quot;图片&quot; style=&quot;vertical-align:middle;&quot; /&gt; 这是文本内容.&lt;/div&gt; 这种情况下文字是因为line-height属性而居中，跟vertical-align属性没有关系。同时img对齐在middle线上，但是如果父盒子去掉了line-height属性的话那么将会不起作用。（可以试试bottom和text-bottom的不同。） ##水平居中 1text-align:center; over","categories":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/categories/Css/"}],"tags":[{"name":"Css","slug":"Css","permalink":"http://www.zsfmyz.top/tags/Css/"}]},{"title":"Angular中ng-Repeat的track by 的使用（$Index）","slug":"angular中ng-repeat的track by 的使用（$index）","date":"2017-11-27T10:14:27.000Z","updated":"2019-08-28T10:18:09.527Z","comments":true,"path":"Angular/angular中ng-repeat的track by 的使用（$index）/","link":"","permalink":"http://www.zsfmyz.top/Angular/angular中ng-repeat的track by 的使用（$index）/","excerpt":"在angular中使用ng-repeat时数组中有重复元素 当我们在循环的数组中存在有重复的元素时候，angular的ng-repeat就会报错，那是因为其不允许collection有相同的id（相同的元素会形成相同的id）出现。而基本的数据类型它的id就是它自身的值。","text":"在angular中使用ng-repeat时数组中有重复元素 当我们在循环的数组中存在有重复的元素时候，angular的ng-repeat就会报错，那是因为其不允许collection有相同的id（相同的元素会形成相同的id）出现。而基本的数据类型它的id就是它自身的值。 我们要避免这种情况通常会使用track by $index 来让其生成自己不同的id，这样是最常用的直接通过索引来生成id。我们也可以通过自己设置业务上的id，然后用其进行遍历track by item.id. 总结一下，解决重复问题的方法就是item in items track by $index 使用$index会出现的问题。 我们使用$index不仅仅是为了避免重复元素的问题，有时候会被使用$index的索引来进行一部分操作，这里有一个坑需要注意。 当我们使用$index的时候，下列情况会出现$index跟原序列不匹配的情况 当我们改变列表的顺序的时候 当我们在列表中插入或者删除的时候 由于$index会跟随item上移下移，或者随之被删除。（例如你把列表第二条和第一条位置互换，这时候列表现在第一条的$index依旧为2，第二条还是原来的1）这时候你再使用$index传值就不在是新数组的索引了，不再匹配。 所以使用$index的时候要特别注意这些问题","categories":[{"name":"Angular","slug":"Angular","permalink":"http://www.zsfmyz.top/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://www.zsfmyz.top/tags/Angular/"}]},{"title":"Angular 的Http请求回调（success 和 Error）","slug":"angular 的http请求回调（success 和 error）","date":"2017-11-27T08:59:13.000Z","updated":"2019-08-28T09:49:49.340Z","comments":true,"path":"Angular/angular 的http请求回调（success 和 error）/","link":"","permalink":"http://www.zsfmyz.top/Angular/angular 的http请求回调（success 和 error）/","excerpt":"前面有文章写过angular的$http请求的简单书写和使用。回顾一下： 12345678910111213141516171819202122232425262728293031var Server = angular.module(&quot;Server&quot;, []);Server.service(&quot;Api&quot;, [&quot;$http&quot;, function ($http) &#123; return &#123; getTest : function (params, callback) &#123; $http(&#123; url: &apos;www.baidu.com?name=xxx&amp;passwd=xxx&apos;, method: &apos;GET&apos; &#125;).success(callback); &#125;, postTest : function (data, callback) &#123; $http(&#123; url: &apos;www.baidu.com&apos;, data: data, method: &apos;POST&apos; &#125;).success(callback); &#125;&#125;]);var App = angular.module(&quot;App&quot;, [ &quot;Server&quot;]);App.controller(&apos;Ctrl&apos;, [&apos;$scope&apos;, &apos;Api&apos;, function($scope, Api) &#123; Api.getTest(&quot;?name=xxx&amp;passwd=xxx&quot;, function(res)&#123; //res为返回值 alert(&quot;请求成功！&quot;) &#125;); Api.postTest(&#123;name: xxx, passwd: xxx&#125;, function(res)&#123; //res为返回值 alert(&quot;请求成功！&quot;) &#125;); &#125;]);","text":"前面有文章写过angular的$http请求的简单书写和使用。回顾一下： 12345678910111213141516171819202122232425262728293031var Server = angular.module(&quot;Server&quot;, []);Server.service(&quot;Api&quot;, [&quot;$http&quot;, function ($http) &#123; return &#123; getTest : function (params, callback) &#123; $http(&#123; url: &apos;www.baidu.com?name=xxx&amp;passwd=xxx&apos;, method: &apos;GET&apos; &#125;).success(callback); &#125;, postTest : function (data, callback) &#123; $http(&#123; url: &apos;www.baidu.com&apos;, data: data, method: &apos;POST&apos; &#125;).success(callback); &#125;&#125;]);var App = angular.module(&quot;App&quot;, [ &quot;Server&quot;]);App.controller(&apos;Ctrl&apos;, [&apos;$scope&apos;, &apos;Api&apos;, function($scope, Api) &#123; Api.getTest(&quot;?name=xxx&amp;passwd=xxx&quot;, function(res)&#123; //res为返回值 alert(&quot;请求成功！&quot;) &#125;); Api.postTest(&#123;name: xxx, passwd: xxx&#125;, function(res)&#123; //res为返回值 alert(&quot;请求成功！&quot;) &#125;); &#125;]); 这里以GET和POST请求为例。首先我们需要在APP中注入Server这个模块，才能使用里面的service服务Api，如上代码所示，注入Server之后我们就可以在控制器Ctl里面注入Api服务，然后使用我们之前定义好的接口。 GET请求中params 代表了？之后的参数，即 params == ‘?name=xxx&amp;passwd=xxx’,这样就可以通过传参的方式把参数加入到地址上，callback是请求成功后的回调，是个function，我们可以在里面打印出请求成功的返回值。 POST请求中data代表请求参数，传入之后直接请求即可，其他跟get请求类似。 error还有一点需要说的是http请求有时候会失败，当我们http请求失败的时候，将不会再调用success回调函数，而是会进入error回调，下面我就写一下http请求的success和error同时存在的写法。 123456789101112131415161718192021222324var Server = angular.module(&quot;Server&quot;, []);Server.service(&quot;Api&quot;, [&quot;$http&quot;, function ($http) &#123; return &#123; getTest : function (params, successCallback, errorCallback) &#123; $http(&#123; url: &apos;www.baidu.com?name=xxx&amp;passwd=xxx&apos;, method: &apos;GET&apos; &#125;).then(successCallback, errorCallback); &#125;&#125;]);var App = angular.module(&quot;App&quot;, [ &quot;Server&quot;]);App.controller(&apos;Ctrl&apos;, [&apos;$scope&apos;, &apos;Api&apos;, function($scope, Api) &#123; Api.getTest(&quot;?name=xxx&amp;passwd=xxx&quot;, function(res)&#123; //res为返回值 alert(&quot;请求成功！&quot;) &#125;, function(res)&#123; //res为返回值 alert(&quot;请求失败！&quot;) &#125;); &#125;]); 用法几乎一样，只不过把success(callback)改成了then(callback1, callback2).然后在调用的时候再加入一个function即可。 最简单的get写法 1234$http(&#123; url: &apos;www.baidu.com?name=xxx&amp;passwd=xxx&apos;, method: &apos;GET&apos; &#125;).success(callback);","categories":[{"name":"Angular","slug":"Angular","permalink":"http://www.zsfmyz.top/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://www.zsfmyz.top/tags/Angular/"}]}]}