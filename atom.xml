<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eighteen Blog</title>
  
  <subtitle>Eighteen Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.zsfmyz.top/"/>
  <updated>2020-05-01T03:55:07.667Z</updated>
  <id>http://www.zsfmyz.top/</id>
  
  <author>
    <name>赵十八</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript：202. 快乐数（快慢指针）</title>
    <link href="http://www.zsfmyz.top/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/JavaScript%EF%BC%9A202.%20%E5%BF%AB%E4%B9%90%E6%95%B0%EF%BC%88%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%EF%BC%89/"/>
    <id>http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：202. 快乐数（快慢指针）/</id>
    <published>2020-04-30T09:59:13.000Z</published>
    <updated>2020-05-01T03:55:07.667Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">给定一个 没有重复 数字的序列，返回其所有可能的全排列。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="解题思路一"><a href="#解题思路一" class="headerlink" title="解题思路一"></a>解题思路一</h3><p>广度优先遍历方法，递归解决</p><p><img src="https://img-blog.csdnimg.cn/20200425150234903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1bmh1aTE5OTRf,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如图所示， 我们需要3个信息：</p><pre><code>1. 和已确定序列，2. 剩余序列</code></pre><h3 id="题解一："><a href="#题解一：" class="headerlink" title="题解一："></a>题解一：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> permute = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> copy = [...nums];</span><br><span class="line">        join(copy.splice(i,<span class="number">1</span>), copy, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// preArr为已确认的前序列</span></span><br><span class="line"><span class="comment">// arr为剩余的序列</span></span><br><span class="line"><span class="keyword">var</span> join = <span class="function"><span class="keyword">function</span>(<span class="params">preArr, arr, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res.push(preArr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> copy = [...arr];</span><br><span class="line">        join(preArr.concat(copy.splice(i,<span class="number">1</span>)), copy, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/categories/Algorithm/"/>
    
      <category term="每日一题" scheme="http://www.zsfmyz.top/categories/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript：617. 合并二叉树（递归合并）</title>
    <link href="http://www.zsfmyz.top/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/JavaScript%EF%BC%9A617.%20%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E9%80%92%E5%BD%92%E5%90%88%E5%B9%B6%EF%BC%89/"/>
    <id>http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：617. 合并二叉树（递归合并）/</id>
    <published>2020-04-30T09:59:13.000Z</published>
    <updated>2020-05-01T03:55:32.963Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</span><br><span class="line"></span><br><span class="line">你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         / \                       / \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       /                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">输出: </span><br><span class="line">合并后的树:</span><br><span class="line">     3</span><br><span class="line">    / \</span><br><span class="line">   4   5</span><br><span class="line">  / \   \ </span><br><span class="line"> 5   4   7</span><br><span class="line">注意: 合并必须从两个树的根节点开始。</span><br></pre></td></tr></table></figure><h3 id="解题思路一"><a href="#解题思路一" class="headerlink" title="解题思路一"></a>解题思路一</h3><ol><li>又是一道二叉树的题，题目要求合并二叉树，即相同位置的val值相加，不同位置的val值互相替换。</li><li>一般思路是创建一个新树，去取两树之和。</li><li>但是题目没有要求不能改变原来的两棵树，那么我们以t1树为基准，观察t2树。</li><li>若t1树对应t2树的位置都有值，则相加，若t1无，t2有，则t2替换t1节点，若t1有，t2无则无需操作。<h3 id="代码实现一"><a href="#代码实现一" class="headerlink" title="代码实现一"></a>代码实现一</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">t1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">t2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> mergeTrees = <span class="function">(<span class="params">t1, t2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (t1 &amp;&amp; t2) &#123;</span><br><span class="line">        mergeNode(t1,t2) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t1 || t2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mergeNode = <span class="function">(<span class="params">t1, t2, root</span>) =&gt;</span> &#123;</span><br><span class="line">    t1.val += t2.val;</span><br><span class="line">    <span class="keyword">if</span> (t1.left === <span class="literal">null</span>) &#123;</span><br><span class="line">        t1.left = t2.left</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>( t2.left !== <span class="literal">null</span>) &#123;</span><br><span class="line">         mergeNode(t1.left,t2.left)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t1.right === <span class="literal">null</span>) &#123;</span><br><span class="line">        t1.right = t2.right</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t2.right !== <span class="literal">null</span>) &#123;</span><br><span class="line">        mergeNode(t1.right,t2.right)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>同样的我们使用递归的方法去遍历。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目说明&quot;&gt;&lt;a href=&quot;#题目说明&quot; class=&quot;headerlink&quot; title=&quot;题目说明&quot;&gt;&lt;/a&gt;题目说明&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/categories/Algorithm/"/>
    
      <category term="每日一题" scheme="http://www.zsfmyz.top/categories/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript:一道题，带你搞定二分法!</title>
    <link href="http://www.zsfmyz.top/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E4%B8%80%E9%81%93%E9%A2%98%EF%BC%8C%E5%B8%A6%E4%BD%A0%E6%90%9E%E5%AE%9A%E4%BA%8C%E5%88%86%E6%B3%95!%20(JavaScript)/"/>
    <id>http://www.zsfmyz.top/Algorithm/每日一题/一道题，带你搞定二分法! (JavaScript)/</id>
    <published>2020-04-29T09:59:13.000Z</published>
    <updated>2020-05-01T03:54:09.941Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>题目有点长，我就截个图展示了。<br><img src="https://img-blog.csdnimg.cn/20200429104354570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1bmh1aTE5OTRf,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这跟我之前做的那个旋转数组有相似之处，都是两个有序序列的组合。<br><a href="https://blog.csdn.net/lunhui1994_/article/details/105791551" target="_blank" rel="noopener">JavaScript：leetcode_33. 搜索旋转排序数组（二分法）</a></p><p>看题目限制，肯定又是不能用遍历的O(n)。而且对获取mountain的值有100次的限制。</p><p>那么自然就想到了<strong>二分法</strong>，结合题目，mountain长度为10000那么大概分十几次就完事儿了。基本不会把一百次用完。</p><p>我的思路是，用<strong>二分法</strong>找到mountain的山顶<strong>top</strong>，将其分为<strong>两个有序</strong>序列，然后分别用<strong>二分法</strong>查找。</p><p>最终算法时间复杂度为 O(log n)</p><ol><li>findTop 查找山顶top</li><li>findLeftTarget 左序查找target，左序列为升序序列。</li><li>findRightTarget 右序列查找target，右序列为降序序列。(也只是在判断条件上有所区别)</li></ol><p>如果不太清楚二分法,那么请先看一下 <a href="#kz"><strong>文末扩展</strong></a> </p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the MountainArray's API interface.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * function MountainArray() &#123;</span></span><br><span class="line"><span class="comment"> *     <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">index</span></span></span></span><br><span class="line"><span class="comment"> *     <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> *     this.get = function(index) &#123;</span></span><br><span class="line"><span class="comment"> *         ...</span></span><br><span class="line"><span class="comment"> *     &#125;;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> *     this.length = function() &#123;</span></span><br><span class="line"><span class="comment"> *         ...</span></span><br><span class="line"><span class="comment"> *     &#125;;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;MountainArray&#125;</span> <span class="variable">mountainArr</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findInMountainArray = <span class="function"><span class="keyword">function</span>(<span class="params">target, mountainArr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> length = mountainArr.length();</span><br><span class="line">    <span class="keyword">let</span> left_v = mountainArr.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> right_v = mountainArr.get(length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (target &lt; left_v &amp;&amp; target &lt; right_v) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> resMid = findTop(<span class="number">0</span>, length - <span class="number">1</span>, mountainArr)</span><br><span class="line">    <span class="keyword">let</span> top = resMid.mid;</span><br><span class="line">    <span class="keyword">let</span> topV = resMid.mid_v;</span><br><span class="line">    <span class="keyword">if</span> (target &gt; topV) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> left_target = findLeftTarget(<span class="number">0</span>, top, mountainArr, target);</span><br><span class="line">    <span class="keyword">return</span> left_target === <span class="number">-1</span> ? findRightTarget(top, length<span class="number">-1</span>, mountainArr, target) : left_target;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> findTop = <span class="function"><span class="keyword">function</span>(<span class="params">left, right, mountainArr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> mid_lv = mountainArr.get(mid - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> mid_v = mountainArr.get(mid);</span><br><span class="line">    <span class="keyword">let</span> mid_rv = mountainArr.get(mid + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (mid_v &gt; mid_lv) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mid_v &gt; mid_rv) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                mid: mid,</span><br><span class="line">                mid_v: mid_v,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> findTop(mid, right, mountainArr)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid_v &lt; mid_lv) &#123;</span><br><span class="line">        <span class="keyword">return</span> findTop(left, mid, mountainArr)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> findLeftTarget = <span class="function"><span class="keyword">function</span>(<span class="params">left, right, mountainArr, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (right - left &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> left_v = mountainArr.get(left);</span><br><span class="line">        <span class="keyword">if</span> (left_v === target) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> right_v = mountainArr.get(right);</span><br><span class="line">        <span class="keyword">if</span> (right_v === target) &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> mid_v = mountainArr.get(mid);</span><br><span class="line">    <span class="keyword">if</span> (mid_v &lt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> findLeftTarget(mid+<span class="number">1</span>, right, mountainArr, target)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid_v &gt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> findLeftTarget(left, mid, mountainArr, target)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> findRightTarget = <span class="function"><span class="keyword">function</span>(<span class="params">left, right, mountainArr, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (right - left &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> left_v = mountainArr.get(left);</span><br><span class="line">        <span class="keyword">if</span> (left_v === target) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> right_v = mountainArr.get(right);</span><br><span class="line">        <span class="keyword">if</span> (right_v === target) &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> mid_v = mountainArr.get(mid);</span><br><span class="line">    <span class="keyword">if</span> (mid_v &gt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> findLeftTarget(mid+<span class="number">1</span>, right, mountainArr, target)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid_v &lt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> findLeftTarget(left, mid, mountainArr, target)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展-二分法详解"><a href="#扩展-二分法详解" class="headerlink" title="扩展 二分法详解"></a><span id="kz">扩展 二分法详解</span></h3><h5 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h5><blockquote><p>算法：当数据量很大适宜采用该方法。采用二分法查找时，数据需是<strong>排好序</strong>的。</p></blockquote><ul><li>基本思想：假设数据是按升序排序的，对于给定值key，从序列的中间位置k开始比较， 如果当前位置arr[k]值等于key，则查找成功；<ul><li>若key小于当前位置值arr[k]，则在数列的前半段中查找,arr[low,mid-1]；</li><li>若key大于当前位置值arr[k]，则在数列的后半段中继续查找arr[mid+1,high]，</li><li>直到找到为止,时间复杂度:O(log(n))</li></ul></li></ul><h5 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h5><ul><li>序列必须是有序的，无序序列无法使用二分法。</li><li>通过递归查找，直至序列长度缩小到2或者1。</li></ul><h5 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a>模拟实现</h5><blockquote><p>以 nums[1,2,3,4,5]为例，找到数组中值为1的下标</p><ol><li>left为 0，right为 4, 声明函数<code>find(left,right)</code></li><li>求出中间点 <code>mid =  left + ((right - left) &gt;&gt; 1)</code> 。 （&gt;&gt; 为位运算，相当于缩小2倍）</li><li>得到 mid 为 2；判断 <code>nums[2] === 1 ?</code>，若等返回<code>mid</code>，nums[2] 为 3，不等 1 ，进入下一步</li><li>判断<code>nums[mid] &gt; 1</code>,由于nums[2] ===3 &gt; 1,进入左序列<code>find(0, 2)</code></li><li>求出中间点 <code>mid =  0+ ((2- 0) &gt;&gt; 1)</code>,</li><li>得到mid 为 1；判断 <code>nums[1] === 1 ?</code>，若等返回<code>mid</code>，nums[1] 为 2，不等 1 ，进入下一步 </li><li>判断<code>nums[mid] &gt; 1</code>,由于nums[1] ===2 &gt; 1,进入左序列<code>find(0, 1)</code></li><li>求出中间点 <code>mid =  0+ ((1 - 0) &gt;&gt; 1)</code>,</li><li>得到mid 为 0；判断 <code>nums[0] === 1 ?</code>，若等返回<code>mid</code>，nums[0] 为 1，等 1 ，return mid；</li></ol></blockquote><p>至此得到最后结果 下标为 0；</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] ;</span><br><span class="line"><span class="keyword">let</span> target = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> find = <span class="function"><span class="keyword">function</span>(<span class="params">left, right, target, nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> mid = (left + ((right - left) &gt;&gt; <span class="number">1</span>));  </span><br><span class="line">    <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">    <span class="keyword">return</span> find(left, mid, target, nums);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> find(mid + <span class="number">1</span>, right, target, nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">find(<span class="number">0</span>,<span class="number">4</span>,<span class="number">1</span>, nums)</span><br></pre></td></tr></table></figure><p>这种是数组中一定包含target的情况下。如果不确定是否包含，需要在值只剩下1-2个的时候做出判断。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] ;</span><br><span class="line"><span class="keyword">let</span> target = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> find = <span class="function"><span class="keyword">function</span>(<span class="params">left, right, target, nums</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (right- left &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> nums[left] === target ? left : (nums[right] ===target ? right: <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">let</span> mid = (left + ((right - left) &gt;&gt; <span class="number">1</span>));  </span><br><span class="line">    <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">    <span class="keyword">return</span> find(left, mid, target, nums);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> find(mid + <span class="number">1</span>, right, target, nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">find(<span class="number">0</span>,<span class="number">4</span>,<span class="number">1</span>, nums)</span><br></pre></td></tr></table></figure><p>这样如果不存在返回 -1 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;题目有点长，我就截个图展示了。&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/categories/Algorithm/"/>
    
      <category term="每日一题" scheme="http://www.zsfmyz.top/categories/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript：leetcode_33. 搜索旋转排序数组（二分法）</title>
    <link href="http://www.zsfmyz.top/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/JavaScript%EF%BC%9Aleetcode_33.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%EF%BC%88%E4%BA%8C%E5%88%86%E6%B3%95%EF%BC%89/"/>
    <id>http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_33. 搜索旋转排序数组（二分法）/</id>
    <published>2020-04-26T09:59:13.000Z</published>
    <updated>2020-05-01T03:51:52.715Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">假设按照升序排序的数组在预先未知的某个点上进行了旋转。</span><br><span class="line"></span><br><span class="line">( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</span><br><span class="line"></span><br><span class="line">搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</span><br><span class="line"></span><br><span class="line">你可以假设数组中不存在重复的元素。</span><br><span class="line"></span><br><span class="line">你的算法时间复杂度必须是 O(log n) 级别。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">输出: 4</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure><h3 id="解题思路一"><a href="#解题思路一" class="headerlink" title="解题思路一"></a>解题思路一</h3><p>时间复杂度要O(log n) ，那么就不能直接用遍历了。遍历是O(n)</p><p>其实一个无序的序列，查找的最小时间复杂度就是O(n)</p><p>但是，根据题意，原序列为升序序列，那么旋转后的序列其实是两个有序的序列的拼接，且没有交集。</p><p>我的思路是<strong>找到旋转点</strong>，然后分别使用<strong>二分法</strong>查找。二分法的时间复杂度就是O(log n)。</p><p>寻找<strong>旋转点</strong>同样使用<strong>二分法</strong>。</p><p>寻找<strong>旋转点</strong>时，<strong>左右序列都要包含mid</strong>，进行判断，否则会出现正好在旋转点处分割左右序列的情况。</p><p>这样的方法时间复杂度为<strong>O(2 log n)</strong> 应该还是符合题意的。</p><h3 id="题解一："><a href="#题解一：" class="headerlink" title="题解一："></a>题解一：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> search = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> flag = ef1(left, right, nums);</span><br><span class="line">    <span class="keyword">let</span> leftV = ef(left, flag, target, nums)</span><br><span class="line">    <span class="keyword">let</span> rightV = ef(flag + <span class="number">1</span>, right, target, nums)</span><br><span class="line">    <span class="keyword">return</span> leftV &gt; <span class="number">-1</span> ? leftV : rightV</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 查找旋转点</span></span><br><span class="line"><span class="keyword">var</span> ef1 = <span class="function"><span class="keyword">function</span>(<span class="params">left, right, nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(left + (right - left) / <span class="number">2</span>); </span><br><span class="line">    <span class="keyword">if</span> (right - left === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] &gt; nums[right]) &#123;</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左序列 如果左大于右，那说明旋转点在左序列中。</span></span><br><span class="line">    <span class="keyword">if</span> (nums[left] &gt; nums[mid]) &#123;</span><br><span class="line">        <span class="keyword">return</span> ef1(left, mid, nums);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// 右序列 如果左大于右，那说明旋转点在左序列中。</span></span><br><span class="line">    <span class="keyword">if</span> (nums[mid] &gt; nums[right]) &#123;</span><br><span class="line">        <span class="keyword">return</span> ef1(mid, right, nums);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查找target</span></span><br><span class="line"><span class="keyword">var</span> ef = <span class="function"><span class="keyword">function</span>(<span class="params">left, right, target, nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(left + (right - left) / <span class="number">2</span>); </span><br><span class="line">    <span class="keyword">if</span> (right - left === <span class="number">1</span> || right - left === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target === nums[left]) &#123;</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target === nums[right]) &#123;</span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; nums[mid] &gt;= target) &#123;</span><br><span class="line">        <span class="keyword">return</span> ef(left, mid, target, nums);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[mid + <span class="number">1</span>] &lt;= target &amp;&amp; nums[right] &gt;= target) &#123;</span><br><span class="line">        <span class="keyword">return</span> ef(mid + <span class="number">1</span>, right, target, nums);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/categories/Algorithm/"/>
    
      <category term="每日一题" scheme="http://www.zsfmyz.top/categories/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript：leetcode_46. 全排列 (广度优先遍历)</title>
    <link href="http://www.zsfmyz.top/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/JavaScript%EF%BC%9Aleetcode_46.%20%E5%85%A8%E6%8E%92%E5%88%97%20(%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86)/"/>
    <id>http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：leetcode_46. 全排列 (广度优先遍历)/</id>
    <published>2020-04-25T09:59:13.000Z</published>
    <updated>2020-05-01T03:50:52.331Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">给定一个 没有重复 数字的序列，返回其所有可能的全排列。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="解题思路一"><a href="#解题思路一" class="headerlink" title="解题思路一"></a>解题思路一</h3><p>广度优先遍历方法，递归解决</p><p><img src="https://img-blog.csdnimg.cn/20200425150234903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1bmh1aTE5OTRf,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如图所示， 我们需要3个信息：</p><pre><code>1. 和已确定序列，2. 剩余序列</code></pre><h3 id="题解一："><a href="#题解一：" class="headerlink" title="题解一："></a>题解一：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> permute = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> copy = [...nums];</span><br><span class="line">        join(copy.splice(i,<span class="number">1</span>), copy, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// preArr为已确认的前序列</span></span><br><span class="line"><span class="comment">// arr为剩余的序列</span></span><br><span class="line"><span class="keyword">var</span> join = <span class="function"><span class="keyword">function</span>(<span class="params">preArr, arr, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res.push(preArr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> copy = [...arr];</span><br><span class="line">        join(preArr.concat(copy.splice(i,<span class="number">1</span>)), copy, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/categories/Algorithm/"/>
    
      <category term="每日一题" scheme="http://www.zsfmyz.top/categories/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript：面56 - I. 数组中数字出现的次数（分组异或）</title>
    <link href="http://www.zsfmyz.top/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/JavaScript%EF%BC%9A%E9%9D%A256%20-%20I.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%EF%BC%88%E5%88%86%E7%BB%84%E5%BC%82%E6%88%96%EF%BC%89/"/>
    <id>http://www.zsfmyz.top/Algorithm/每日一题/JavaScript：面56 - I. 数组中数字出现的次数（分组异或）/</id>
    <published>2020-04-25T09:59:13.000Z</published>
    <updated>2020-05-01T03:52:39.394Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums = [1,2,10,4,1,4,3,3]</span><br><span class="line">输出：[2,10] 或 [10,2]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line"></span><br><span class="line">2 &lt;= nums &lt;= 10000</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>求出数组异或的结果。因为相同值的异或为0，所以最后异或的结果为两个不同数的异或结果res。</li><li>将两个不同的值分别分割到两个不同的数组中。取res二进制中任意一位值为1的位置，作为区分标志flag。（1，说明两个不同值的二进制，在该位处的值一个为0，一个为1）</li><li>遍历数组  根据（nums[i] &amp; flag）的值区分为两个数组，并求出两个数组的异或结果。</li><li>由于两个不同值被分开，并且相同值对同一值的位与（&amp;）操作是相同的。所以，两个数组内除了不同值，其他都是由n对相同值构成，所以最后的异或操做是排除了n对相同值，最后分别得出了两个不同值。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> singleNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length === <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    nums.unshift(<span class="number">0</span>);</span><br><span class="line">    res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        res ^= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>((flag &amp; res) == <span class="number">0</span>) &#123;</span><br><span class="line">        flag &lt;&lt;= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &amp; flag) &#123;</span><br><span class="line">            left ^= nums[i]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right ^= nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [left, right]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目说明&quot;&gt;&lt;a href=&quot;#题目说明&quot; class=&quot;headerlink&quot; title=&quot;题目说明&quot;&gt;&lt;/a&gt;题目说明&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/categories/Algorithm/"/>
    
      <category term="每日一题" scheme="http://www.zsfmyz.top/categories/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode_面试题51. 数组中的逆序对（归并排序记录逆序对）</title>
    <link href="http://www.zsfmyz.top/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/leetcode_%E9%9D%A2%E8%AF%95%E9%A2%9851.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    <id>http://www.zsfmyz.top/Algorithm/每日一题/leetcode_面试题51. 数组中的逆序对/</id>
    <published>2020-04-24T09:59:13.000Z</published>
    <updated>2020-04-24T07:58:53.825Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [7,5,6,4]</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><h3 id="解题思路一"><a href="#解题思路一" class="headerlink" title="解题思路一"></a>解题思路一</h3><p>N*N遍历求出逆序对的总数</p><h3 id="题解一："><a href="#题解一：" class="headerlink" title="题解一："></a>题解一：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">var</span> reversePairs = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">let</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &gt;=<span class="number">0</span>; j++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                res++;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>很简单，但是毫无疑问超时。</p><h3 id="解题思路二"><a href="#解题思路二" class="headerlink" title="解题思路二"></a>解题思路二</h3><p>归并排序算法，排序过程中记录逆序对的数量。最终nums还是一个升序序列。相当于我们在归并排序中顺手得到了逆序对的数量。</p><p>归并排序：它的思路就是，找到数组中间下标，然后排序左序列（left，middle）和右序列（middle+1，right）。结合递归一直分到序列长度为2，然后出栈排序。</p><p>归并排序的思路即：</p><ol><li>[4,2,3,1,8,7,6,5] =&gt; [4,2,3,1]和[8,7,6,5]</li><li>[4,2,3,1] =&gt; [4,2] 和 [3,1]</li><li>到length==2,递归到终点，排序[4,2] =&gt; [2,4]。[3,1] =&gt; [1,3]。</li><li>然后得到[2,4,1,3],再对其进行排序，因为子序列的顺序都是排好的。所以，我们只需要对比，[2,4]和[1,3]哪个序列中前面的值小，就摘出来，放在help中。<ol><li>比如1和2比，1小，那么help就变成了[1]，左序列还是[2,4],右序列变成了[3].</li><li>然后3和2比，2小，那么help就变成了[1,2], 左序列变成了[4],右序列还是[3].</li><li>一直比到左右序列有一个序列为空时，再将另外一个序列依次加入help。</li></ol></li></ol><h3 id="题解一：-1"><a href="#题解一：-1" class="headerlink" title="题解一："></a>题解一：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">nums, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left === right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(left + ((right - left) &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    mergeSort(nums, left, mid)</span><br><span class="line">    mergeSort(nums, mid + <span class="number">1</span>, right)</span><br><span class="line">    <span class="keyword">let</span> p1 = left;</span><br><span class="line">    <span class="keyword">let</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> help = [];</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p1 &lt;= mid &amp;&amp; p2 &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[p1] &lt;= nums[p2]) &#123;</span><br><span class="line">            res += p2 - (mid + <span class="number">1</span>)<span class="comment">//左序列的值，在赋值之前要看下help中，在它之前有几个右序列的值。就有几个逆序对。</span></span><br><span class="line">        &#125;</span><br><span class="line">        help[i++] = nums[p1] &gt; nums[p2] ? nums[p2++] : nums[p1++];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p1 &lt;= mid) &#123;</span><br><span class="line">        help[i++] = nums[p1++];</span><br><span class="line">        res += right - mid <span class="comment">//若左序列还有剩余，那么剩余的都比右序列大，所以每个都要加上右序列的长度。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p2 &lt;= right) &#123;</span><br><span class="line">        help[i++] = nums[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    nums.splice(left, right - left + <span class="number">1</span>, ...help);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reversePairs = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!nums.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="number">0</span>;</span><br><span class="line">    mergeSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//nums此时是一个升序的序列</span></span><br><span class="line">    <span class="keyword">return</span> res </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/categories/Algorithm/"/>
    
      <category term="每日一题" scheme="http://www.zsfmyz.top/categories/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode_面试题 08.11. 硬币(数学方法，双百分)</title>
    <link href="http://www.zsfmyz.top/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/leetcode_%E9%9D%A2%E8%AF%95%E9%A2%98%2008.11.%20%E7%A1%AC%E5%B8%81/"/>
    <id>http://www.zsfmyz.top/Algorithm/每日一题/leetcode_面试题 08.11. 硬币/</id>
    <published>2020-04-23T09:59:13.000Z</published>
    <updated>2020-04-24T07:58:05.179Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)</span><br><span class="line"></span><br><span class="line">示例1:</span><br><span class="line"></span><br><span class="line"> 输入: n = 5</span><br><span class="line"> 输出：2</span><br><span class="line"> 解释: 有两种方式可以凑成总金额:</span><br><span class="line">5=5</span><br><span class="line">5=1+1+1+1+1</span><br><span class="line">示例2:</span><br><span class="line"></span><br><span class="line"> 输入: n = 10</span><br><span class="line"> 输出：4</span><br><span class="line"> 解释: 有四种方式可以凑成总金额:</span><br><span class="line">10=10</span><br><span class="line">10=5+5</span><br><span class="line">10=5+1+1+1+1+1</span><br><span class="line">10=1+1+1+1+1+1+1+1+1+1</span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line"></span><br><span class="line">你可以假设：</span><br><span class="line"></span><br><span class="line">0 &lt;= n (总金额) &lt;= 1000000</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>在这我只说一个硬刚的办法。没有算法，按照正常人类观察的思路：</p><ol><li>一共存在n/25个25分硬币。</li><li>求当存在1个25分硬币时，剩余部分由多少个10分硬币组成。<ol><li>在2的条件下，求1个10分硬币之外的部分由多少个5分硬币组成,有几个就加几个，再加上全1分的情况。</li></ol></li><li>求当存在1个25分硬币时，剩余部分由多少个5分硬币组成。有几个就加几个，再加上全1分的情况。</li></ol><p>至此我们求出了，组合中含有25分硬币的所有方法。然后按照上面的方法，求只存在10，5，1的方法，最后求只存在5，1的方法。其和即为我们所求的所有组合个数</p><h3 id="题解一："><a href="#题解一：" class="headerlink" title="题解一："></a>题解一：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> waysToChange = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//求 25分 10分 5分 1分组合情况</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">Math</span>.floor(n / <span class="number">25</span>); i++) &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= <span class="built_in">Math</span>.floor(( n - <span class="number">25</span> * i) / <span class="number">10</span>) ; j++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt;= <span class="built_in">Math</span>.floor((n - <span class="number">25</span> * i - <span class="number">10</span>*j) / <span class="number">5</span>); k++) &#123;</span><br><span class="line">               res++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">let</span> l = <span class="number">0</span>; l &lt;= <span class="built_in">Math</span>.floor(( n - <span class="number">25</span> * i) / <span class="number">5</span>) ; l++) &#123;</span><br><span class="line">            res++</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求 10分 5分 1分组合情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= <span class="built_in">Math</span>.floor(n / <span class="number">10</span>) ; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt;= <span class="built_in">Math</span>.floor((n - <span class="number">10</span>*j) / <span class="number">5</span>); k++) &#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求 5分 1分组合情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt;= <span class="built_in">Math</span>.floor(n / <span class="number">5</span>); k++) &#123;</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res % <span class="number">1000000007</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个办法，相当的好理解吧。然鹅！！！超时咯~~~</p><p>那我就不会优化优化吗~~</p><ol><li>我们可以看出来求10，5，1 的情况和求5，1的情况，实际上是求当25分的个数为0时的情况。那我们合并一下，将i的值从0开始循环，那么就可以合并起来啦</li></ol><h4 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> waysToChange = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//求 25分 10分 5分 1分组合情况</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= <span class="built_in">Math</span>.floor(n / <span class="number">25</span>); i++) &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= <span class="built_in">Math</span>.floor(( n - <span class="number">25</span> * i) / <span class="number">10</span>) ; j++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt;= <span class="built_in">Math</span>.floor((n - <span class="number">25</span> * i - <span class="number">10</span>*j) / <span class="number">5</span>); k++) &#123;</span><br><span class="line">               res++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">let</span> l = <span class="number">0</span>; l &lt;= <span class="built_in">Math</span>.floor(( n - <span class="number">25</span> * i) / <span class="number">5</span>) ; l++) &#123;</span><br><span class="line">            res++</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> res % <span class="number">1000000007</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>再来看,这是求5，1分的。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (let l = 0; l &lt;= Math.floor(( n - 25 * i) / 5) ; l++) &#123;</span><br><span class="line">  res++</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol><p>其实是求i = 0 到 Math.floor(( n - 25 <em> i) / 5) 的个数吧，那就是Math.floor(( n - 25 </em> i) / 5)+1个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let rest = Math.floor( n - 25 * i) ;</span><br><span class="line">res+= Math.floor(rest / 5) + 1;</span><br></pre></td></tr></table></figure><ol start="3"><li>同理我们把10，5，1 的for循环也提取一下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> for (let j = 1; j &lt;= Math.floor(( n - 25 * i) / 10) ; j++) &#123;</span><br><span class="line">           for (let k = 0; k &lt;= Math.floor((n - 25 * i - 10*j) / 5); k++) &#123;</span><br><span class="line">               res++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">// 先按照2中的方法把内循环优化一下</span><br><span class="line">let rest = Math.floor( n - 25 * i) ;</span><br><span class="line">let rest10 = Math.floor(rest / 10);</span><br><span class="line"> for (let j = 1; j &lt;= rest10 ; j++) &#123;</span><br><span class="line">           res+= Math.floor(rest / 5) + 1 - 2j;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li></ol><p>=&gt; 到这儿应该很清楚怎么优化了吧 (Math.floor(rest / 5) + 1)<em>rest10 - (2 + 2 </em> 2 + 2 <em> 3+….+2 </em> rest10)<br>=&gt; (Math.floor(rest / 5) + 1)<em>rest10 - (2+2</em>rest10)/2 再提取一下公因式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let rest = Math.floor( n - 25 * i) ;</span><br><span class="line">let rest10 = Math.floor(rest / 10);</span><br><span class="line"></span><br><span class="line">   res += rest10 * (Math.floor(rest / 5) - rest10)</span><br></pre></td></tr></table></figure></p><h3 id="题解二："><a href="#题解二：" class="headerlink" title="题解二："></a>题解二：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> waysToChange = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> length25 = <span class="built_in">Math</span>.floor(n / <span class="number">25</span>);</span><br><span class="line">     <span class="keyword">for</span> ( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= length25; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> rest = <span class="built_in">Math</span>.floor(( n - <span class="number">25</span> * i));</span><br><span class="line">        <span class="keyword">let</span> rest10 = <span class="built_in">Math</span>.floor(rest / <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        res += rest10 * (<span class="built_in">Math</span>.floor(rest / <span class="number">5</span>) - rest10)</span><br><span class="line"></span><br><span class="line">        res += <span class="built_in">Math</span>.floor(rest / <span class="number">5</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res % <span class="number">1000000007</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>就这样完美解决了，并且时间和空间都秒杀了100%</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/categories/Algorithm/"/>
    
      <category term="每日一题" scheme="http://www.zsfmyz.top/categories/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Leecode_199. 二叉树的右视图(二叉树中右左遍历）</title>
    <link href="http://www.zsfmyz.top/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/leecode_199.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/"/>
    <id>http://www.zsfmyz.top/Algorithm/每日一题/leecode_199. 二叉树的右视图/</id>
    <published>2020-04-22T09:59:13.000Z</published>
    <updated>2020-04-24T07:57:55.860Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [1,2,3,null,5,null,4]</span><br><span class="line">输出: [1, 3, 4]</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">   1            &lt;---</span><br><span class="line"> /   \</span><br><span class="line">2     3         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  5     4       &lt;---</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>对二叉树进行<strong>中右左</strong>顺序遍历，以此顺序，记录每个层级第一个被遍历的节点。</p><h3 id="题解一："><a href="#题解一：" class="headerlink" title="题解一："></a>题解一：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rightSideView = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> resArr = [];</span><br><span class="line">    <span class="keyword">let</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;<span class="keyword">return</span> []&#125;    </span><br><span class="line">    nodeFn(root, <span class="number">0</span>, resArr)</span><br><span class="line">    <span class="keyword">return</span> resArr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nodeFn = <span class="function"><span class="keyword">function</span> (<span class="params">node, level, resArr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (resArr[level] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        resArr[level] = node.val;</span><br><span class="line">    &#125;</span><br><span class="line">    node.right &amp;&amp; nodeFn(node.right, level + <span class="number">1</span>, resArr)</span><br><span class="line">    node.left &amp;&amp; nodeFn(node.left, level + <span class="number">1</span>, resArr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于二叉树的后序遍历的反序（中右左），只不过需要标记一下每个层级的第一个遍历节点即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/categories/Algorithm/"/>
    
      <category term="每日一题" scheme="http://www.zsfmyz.top/categories/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode_200. 岛屿数量 (DFS)</title>
    <link href="http://www.zsfmyz.top/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/leetcode_200.%20%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"/>
    <id>http://www.zsfmyz.top/Algorithm/每日一题/leetcode_200. 岛屿数量/</id>
    <published>2020-04-20T09:59:13.000Z</published>
    <updated>2020-04-24T07:57:55.737Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">给你一个由 &apos;1&apos;（陆地）和 &apos;0&apos;（水）组成的的二维网格，请你计算网格中岛屿的数量。</span><br><span class="line"></span><br><span class="line">岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</span><br><span class="line"></span><br><span class="line">此外，你可以假设该网格的四条边均被水包围。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line">输出: 1</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line">输出: 3</span><br><span class="line">解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>遍历二维数组，遍历时只查找===’1‘的情况，设立大陆数量flag初始化为1</li><li>找到一块岛屿（===’1‘），此时将flag+1，并将该岛屿标记为flag（2）</li><li>深度遍历与该岛屿连接起来的所有岛屿（连起来的其他’1‘）</li><li>将其深度遍历到的岛屿标记为flag</li><li>深度遍历完成后，继续二维数组的遍历，如果在深度标记后，又找到一个’1‘，那这肯定是第二块大陆的一部分了，重复2-4的步骤。</li><li>返回flag-1就是大陆的数量。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = [<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line"><span class="keyword">let</span> y = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>]</span><br><span class="line"><span class="keyword">var</span> mark = <span class="function"><span class="keyword">function</span>(<span class="params">i,j,flag,grid</span>)</span>&#123;</span><br><span class="line">    grid[i][j] = flag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key = <span class="number">0</span>; key &lt; <span class="number">4</span>; key++) &#123;</span><br><span class="line">         (grid[i + x[key]][j + y[key]] === <span class="string">'1'</span>) &amp;&amp; (mark(i + x[key],j+y[key],flag,grid));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> numIslands = <span class="function"><span class="keyword">function</span>(<span class="params">grid</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!grid.length)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这一块操作是在二维数组外层包裹了一层’0‘，也就是一层海洋，方便处理边界问题。start</span></span><br><span class="line">    grid.unshift(<span class="keyword">new</span> <span class="built_in">Array</span>(grid[<span class="number">0</span>].length).fill(<span class="string">'0'</span>));</span><br><span class="line">    grid.push(<span class="keyword">new</span> <span class="built_in">Array</span>(grid[<span class="number">0</span>].length).fill(<span class="string">'0'</span>));</span><br><span class="line">    grid.map(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">        item.unshift(<span class="string">'0'</span>)</span><br><span class="line">        item.push(<span class="string">'0'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//这一块操作是在二维数组外层包裹了一层’0‘，也就是一层海洋，方便处理边界问题。end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; grid.length<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; grid[i].length<span class="number">-1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] === <span class="string">'1'</span>) &#123;</span><br><span class="line">                flag++;</span><br><span class="line">                mark(i,j,flag,grid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (flag - <span class="number">1</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目说明&quot;&gt;&lt;a href=&quot;#题目说明&quot; class=&quot;headerlink&quot; title=&quot;题目说明&quot;&gt;&lt;/a&gt;题目说明&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/categories/Algorithm/"/>
    
      <category term="每日一题" scheme="http://www.zsfmyz.top/categories/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode_11. 盛最多水的容器 （暴力遍历=&gt;双指针）</title>
    <link href="http://www.zsfmyz.top/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/leetcode_11.%20%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <id>http://www.zsfmyz.top/Algorithm/每日一题/leetcode_11. 盛最多水的容器/</id>
    <published>2020-04-19T09:59:13.000Z</published>
    <updated>2020-04-24T07:53:56.692Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">题目描述</a></h3><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器，且 n 的值至少为 2。</p><h3 id="解题思路-一暴力法"><a href="#解题思路-一暴力法" class="headerlink" title="解题思路 一暴力法"></a>解题思路 一暴力法</h3><p>办法一很简单，双层循环计算出所有可能的结果，选出最大的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> maxArea = <span class="function"><span class="keyword">function</span>(<span class="params">height</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i; j &lt; height.length; j++) &#123;</span><br><span class="line">            <span class="keyword">let</span> m2 = <span class="built_in">Math</span>.min(height[i],height[j]) * (j-i);</span><br><span class="line">            <span class="keyword">if</span> (m2 &gt; area) &#123;</span><br><span class="line">                area = m2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一点难度都没有。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>接下来我们优化一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getArea = <span class="function"><span class="keyword">function</span>(<span class="params">height, i, j</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.min(height[i],height[j]) * (j-i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> maxArea = <span class="function"><span class="keyword">function</span>(<span class="params">height</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> end = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> area = getArea(height, start, end );</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = height.length - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[j] &lt; height[end]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (area &lt; getArea(height, i, j)) &#123;</span><br><span class="line">                area = getArea(height,i, j);</span><br><span class="line">                start = i;</span><br><span class="line">                end = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>把计算面积提出到getArea中了</li><li>标记了start，end。并利用其进行剪枝（优化去掉不必要的for循环），因为我们很容易看出来，比end（距离start最远）位更短的木板没有必要再进行计算了。</li></ol><h3 id="解题思路-二-双指针"><a href="#解题思路-二-双指针" class="headerlink" title="解题思路 二 双指针"></a>解题思路 二 双指针</h3><p>其实这道题的思路是这样：<br>计算start，end之间的距离（宽），和Math.min(start，end)(高)的面积。<br>怎么计算最大面积呢？目标是找最宽和最高。<br>即在start，end距离最远的情况下，找两边最高的木板。</p><p>所以，我们通过让start和end在最远的距离处，开始慢慢靠近，靠近的规则是：</p><ol><li>抛弃最短的，即若start比end处的木板短，start向右移一位+1，（反之end处短，则end - 1）</li><li>这样可以使两边都保证是最长的木板之间的面积</li><li>同样我们可以加入上面的优化，移位后，比原本位置短的，直接过滤掉。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getArea = <span class="function"><span class="keyword">function</span>(<span class="params">height, i, j</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.min(height[i],height[j]) * (j-i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> maxArea = <span class="function"><span class="keyword">function</span>(<span class="params">height</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> end = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> area = getArea(height, start, end );</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>,j = end; i &lt; j;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[i] &gt; height[j]) &#123;</span><br><span class="line">                j--;</span><br><span class="line">                <span class="keyword">if</span> (height[j] &lt; height[end]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++</span><br><span class="line">                <span class="keyword">if</span> (height[i] &lt; height[start]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> m2 = getArea(height, i, j);</span><br><span class="line">            <span class="keyword">if</span> (area &lt; m2) &#123;</span><br><span class="line">                area = m2;</span><br><span class="line">                start = i;</span><br><span class="line">                end = j;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/container-with-most-water/&quot; targ
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/categories/Algorithm/"/>
    
      <category term="每日一题" scheme="http://www.zsfmyz.top/categories/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>块级作用域内的函数声明到底是什么？？</title>
    <link href="http://www.zsfmyz.top/JavaScript/%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%86%85%E7%9A%84%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%9F/"/>
    <id>http://www.zsfmyz.top/JavaScript/块级作用域内的函数声明到底是什么？？/</id>
    <published>2020-04-16T04:19:13.000Z</published>
    <updated>2020-04-24T07:51:09.551Z</updated>
    
    <content type="html"><![CDATA[<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>在一篇文章里看到这样一个问题。<a href="https://mp.weixin.qq.com/s/MlKRNfK3blGJA7bfXzdsNg" target="_blank" rel="noopener">文章地址</a></p><blockquote><p>文章中会扩展一些其他的内容， 大家可以看过之后再来看我这篇个人的总结</p></blockquote><p>函数声明写在块级作用域中（ES6）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    a = <span class="number">21</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"里面"</span>,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"外部"</span>,a);</span><br></pre></td></tr></table></figure></p><p>请问输出是什么？ 答案是：<strong>里面21 外面1</strong>。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovLzViMDk4OGU1OTUyMjUuY2RuLnNvaHVjcy5jb20vaW1hZ2VzLzIwMjAwMzIxL2Q3MTRmMzU1YjUwYTRlYjU4YWIyZTI3MTliYTNkMjUzLmpwZWc?x-oss-process=image/format,png#pic_center" alt="小朋友，ni&#39;you"><br>正如我一样，看到答案的我蒙蔽了，然后就继续阅读完全文，感觉还是有点不太明白。最后经过我查询资料我得到了答案。</p><h3 id="转换结果"><a href="#转换结果" class="headerlink" title="转换结果"></a>转换结果</h3><p>代码转化如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">   <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">       <span class="keyword">let</span> a = <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">       &#125;</span><br><span class="line">       a = <span class="number">1</span>; </span><br><span class="line">       <span class="built_in">window</span>.a = a;  <span class="comment">//此处为原函数声明的位置</span></span><br><span class="line">       a = <span class="number">21</span>;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">"里面"</span>,a);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"外部"</span>,a);</span><br></pre></td></tr></table></figure><p>其实，函数声明放在块级作用域内做了以下几件事。<br>so， 我想看到了转换后的代码，估计大家就豁然开朗了。</p><ol><li><p>{}内部修改的是let定义的块级a，跟外部没关系。</p></li><li><p>所以 a = 1 的时候，外部其实还是为0。</p></li><li><p>外部的全局a原本为0， 被window.a = a 同步为了1.</p></li><li><p>a =21 块级a变成了21，全局a无变化还是1.</p></li></ol><p><strong>那么为啥会这么转换呢????</strong>  </p><h3 id="实质"><a href="#实质" class="headerlink" title="实质"></a>实质</h3><ol><li><p>函数声明会被提升到<strong>块级作用域</strong>顶部。</p></li><li><p>使用了类似let的方式定义了一个<strong>块级作用域</strong>的函数<strong>同名变量</strong>，并赋值。（个人总结）</p></li><li><p>函数声明的<strong>变量被声明</strong>到了<strong>全局作用域</strong>（或者函数作用域）顶部。</p></li><li><p>在函数<strong>声明的位置</strong>，会将目前<strong>块级作用域内的变量的值</strong>，<strong>同步</strong>到全局作用域（函数作用域）下。</p></li></ol><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>如下标记 1234 ，我想这样是最直观的。</p><p>（window 代表的外层的作用域上下文，意思是if块所在的作用域，因为此处为全局，所以为window）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> a; <span class="comment">// 3</span></span><br><span class="line">   <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">       <span class="keyword">let</span> a = <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">       <span class="comment">// 1，2</span></span><br><span class="line">       &#125;</span><br><span class="line">       a = <span class="number">1</span>; </span><br><span class="line">       <span class="built_in">window</span>.a = a;  <span class="comment">// 4：此处为原函数声明的位置</span></span><br><span class="line">       a = <span class="number">21</span>;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">"里面"</span>,a);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"外部"</span>,a);</span><br></pre></td></tr></table></figure><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"> </span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换为es5为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以经过我的查找，所有人都不推荐直接在块级作用域内进行函数声明，如果非要，就请使用es5的函数表达式写法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h3&gt;&lt;p&gt;在一篇文章里看到这样一个问题。&lt;a href=&quot;https://mp.weixin.qq.com/s/MlKRNfK3blGJA7bfXzd
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.zsfmyz.top/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.zsfmyz.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 每日一题 旋转矩阵 （逆列 =&gt; 行）</title>
    <link href="http://www.zsfmyz.top/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/leetcode.%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/"/>
    <id>http://www.zsfmyz.top/Algorithm/每日一题/leetcode.旋转矩阵/</id>
    <published>2020-04-07T09:59:13.000Z</published>
    <updated>2020-04-24T07:48:39.852Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。</p><blockquote><p>不占用额外内存空间能否做到？</p></blockquote><p>示例 1:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix = </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br></pre></td></tr></table></figure></p><p>原地旋转输入矩阵，使其变为:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>目标阵列的每一<strong>横列</strong>为对应原始阵列每一<strong>竖列</strong>的<strong>倒序</strong>。</p><h3 id="题解一："><a href="#题解一：" class="headerlink" title="题解一："></a>题解一：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @param &#123;number[][]&#125; matrix</span><br><span class="line"> * @return &#123;void&#125; Do not return anything, modify matrix in-place instead.</span><br><span class="line"> */</span><br><span class="line">var rotate = function(matrix) &#123;</span><br><span class="line">    let N = matrix.length;</span><br><span class="line">   let newM = []</span><br><span class="line">    for (let i = 0; i &lt; N; i++) &#123;</span><br><span class="line">        newM[i] = Array.from(matrix[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i = 0; i &lt; N; i++) &#123;</span><br><span class="line">        for(let j = 0; j &lt; N; j++) &#123;</span><br><span class="line">            matrix[i][j] = newM [N - j - 1][i]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="题解二：不创建新的数组空间"><a href="#题解二：不创建新的数组空间" class="headerlink" title="题解二：不创建新的数组空间"></a>题解二：不创建新的数组空间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @param &#123;number[][]&#125; matrix</span><br><span class="line"> * @return &#123;void&#125; Do not return anything, modify matrix in-place instead.</span><br><span class="line"> */</span><br><span class="line">var rotate = function(matrix) &#123;</span><br><span class="line">    let N = matrix.length;</span><br><span class="line">    for (let i = 0; i &lt; N; i++) &#123;</span><br><span class="line">        for(let j = 0; j &lt; N; j++) &#123;</span><br><span class="line">            matrix[i][j + N] = matrix[N - j - 1][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i = 0; i &lt; N; i++) &#123;</span><br><span class="line">        matrix[i] = matrix[i].slice(N, 2*N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>事实上这种方法是取巧了的，数组扩容了。数组检测到需要扩容时，就会开辟新的内存空间，最终大小为1.5倍+16。当数组内存空间&gt;=length*2+16的时候会进行缩容。如果数组长度比之前缩短了1，则只回收多余容量的一半，若长度比之前缩小的更多，则全部回收多余容量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/categories/Algorithm/"/>
    
      <category term="每日一题" scheme="http://www.zsfmyz.top/categories/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_289.生命游戏：巧妙处理边界问题。</title>
    <link href="http://www.zsfmyz.top/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/leetcode_289.%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/"/>
    <id>http://www.zsfmyz.top/Algorithm/每日一题/leetcode_289.生命游戏/</id>
    <published>2020-04-03T09:59:13.000Z</published>
    <updated>2020-04-24T07:47:18.524Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/game-of-life/" target="_blank" rel="noopener">题目描述</a></h3><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>其实这道题，大家看到第一眼应该就知道很简单了。</p><p>同时更新的意思就是让我们拷贝一份数据备用嘛，</p><p>根据原版备份数据去更新新的细胞阵列。</p><ol><li>boardBak = copy(board)</li></ol><p>然后看看核心思路</p><ol><li>统计8个位置的1的个数</li><li>==3 那肯定要活着， ==2 自生自灭，其他情况都嗝屁</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">boardBak[y-1][x-1] + </span><br><span class="line">boardBak[y+1][x+1] + </span><br><span class="line">boardBak[y-1][x] + </span><br><span class="line">boardBak[y][x-1] + </span><br><span class="line">boardBak[y-1][x+1] + </span><br><span class="line">boardBak[y+1][x-1] + </span><br><span class="line">boardBak[y][x+1] + </span><br><span class="line">boardBak[y+1][x];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if (sum === 3) &#123;</span><br><span class="line">    board[y][x] = 1;</span><br><span class="line">&#125; else if(sum !== 2) &#123;</span><br><span class="line">    board[y][x] = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>so 核心的部分就是这些，一点难度都没有。</p><p>然后假定m为行数，n为列数，将下面的循环包裹在核心代码外，就ok了</p><p>for (y=0, y &lt; m)<br>  for (x=0, x &lt; n)</p><p>是不是很简单！！</p><p>但是可恶的是，报错了。。因为边边上的细胞不够8个。。</p><p>那怎么办呢。。</p><p>我是这个样子处理的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,1],</span><br><span class="line">  [1,1,1],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">====&gt;</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [0,0,1,0,0],</span><br><span class="line">  [0,0,1,0,0],</span><br><span class="line">  [0,0,0,1,0],</span><br><span class="line">  [0,1,1,1,0],</span><br><span class="line">  [0,0,0,0,0],</span><br><span class="line">  [0,0,0,0,0],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>看粗来了吗</p><p>我用了一圈死细胞（0）把我们的目标组织包裹起来了，这样不管是边界细胞还是里面的细胞，大家都可以统一的按照8个周边处理咯</p><p>当然我们不要直接改造目标细胞，而是改造备份细胞。</p><p>改造完之后，只需要改变一下循环条件，目的是为了从(1,1)坐标的细胞开始遍历到(m-1,n-1)，不去遍历我们包裹的边界。</p><p>for (y=1, y &lt; m-1)<br>  for (x=1, x &lt; n-1)</p><pre><code>同样的现在我们的原阵列跟备份阵列的坐标存在不同咯。备份阵列因为多了一层，所以，需要-1之后才是备份细胞在原阵列中的位置。if (sum === 3) {       board[y-1][x-1] = 1;   } else if(sum !== 2) {       board[y-1][x-1] = 0;   }</code></pre><p>到此就完事儿了。</p><p>下面是具体实现。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">board</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gameOfLife = <span class="function"><span class="keyword">function</span>(<span class="params">board</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> boardBak = [];</span><br><span class="line">    <span class="keyword">let</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">     board.map(<span class="function">(<span class="params">row</span>)=&gt;</span>&#123;</span><br><span class="line">        boardBak.push([<span class="number">0</span>, ...row, <span class="number">0</span>]);</span><br><span class="line">    &#125;)</span><br><span class="line">    boardBak = [<span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">2</span>).fill(<span class="number">0</span>), ...boardBak, <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">2</span>).fill(<span class="number">0</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> m = boardBak.length;</span><br><span class="line">    n = boardBak[<span class="number">0</span>].length;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> y = <span class="number">1</span>; y &lt; m - <span class="number">1</span>; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="number">1</span>; x &lt; n - <span class="number">1</span>; x++) &#123;</span><br><span class="line">            <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">            sum = boardBak[y<span class="number">-1</span>][x<span class="number">-1</span>] + </span><br><span class="line">            boardBak[y+<span class="number">1</span>][x+<span class="number">1</span>] + </span><br><span class="line">            boardBak[y<span class="number">-1</span>][x] + </span><br><span class="line">            boardBak[y][x<span class="number">-1</span>] + </span><br><span class="line">            boardBak[y<span class="number">-1</span>][x+<span class="number">1</span>] + </span><br><span class="line">            boardBak[y+<span class="number">1</span>][x<span class="number">-1</span>] + </span><br><span class="line">            boardBak[y][x+<span class="number">1</span>] + </span><br><span class="line">            boardBak[y+<span class="number">1</span>][x];</span><br><span class="line">            <span class="keyword">if</span> (sum === <span class="number">3</span>) &#123;</span><br><span class="line">                board[y<span class="number">-1</span>][x<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(sum !== <span class="number">2</span>) &#123;</span><br><span class="line">                board[y<span class="number">-1</span>][x<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> board;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/game-of-life/&quot; target=&quot;_blank&quot; r
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/categories/Algorithm/"/>
    
      <category term="每日一题" scheme="http://www.zsfmyz.top/categories/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode_226. 翻转二叉树</title>
    <link href="http://www.zsfmyz.top/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/leetcode_226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://www.zsfmyz.top/Algorithm/每日一题/leetcode_226.翻转二叉树/</id>
    <published>2020-03-26T03:59:13.000Z</published>
    <updated>2020-04-15T07:40:23.891Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>翻转一棵二叉树。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   3 6   9</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  7     2</span><br><span class="line"> / \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>递归，递归判断条件1. 左右节点是否为null，不为null，则翻转其左右节点</code></pre><a id="more"></a><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;TreeNode&#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">function ex(treeNode) &#123;</span><br><span class="line">    if (treeNode == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    let item = treeNode.left;</span><br><span class="line">    treeNode.left = treeNode.right;</span><br><span class="line">    treeNode.right = item;</span><br><span class="line">    treeNode.left &amp;&amp; ex(treeNode.left)</span><br><span class="line">    treeNode.right &amp;&amp; ex(treeNode.right)</span><br><span class="line">&#125;</span><br><span class="line">var invertTree = function(root) &#123;</span><br><span class="line">    ex(root)</span><br><span class="line">    return root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目解析&quot;&gt;&lt;a href=&quot;#题目解析&quot; class=&quot;headerlink&quot; title=&quot;题目解析&quot;&gt;&lt;/a&gt;题目解析&lt;/h3&gt;&lt;p&gt;翻转一棵二叉树。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;p&gt;示例 1:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   /   \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  2     7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; / \   / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1   3 6   9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   /   \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  7     2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; / \   / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9   6 3   1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;解题思路&quot;&gt;&lt;a href=&quot;#解题思路&quot; class=&quot;headerlink&quot; title=&quot;解题思路&quot;&gt;&lt;/a&gt;解题思路&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;递归，递归判断条件
1. 左右节点是否为null，不为null，则翻转其左右节点
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/categories/Algorithm/"/>
    
      <category term="每日一题" scheme="http://www.zsfmyz.top/categories/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Vue双向数据绑定原理及实现</title>
    <link href="http://www.zsfmyz.top/Vue/Vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.zsfmyz.top/Vue/Vue双向数据绑定原理及实现/</id>
    <published>2020-03-14T08:59:13.000Z</published>
    <updated>2020-03-27T09:56:43.174Z</updated>
    
    <content type="html"><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>vue实现双向绑定原理，主要是利用Object.defineProperty 来给实例data的属性添加 setter和getter.<br>并通过发布订阅模式（一对多的依赖关系，当状态发生改变，它的所有依赖都将被通知）来实现响应。</p><p>这个环节中包含了三个部分</p><ul><li><p>Observer 用来监听拦截data的属性为监察者。 </p></li><li><p>Dep用来添加订阅者，为订阅器</p></li><li><p>Watcher 就是订阅者</p></li></ul><p>监察者通过 Dep 向 Watcher发布更新消息</p> <a id="more"></a><h4 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h4><p>那么首先</p><ol><li>通过对set和get的拦截，在get阶段进行依赖收集，在set阶段对通知该属性上所啊绑定的依赖。</li></ol><p>如下我们就已经实现了一个简单的双向绑定了。</p><p>我们将data的value属性绑定上set和get，通过 _value 来进行操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- HTML部分 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;input type=&quot;text&quot; id=&quot;inp&quot; oninput=&quot;inputFn(this.value)&quot;&gt;</span><br><span class="line">&lt;div id=&apos;div&apos;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- JS部分 --&gt;</span><br><span class="line">var inp = document.getElementById(&apos;inp&apos;);</span><br><span class="line">var div = document.getElementById(&apos;div&apos;);</span><br><span class="line">var data = &#123;</span><br><span class="line">    value:&apos;&apos;</span><br><span class="line">&#125;</span><br><span class="line">  Object.defineProperty(data, &apos;value&apos;, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    set: function (newValue) &#123;</span><br><span class="line">        this._value = newValue; </span><br><span class="line">        div.innerText = data._value = value; //watcher</span><br><span class="line">    &#125;,</span><br><span class="line">    get: function () &#123;</span><br><span class="line">        return this._value; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">function inputFn(value) &#123;</span><br><span class="line">  data._value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果只是实现一个简单的双向绑定那么上面的代码就已经实现了。</p><h4 id="进一步完善模拟vue实现"><a href="#进一步完善模拟vue实现" class="headerlink" title="进一步完善模拟vue实现"></a>进一步完善模拟vue实现</h4><p>首先我们将watcher抽出来 备用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function watcher(params) &#123;</span><br><span class="line">  div.innerText = inp.value = params; // 派发watcher</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明一个vm来模拟vue的实例,并初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var vm = &#123;</span><br><span class="line"></span><br><span class="line">    //类似vue实例上的data</span><br><span class="line">    data: &#123;</span><br><span class="line">        value: &apos;&apos;</span><br><span class="line">    &#125;, </span><br><span class="line"></span><br><span class="line">    // vue私有, _data的所有属性为data中的所有属性被改造为 getter/setter 之后的。</span><br><span class="line">    _data: &#123;</span><br><span class="line">        value: &apos;&apos;</span><br><span class="line">    &#125;, </span><br><span class="line"></span><br><span class="line">    // 代理到vm对象上，可以实现vm.value</span><br><span class="line">    value: &apos;&apos;, </span><br><span class="line"></span><br><span class="line">    //value的订阅器用来收集订阅者 </span><br><span class="line">    valueWatchers:[] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历其data上的属性 进行改造 这里我们还是只举一个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 利用 Object.defineProperty 定义一个属性 (eg：value) 描述符为存取描述符的属性</span><br><span class="line">Object.defineProperty(vm._data, &apos;value&apos;, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    set: function (newValue) &#123; //set 派发watchers</span><br><span class="line">      vm.data.value = newValue; </span><br><span class="line">      vm.valueWatchers.map(fn =&gt; fn(newValue));</span><br><span class="line">    &#125;,</span><br><span class="line">    get: function () &#123; </span><br><span class="line">        </span><br><span class="line">        // 收集wachter vue中会在compile解析器中通过 显示调用 (this.xxx) 来触发get进行收集</span><br><span class="line">        vm.valueWatchers.length = 0; </span><br><span class="line">        vm.valueWatchers.push(watcher); </span><br><span class="line">        return vm.data.value; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">  &lt;!--直接通过显示调用来触发get进行绑定 vue中是在compile解析器中来进行这一步--&gt;</span><br><span class="line">  vm._data.value</span><br></pre></td></tr></table></figure><p>进行到这儿也已经实现了绑定，但是我们平时使用vue ，都是可以直接通过 this.xxx来获取和定义数据</p><p>那么我们还需要进行一步Proxy 代理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Object.defineProperty(vm, &apos;value&apos;, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    set: function (newValue) &#123;</span><br><span class="line">        this._data.value = newValue; //借助</span><br><span class="line">    &#125;,</span><br><span class="line">    get: function () &#123;</span><br><span class="line">        return this._data.value; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样我们就把vm._data.value 代理到vm.value上了，可以通过其直接操作了。</p><p>那么按照官方的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function proxy (target, sourceKey, key) &#123;</span><br><span class="line">    Object.defineProperty(target, key, &#123;</span><br><span class="line">        enumerable: true,</span><br><span class="line">        configurable: true,</span><br><span class="line">        get() &#123;</span><br><span class="line">            return this[sourceKey][key];</span><br><span class="line">        &#125;,</span><br><span class="line">        set(val) &#123;</span><br><span class="line">            this[sourceKey][key] = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">proxy(vm, &apos;_data&apos;, &apos;value&apos;);</span><br></pre></td></tr></table></figure><h4 id="完善后的完整代码"><a href="#完善后的完整代码" class="headerlink" title="完善后的完整代码"></a>完善后的完整代码</h4><p>以下为整个页面，可以直接运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;双向绑定简单实现&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; id=&quot;inp&quot; oninput=&quot;inputFn(this.value)&quot;&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; id=&quot;inp2&quot; oninput=&quot;inputFn(this.value)&quot;&gt;</span><br><span class="line">&lt;div id=&apos;div&apos;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var inp = document.getElementById(&apos;inp&apos;);</span><br><span class="line">    var inp2 = document.getElementById(&apos;inp2&apos;);</span><br><span class="line">    var div = document.getElementById(&apos;div&apos;);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    function inputFn(value) &#123;</span><br><span class="line">        div.innerText = vm.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function watcher(params) &#123;</span><br><span class="line">        console.log(1)</span><br><span class="line">        div.innerText = inp.value = params; // 派发watcher</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function watcher2(params) &#123;</span><br><span class="line">        console.log(2)</span><br><span class="line"></span><br><span class="line">        div.innerText = inp2.value = params; // 派发watcher</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function proxy (target, sourceKey, key) &#123;</span><br><span class="line">        Object.defineProperty(target, key, &#123;</span><br><span class="line">            enumerable: true,</span><br><span class="line">            configurable: true,</span><br><span class="line">            get() &#123;</span><br><span class="line">                return this[sourceKey][key];</span><br><span class="line">            &#125;,</span><br><span class="line">            set(val) &#123;</span><br><span class="line">                this[sourceKey][key] = val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var vm = &#123;</span><br><span class="line">        data: &#123;&#125;,</span><br><span class="line">        _data: &#123;&#125;,</span><br><span class="line">        value: &apos;&apos;, </span><br><span class="line">        valueWatchers: [] </span><br><span class="line">    &#125;</span><br><span class="line">    Object.defineProperty(vm._data, &apos;value&apos;, &#123;</span><br><span class="line">        enumerable: true,</span><br><span class="line">        configurable: true,</span><br><span class="line">        set: function (newValue) &#123;</span><br><span class="line">            vm.data.value = newValue; </span><br><span class="line">            vm.valueWatchers.map(fn =&gt; fn(newValue));</span><br><span class="line">        &#125;,</span><br><span class="line">        get: function () &#123;</span><br><span class="line">            vm.valueWatchers = []; //防止重复添加, </span><br><span class="line">            vm.valueWatchers.push(watcher); </span><br><span class="line">            vm.valueWatchers.push(watcher2); </span><br><span class="line">            return vm.data.value; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    proxy(vm, &apos;_data&apos;, &apos;value&apos;);</span><br><span class="line"></span><br><span class="line">    vm.value;  //显示调用绑定</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>再多讲一点。实际上vue在初始化的时候是用解析器解析过程中将wathcer进行绑定的。</p><p>它会利用一个全局的Dep.target = watcher </p><p>然后在get收集中，只收集全局上Dep.target, 添加完毕后会重新初始化全局Dep.target = null;</p><p>类似如下操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Dep.target = watcher;</span><br><span class="line">vm.value;    // 触发get =&gt; Dep.target &amp;&amp; valueWatchers.push(Dep.target);</span><br><span class="line">Dep.target = null;</span><br></pre></td></tr></table></figure><p>这样也会防止我们在调用时触发get重复去添加watcher。</p><p>而我们的例子中只是每次都初始化为[]. 实际订阅器也不只是一个watcher数组。 </p><p>此例跟官方实现还是有很多差距，只是简单模拟。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h4&gt;&lt;p&gt;vue实现双向绑定原理，主要是利用Object.defineProperty 来给实例data的属性添加 setter和getter.&lt;br&gt;并通过发布订阅模式（一对多的依赖关系，当状态发生改变，它的所有依赖都将被通知）来实现响应。&lt;/p&gt;
&lt;p&gt;这个环节中包含了三个部分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Observer 用来监听拦截data的属性为监察者。 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Dep用来添加订阅者，为订阅器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Watcher 就是订阅者&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;监察者通过 Dep 向 Watcher发布更新消息&lt;/p&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://www.zsfmyz.top/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://www.zsfmyz.top/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>定时器中的异步请求堆积如何解决？</title>
    <link href="http://www.zsfmyz.top/JavaScript/%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E5%A0%86%E7%A7%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F/"/>
    <id>http://www.zsfmyz.top/JavaScript/定时器中的异步请求堆积如何解决？/</id>
    <published>2020-03-14T04:50:34.000Z</published>
    <updated>2020-04-15T07:40:23.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>有时候我们需要用setinterval来执行一些异步操作来刷新页面的信息。但是如果一旦异步函数的请求时间过长，就会造成事件操作堆积。</p><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">this.interval = setInterval(async () =# &#123;</span><br><span class="line">      const resp = await ajax();</span><br><span class="line">      this.rows = resp.rows;</span><br><span class="line">    &#125;, 5000);</span><br></pre></td></tr></table></figure><p>假设ajax()请求的时间因为网络或者其他原因超过了5秒，定时器并不会等待其返回结果，而是依旧会进行下一次循环，这样的话，其实定时器和异步请求之间的时序并没有联系顺序也毫无规律，那么我们如何实现等本次ajax请求完毕之后等待一段时间之后再进行下一次循环呢？</p><a id="more"></a><h3 id="1-简单代码实现"><a href="#1-简单代码实现" class="headerlink" title="1.简单代码实现"></a>1.简单代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function setIntervalWaitable(callback,ms)&#123;</span><br><span class="line">    this._self = &#123;</span><br><span class="line">        fn: callback,</span><br><span class="line">        timeout: ms,</span><br><span class="line">        timeoutHandler: null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">setIntervalWaitable.prototype.request = function() &#123;</span><br><span class="line">    if (this._self.timeoutHandler) &#123;</span><br><span class="line">        clearTimeout(this._self.timeoutHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this._self.timeoutHandler = setTimeout(() =&gt; &#123;</span><br><span class="line">        this._self.fn();</span><br><span class="line">    &#125;, this._self.timeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 模拟执行 --&gt;</span><br><span class="line">&lt;!-- let ms = 2000;</span><br><span class="line">let asyncMs = 1000;</span><br><span class="line">var set = new setIntervalWaitable(()=&gt;&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        set.request()</span><br><span class="line">    &#125;, asyncMs)</span><br><span class="line">&#125;, ms)</span><br><span class="line">set.request() --&gt;</span><br></pre></td></tr></table></figure><p>达到如下效果的异步刷新时序图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rfn########----------------rfn##----------------rfn########################----------------rfn####</span><br><span class="line">-----------5000ms##########-----5000ms##########---------------------------5000ms##########</span><br></pre></td></tr></table></figure><h3 id="2-改造："><a href="#2-改造：" class="headerlink" title="2. 改造："></a>2. 改造：</h3><ul><li>等待传入的ms时间，如果此时callback已经完成，重新执行callback</li><li>否则，等待callback完成，再重新执行callback</li></ul><p>例如500ms周期时序图:<br>rpc########—-rpc############rpc########################rpc####——–rpc######——rpc####<br>500ms##########500ms##########500ms##########————500ms##########500ms##########</p><h4 id="实现思路："><a href="#实现思路：" class="headerlink" title="实现思路："></a>实现思路：</h4><p>在第一题的基础上，在异步函数调用settimeout之前判断异步函数用时和settimeout的时间大小，计算差值，以差值作为下次定时器执行的时间。 如果异步函数用时大于定时器设定时间，直接执行下次异步函数即可</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function setIntervalWaitable2(callback,ms)&#123;</span><br><span class="line">    this._self = &#123;</span><br><span class="line">        fn: callback,</span><br><span class="line">        timeout: ms,</span><br><span class="line">        timeoutHandler: null,</span><br><span class="line">        start: null,</span><br><span class="line">        duration: null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">setIntervalWaitable2.prototype.request = function() &#123;</span><br><span class="line">    let that = this;</span><br><span class="line">    let timeout = 0; //首次直接执行事件</span><br><span class="line"></span><br><span class="line">    if (that._self.timeoutHandler) &#123;</span><br><span class="line">        clearTimeout(that._self.timeoutHandler);</span><br><span class="line">    &#125;</span><br><span class="line">    // 判断</span><br><span class="line">    if (that._self.start) &#123; //计算更新timeout值</span><br><span class="line">        that._self.duration = new Date().getTime() - that._self.start;</span><br><span class="line">        if (that._self.duration &lt; that._self.timeout) &#123;</span><br><span class="line">            timeout = that._self.timeout - that._self.duration;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    that._self.timeoutHandler = setTimeout(() =&gt; &#123;</span><br><span class="line">        that._self.start = new Date().getTime();</span><br><span class="line">        that._self.fn();</span><br><span class="line">    &#125;, timeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 模拟执行</span><br><span class="line">let ms = 2000;</span><br><span class="line">let asyncMs = 1000; //假设异步操作时间</span><br><span class="line"></span><br><span class="line">var set = new setIntervalWaitable2(()=&gt;&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(&apos;函数执行&apos; + new Date().getSeconds())</span><br><span class="line">        set.request()</span><br><span class="line">    &#125;, asyncMs)</span><br><span class="line">&#125;, ms)</span><br><span class="line">set.request()  --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 实际执行 --&gt;</span><br><span class="line"></span><br><span class="line"> &lt;!-- 实际执行 --&gt;</span><br><span class="line">created() &#123;</span><br><span class="line">      this.interval = new setIntervalWaitable2(()=&gt;&#123;</span><br><span class="line">          const resp = await getNewStatistics();</span><br><span class="line">          this.rows = resp.rows;</span><br><span class="line">          this.interval.request()</span><br><span class="line">      &#125;, 500)</span><br><span class="line">      this.interval.request() //执行</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="3-实现暂停和重启"><a href="#3-实现暂停和重启" class="headerlink" title="3. 实现暂停和重启"></a>3. 实现暂停和重启</h3><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路:"></a>实现思路:</h4><p>增加flag判断即可。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">  function setIntervalWaitable3(callback,ms)&#123;</span><br><span class="line">      this._self = &#123;</span><br><span class="line">          fn: callback,</span><br><span class="line">          timeout: ms,</span><br><span class="line">          timeoutHandler: null,</span><br><span class="line">          timeoutEnabled: true,</span><br><span class="line">          start: null,</span><br><span class="line">          duration: null</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  setIntervalWaitable3.prototype.request = function() &#123;</span><br><span class="line">      let that = this;</span><br><span class="line">      let timeout = 0;</span><br><span class="line"></span><br><span class="line">      if (!that._self.timeoutEnabled) &#123;</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (that._self.timeoutHandler) &#123;</span><br><span class="line">          clearTimeout(that._self.timeoutHandler);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      that._self.duration = new Date().getTime() - that._self.start;</span><br><span class="line"></span><br><span class="line">      if (that._self.duration &lt; that._self.timeout) &#123;</span><br><span class="line">          timeout = that._self.timeout - that._self.duration;</span><br><span class="line">      &#125;</span><br><span class="line">      that._self.timeoutHandler = setTimeout(() =&gt; &#123;</span><br><span class="line">          that._self.start = new Date().getTime();</span><br><span class="line">          that._self.fn();</span><br><span class="line">      &#125;, timeout);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setIntervalWaitable3.prototype.stop = function() &#123;</span><br><span class="line">      this._self.timeoutEnabled = false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  setIntervalWaitable3.prototype.restart = function() &#123;</span><br><span class="line">      this._self.timeoutEnabled = true;</span><br><span class="line">this.request()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 模拟执行 --&gt;</span><br><span class="line">  &lt;!-- let ms = 2000;</span><br><span class="line">  let asyncMs = 1000; //假设异步操作时间</span><br><span class="line"></span><br><span class="line">  var set = new setIntervalWaitable3(()=&gt;&#123;</span><br><span class="line">      setTimeout(function()&#123;</span><br><span class="line">          console.log(&apos;函数执行&apos; + new Date().getSeconds())</span><br><span class="line">          set.request()</span><br><span class="line">      &#125;, asyncMs)</span><br><span class="line">  &#125;, ms)</span><br><span class="line">  set.request() //执行 --&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;!-- 实际执行 --&gt;</span><br><span class="line"></span><br><span class="line">  created() &#123;</span><br><span class="line">      this.interval = new setIntervalWaitable3(()=&gt;&#123;</span><br><span class="line">          const resp = await getNewStatistics();</span><br><span class="line">          this.rows = resp.rows;</span><br><span class="line">          this.interval.request()</span><br><span class="line">      &#125;, 500)</span><br><span class="line">      this.interval.request() //执行</span><br><span class="line">  &#125;</span><br><span class="line">  destroyed() &#123;</span><br><span class="line">      this.interval.stop();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如上实现过程，思路很简单，就是在异步请求结束后手动调起下次循环，这样才能保证时序性。（当然我现在也只能想到这种办法，无论怎么考虑，第二次循环始终需要异步请求结尾处调用。）</p><p>目前我已经将该功能进行了封装，对其功能进行了一部分添加和完善。包括两种循环模式。</p><blockquote><p>详情  <a href="&quot;https://github.com/lunhui1994/async-loop-timer&quot;">Github 项目</a></p></blockquote><blockquote><p>npm 使用</p></blockquote><blockquote><p>npm i async-loop-timer</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;有时候我们需要用setinterval来执行一些异步操作来刷新页面的信息。但是如果一旦异步函数的请求时间过长，就会造成事件操作堆积。&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;this.interval = setInterval(async () =# &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      const resp = await ajax();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      this.rows = resp.rows;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;, 5000);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;假设ajax()请求的时间因为网络或者其他原因超过了5秒，定时器并不会等待其返回结果，而是依旧会进行下一次循环，这样的话，其实定时器和异步请求之间的时序并没有联系顺序也毫无规律，那么我们如何实现等本次ajax请求完毕之后等待一段时间之后再进行下一次循环呢？&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.zsfmyz.top/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.zsfmyz.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Vue性能优化方案</title>
    <link href="http://www.zsfmyz.top/Vue/Vue%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"/>
    <id>http://www.zsfmyz.top/Vue/Vue性能优化方案/</id>
    <published>2020-03-10T09:05:27.000Z</published>
    <updated>2020-03-27T09:56:43.174Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote><p>总结一下使用Vue涉及到的性能优化方法，从我实践和查阅资源总结出来的集合。</p></blockquote><p>目录：</p><ol><li><strong>v-if 和 v-show</strong><ol><li><strong>v-if</strong></li><li><strong>v-show</strong></li></ol></li><li><strong>computed 和 watch</strong></li><li><strong>v-for加key，避免使用v-if</strong></li><li><strong>keepalive</strong></li><li><strong>Object.freeze长列表优化</strong></li></ol><a id="more"></a><h3 id="一、-v-if-和-v-show"><a href="#一、-v-if-和-v-show" class="headerlink" title="一、 v-if 和 v-show"></a>一、 v-if 和 v-show</h3><ul><li>一般使用过vue或者angular及其相同框架的人都会知道他们的区别。</li></ul><h5 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h5><p>它是真正的条件判断语句，会根据条件对条件内的组件进行重建和销毁。<br>它是惰性的，在第一次判断条件为true时，才会去创建相应的组件。即初始化为false时，该条件内组件不会加载。</p><h5 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h5><p>它仅仅是通过控制css的display属性来控制组件的显示和隐藏。<br>所以，无论是否为false，该组件都会在页面构建时加载。</p><h4 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h4><p>我们可以在需要<em>频繁切换</em>显示隐藏的组件上使用v-show，在只需要<em>一次或少数判断</em>的时候使用v-if。</p><h3 id="二、-computed-和-watch"><a href="#二、-computed-和-watch" class="headerlink" title="二、 computed 和 watch"></a>二、 computed 和 watch</h3><ul><li>computed 和 watch 都可以对个变量进行监听依赖，但是用法上还是有很大区别的。</li></ul><p>如 name = ‘xiaoming’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123; name.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>如上我们想把name反转，如此写在html中略显混乱，并对阅读不友好。</p><h5 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h5><p>它表示计算属性，目的是用来方便控制需要计算之后再进行展示的数据。<br>computed属性会被缓存，只有computed所依赖的属性发生变化之后，才会触发computed重新计算。</p><p>使用computed</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123; nameReverse &#125;&#125;&lt;/div&gt;</span><br><span class="line">// ...</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            name: &apos;xiaoming&apos;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        nameReverse: &#123;</span><br><span class="line">            get: function () &#123;</span><br><span class="line">                    return this.name.split(&apos;&apos;).reverse().join(&apos;&apos;);</span><br><span class="line">                &#125;,</span><br><span class="line">            set: function (newValue) &#123;</span><br><span class="line">                    //同时computed也有set函数，可以在计算变量赋值时触发。</span><br><span class="line">                    //this.name = ...</span><br><span class="line">                &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><h5 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h5><p>watch事实上就是一个监听函数，通过监听该变量来执行一些更加复杂的操作。它是比computed更耗费性能的。</p><p>注意watch在进入页面之后是不会立即触发的。</p><p>使用watch</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123; nameReverse &#125;&#125;&lt;/div&gt;</span><br><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        name: &apos;xiaoming&apos;,</span><br><span class="line">        nameReverse: &apos;&apos; //定义</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;,</span><br><span class="line">method: &#123;</span><br><span class="line">    nameHandler: function (newQuestion, oldQuestion) &#123;</span><br><span class="line">            this.nameReverse = newQuestion.split(&apos;&apos;).reverse().join(&apos;&apos;);</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;</span><br><span class="line">watch: &#123;</span><br><span class="line">    // &apos;obj.name&apos;: &apos;xxxhandler&apos; 也可以监听深层属性  </span><br><span class="line">    name:&#123; </span><br><span class="line">        handler: &quot;nameHandler&quot;,</span><br><span class="line">        immediate: true //该属性设置之后watch会以当前值立即触发回调函数。</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化：-1"><a href="#优化：-1" class="headerlink" title="优化："></a>优化：</h4><p>所以我们可以根据computed和watch的不同用法，来区分使用场景。<br>当我们仅仅需要获取一个通过一系列操作后的计算结果，我们应该使用computed。<br>当我们需要在属性变化时进行更加复杂的操作，比如异步操作，设置中间状态进行节流等，这些都需要使用watch实现。</p><h3 id="三、-v-for-和-key-避免使用v-if"><a href="#三、-v-for-和-key-避免使用v-if" class="headerlink" title="三、 v-for 和 key 避免使用v-if"></a>三、 v-for 和 key 避免使用v-if</h3><ul><li>我们都知道使用v-for的时候要在每个节点加上唯一的key值，否则即采用就地复用的原则，同时避免使用v-if使用computed来代替。</li></ul><h5 id="不加key"><a href="#不加key" class="headerlink" title="不加key"></a>不加key</h5><p>官方文档对key的解释很清楚，key的用途主要用于虚拟DOM对比时对vnode进行辨别。</p><p>那么不加key的就地复用是什么意思呢?<br>即当节点被删除或者位置被移动，节点不会被删除或者替换。<br>虚拟DOM将会遍历vnode，直接更改其内容。（该操作是高效的）<br>但是其只适用于渲染列表Dom结构极其简单的情况。</p><h5 id="加key"><a href="#加key" class="headerlink" title="加key"></a>加key</h5><p>加上key之后，对vnode增加了独特的标记，虚拟DOM的对比将不会再遍历vnodes，而是直接采用key的映射进行对比。<br>将会基于key冲i性能排序元素顺序，删除key不存在的节点，替换和删除节点。<br>它也能触发完整的生命周期函数。</p><h5 id="v-if-和-computed"><a href="#v-if-和-computed" class="headerlink" title="v-if 和 computed"></a>v-if 和 computed</h5><p>如果我们的列表只需要渲染其中的一部分，我们可以使用computed，即通过computed对最终显示数据进行过滤，而非在html中进行if判断过滤。</p><h4 id="优化：-2"><a href="#优化：-2" class="headerlink" title="优化："></a>优化：</h4><p>官方建议：建议尽可能在使用 v-for 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。<br>注意： key值需使用使用string和数值型基础类型，不要使用对象数组等复杂类型。同时key值需要独特性。可以使用列如id属性作为key。</p><h3 id="四、-keepalive"><a href="#四、-keepalive" class="headerlink" title="四、 keepalive"></a>四、 keepalive</h3><p>使用keep-alive包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们；<br>keep-alive是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中；</p><h4 id="使用keepalive"><a href="#使用keepalive" class="headerlink" title="使用keepalive"></a>使用keepalive</h4><p>当组件在 <keep-alive> 内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行。<br>可以保存组件的状态，比如一个下拉框，选择了第二项，切换其他组件再返回时依旧是第二个组件。<br>防止组件重复的销毁和重建。</keep-alive></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- include表示匹配要缓存的组件名称，exclude表示不缓存的组件名称，exclude优先级更高。 max表示最大缓存数 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;keep-alive :include=&quot;&quot; :exclude=&quot;&quot; :max=&quot;&quot;&gt;</span><br><span class="line">  &lt;comp-a v-if=&quot;a &gt; 1&quot;&gt;&lt;/comp-a&gt;</span><br><span class="line">  &lt;comp-b v-else&gt;&lt;/comp-b&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><h4 id="keepalive-多了解一点"><a href="#keepalive-多了解一点" class="headerlink" title="keepalive 多了解一点"></a>keepalive 多了解一点</h4><p>keepalive是vue的一个组件，它自己的生命周期有created和destoryed,。</p><p><strong>created</strong>用来创建一个cache用来保存需要缓存的Vnode节点，和一个keys数组用来保存cache中对应的key值。<br><strong>destoryed</strong>用来遍历缓存节点并逐个调用$destory()进行销毁。</p><p><strong>rander</strong>首先会获取第一个子组件，获取到名称，然后进行include和exclude过滤，判断是否匹配缓存。<br>如果不符合缓存条件，直接返回vnode，如果符合，则以名称为key值去keys中查找。<br>若命中，则返回cache中的缓存，并将cache中key位置的缓存删除，并添加到cache的末尾。<br>若没命中，则进行缓存并返回vnode，并将其添加至cache尾部。</p><p>返回前会将它们的keepAlive属性设置为true用于后面调用activated与deactivated函数。 </p><p><strong>watch</strong>同时keepalive会监听include和exclude的变化，不存在的key将进行销毁并以出cache列表。</p><p>keepalive 组件本身并不会生成节点，在keep-alive中，设置了 abstract: true ，该属性表示此组件为抽象组件意思就是不会生成实际节点。</p><p><a href="&quot;https://www.cnblogs.com/wangjiachen666/p/11497200.html&quot;">相关荐文</a></p><h4 id="优化：-3"><a href="#优化：-3" class="headerlink" title="优化："></a>优化：</h4><p>如果你的组件需要保持切换前的状态就需要加上keepalive，或者对于频繁切换的组件也需要加上，以保证它避免被销毁，保存渲染状态，提高性能。</p><h3 id="五、-Object-freeze-冻结对象，长列表优化"><a href="#五、-Object-freeze-冻结对象，长列表优化" class="headerlink" title="五、 Object.freeze 冻结对象，长列表优化"></a>五、 Object.freeze 冻结对象，长列表优化</h3><p>有时候我们会有一些比较长的列表要进行展示，而且这些数据展示完之后并不会发生变化。<br>但是vue对数据都是使用了Object.defineProperty进行了数据劫持，所以初始化时就会造成大量的无用劫持。<br>这时候我们就可以使用Object.freeze进行冻结，冻结之后数据就不会再被修改了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.list = Object.freeze(list);</span><br></pre></td></tr></table></figure><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>对一些不需要双向绑定的列表进行Object.freeze()进行冻结，提高性能。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;总结一下使用Vue涉及到的性能优化方法，从我实践和查阅资源总结出来的集合。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目录：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;v-if 和 v-show&lt;/strong&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;v-if&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;v-show&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;computed 和 watch&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;v-for加key，避免使用v-if&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;keepalive&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Object.freeze长列表优化&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://www.zsfmyz.top/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://www.zsfmyz.top/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode_101. 对称二叉树</title>
    <link href="http://www.zsfmyz.top/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/leetcode_101.%20%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://www.zsfmyz.top/Algorithm/每日一题/leetcode_101. 对称二叉树/</id>
    <published>2019-12-12T03:59:13.000Z</published>
    <updated>2020-03-27T09:56:43.175Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目解析："><a href="#题目解析：" class="headerlink" title="题目解析："></a>题目解析：</h3><p>给定一个二叉树，检查它是否是镜像对称的。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,2,3,4,4,3]  对称</span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br><span class="line"></span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,2,null,3,null,3] 非对称</span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line">   \   \</span><br><span class="line">   3    3</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p><p>说明&amp;&amp;进阶:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果你可以运用递归和迭代两种方法解决这个问题，会很加分。</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>递归，递归判断条件1. 左右对称的节点是否相同。2. 递归判断直至叶节点。</code></pre><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">var isSymmetric = function(root) &#123;</span><br><span class="line">    if (root === null) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return fun(root.left, root.right);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var fun = function(left, right) &#123;</span><br><span class="line">    if (left === null &amp;&amp; right === null) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (left === null || right === null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return (left.val === right.val) &amp;&amp; fun(left.left, right.right) &amp;&amp; fun(left.right, right.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目解析：&quot;&gt;&lt;a href=&quot;#题目解析：&quot; class=&quot;headerlink&quot; title=&quot;题目解析：&quot;&gt;&lt;/a&gt;题目解析：&lt;/h3&gt;&lt;p&gt;给定一个二叉树，检查它是否是镜像对称的。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;p&gt;示例 1:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,2,2,3,4,4,3]  对称&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  2   2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; / \ / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3  4 4  3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;示例 2:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,2,2,null,3,null,3] 非对称&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  2   2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   \   \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   3    3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;说明&amp;amp;&amp;amp;进阶:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;如果你可以运用递归和迭代两种方法解决这个问题，会很加分。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/categories/Algorithm/"/>
    
      <category term="每日一题" scheme="http://www.zsfmyz.top/categories/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode_112. 路径总和</title>
    <link href="http://www.zsfmyz.top/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/leetcode_112.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/"/>
    <id>http://www.zsfmyz.top/Algorithm/每日一题/leetcode_112. 路径总和/</id>
    <published>2019-12-12T03:59:13.000Z</published>
    <updated>2020-03-27T09:56:43.175Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目解析："><a href="#题目解析：" class="headerlink" title="题目解析："></a>题目解析：</h3><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给定如下二叉树，以及目标和 sum = 22</span><br><span class="line">              5</span><br><span class="line">             / \</span><br><span class="line">            4   8</span><br><span class="line">           /   / \</span><br><span class="line">          11  13  4</span><br><span class="line">         /  \      \</span><br><span class="line">        7    2      1</span><br><span class="line"></span><br><span class="line">返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</span><br></pre></td></tr></table></figure></p><p>说明&amp;&amp;进阶:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">说明: 叶子节点是指没有子节点的节点。</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>递归，递归判断条件1. 左右对称的节点是否相同。2. 递归判断直至叶节点。</code></pre><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @param &#123;number&#125; sum</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">var hasPathSum = function(root, sum) &#123;</span><br><span class="line">    if (root === null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return fun(root, 0, sum);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var fun = function(root, mysum, sum) &#123;</span><br><span class="line">    root.mysum = root.val + mysum;</span><br><span class="line">    if (root.left === null &amp;&amp; root.right === null)&#123;</span><br><span class="line">       return root.mysum === sum;</span><br><span class="line">    &#125;</span><br><span class="line">    return (root.left &amp;&amp; fun(root.left, root.mysum, sum)) || (root.right &amp;&amp; fun(root.right, root.mysum, sum)) || false; </span><br><span class="line">    // 或（||）会取最后一个转义为false的值。 即可能会出现0，null，undefined等结果</span><br><span class="line">    // 为避免不必要的错误，增加 || false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目解析：&quot;&gt;&lt;a href=&quot;#题目解析：&quot; class=&quot;headerlink&quot; title=&quot;题目解析：&quot;&gt;&lt;/a&gt;题目解析：&lt;/h3&gt;&lt;p&gt;给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;p&gt;示例 1:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给定如下二叉树，以及目标和 sum = 22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            4   8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           /   / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          11  13  4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         /  \      \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        7    2      1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&amp;gt;4-&amp;gt;11-&amp;gt;2。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;说明&amp;amp;&amp;amp;进阶:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;说明: 叶子节点是指没有子节点的节点。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/categories/Algorithm/"/>
    
      <category term="每日一题" scheme="http://www.zsfmyz.top/categories/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/tags/Algorithm/"/>
    
  </entry>
  
</feed>
