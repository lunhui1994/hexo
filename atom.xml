<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eighteen Blog</title>
  
  <subtitle>Eighteen Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.zsfmyz.top/"/>
  <updated>2020-03-27T16:32:54.514Z</updated>
  <id>http://www.zsfmyz.top/</id>
  
  <author>
    <name>赵十八</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode_226. 翻转二叉树</title>
    <link href="http://www.zsfmyz.top/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/leetcode_226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://www.zsfmyz.top/Algorithm/每日一题/leetcode_226.翻转二叉树/</id>
    <published>2020-03-26T03:59:13.000Z</published>
    <updated>2020-03-27T16:32:54.514Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>翻转一棵二叉树。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   3 6   9</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  7     2</span><br><span class="line"> / \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>递归，递归判断条件1. 左右节点是否为null，不为null，则翻转其左右节点</code></pre><a id="more"></a><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;TreeNode&#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">function ex(treeNode) &#123;</span><br><span class="line">    if (treeNode == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    let item = treeNode.left;</span><br><span class="line">    treeNode.left = treeNode.right;</span><br><span class="line">    treeNode.right = item;</span><br><span class="line">    treeNode.left &amp;&amp; ex(treeNode.left)</span><br><span class="line">    treeNode.right &amp;&amp; ex(treeNode.right)</span><br><span class="line">&#125;</span><br><span class="line">var invertTree = function(root) &#123;</span><br><span class="line">    ex(root)</span><br><span class="line">    return root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目解析&quot;&gt;&lt;a href=&quot;#题目解析&quot; class=&quot;headerlink&quot; title=&quot;题目解析&quot;&gt;&lt;/a&gt;题目解析&lt;/h3&gt;&lt;p&gt;翻转一棵二叉树。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;p&gt;示例 1:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   /   \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  2     7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; / \   / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1   3 6   9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   /   \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  7     2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; / \   / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9   6 3   1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;解题思路&quot;&gt;&lt;a href=&quot;#解题思路&quot; class=&quot;headerlink&quot; title=&quot;解题思路&quot;&gt;&lt;/a&gt;解题思路&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;递归，递归判断条件
1. 左右节点是否为null，不为null，则翻转其左右节点
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/categories/Algorithm/"/>
    
      <category term="每日一题" scheme="http://www.zsfmyz.top/categories/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Vue双向数据绑定原理及实现</title>
    <link href="http://www.zsfmyz.top/Vue/Vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.zsfmyz.top/Vue/Vue双向数据绑定原理及实现/</id>
    <published>2020-03-14T08:59:13.000Z</published>
    <updated>2020-03-14T06:59:38.019Z</updated>
    
    <content type="html"><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>vue实现双向绑定原理，主要是利用Object.defineProperty 来给实例data的属性添加 setter和getter.<br>并通过发布订阅模式（一对多的依赖关系，当状态发生改变，它的所有依赖都将被通知）来实现响应。</p><p>这个环节中包含了三个部分</p><ul><li><p>Observer 用来监听拦截data的属性为监察者。 </p></li><li><p>Dep用来添加订阅者，为订阅器</p></li><li><p>Watcher 就是订阅者</p></li></ul><p>监察者通过 Dep 向 Watcher发布更新消息</p> <a id="more"></a><h4 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h4><p>那么首先</p><ol><li>通过对set和get的拦截，在get阶段进行依赖收集，在set阶段对通知该属性上所啊绑定的依赖。</li></ol><p>如下我们就已经实现了一个简单的双向绑定了。</p><p>我们将data的value属性绑定上set和get，通过 _value 来进行操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- HTML部分 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;input type=&quot;text&quot; id=&quot;inp&quot; oninput=&quot;inputFn(this.value)&quot;&gt;</span><br><span class="line">&lt;div id=&apos;div&apos;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- JS部分 --&gt;</span><br><span class="line">var inp = document.getElementById(&apos;inp&apos;);</span><br><span class="line">var div = document.getElementById(&apos;div&apos;);</span><br><span class="line">var data = &#123;</span><br><span class="line">    value:&apos;&apos;</span><br><span class="line">&#125;</span><br><span class="line">  Object.defineProperty(data, &apos;value&apos;, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    set: function (newValue) &#123;</span><br><span class="line">        this._value = newValue; </span><br><span class="line">        div.innerText = data._value = value; //watcher</span><br><span class="line">    &#125;,</span><br><span class="line">    get: function () &#123;</span><br><span class="line">        return this._value; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">function inputFn(value) &#123;</span><br><span class="line">  data._value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果只是实现一个简单的双向绑定那么上面的代码就已经实现了。</p><h4 id="进一步完善模拟vue实现"><a href="#进一步完善模拟vue实现" class="headerlink" title="进一步完善模拟vue实现"></a>进一步完善模拟vue实现</h4><p>首先我们将watcher抽出来 备用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function watcher(params) &#123;</span><br><span class="line">  div.innerText = inp.value = params; // 派发watcher</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明一个vm来模拟vue的实例,并初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var vm = &#123;</span><br><span class="line"></span><br><span class="line">    //类似vue实例上的data</span><br><span class="line">    data: &#123;</span><br><span class="line">        value: &apos;&apos;</span><br><span class="line">    &#125;, </span><br><span class="line"></span><br><span class="line">    // vue私有, _data的所有属性为data中的所有属性被改造为 getter/setter 之后的。</span><br><span class="line">    _data: &#123;</span><br><span class="line">        value: &apos;&apos;</span><br><span class="line">    &#125;, </span><br><span class="line"></span><br><span class="line">    // 代理到vm对象上，可以实现vm.value</span><br><span class="line">    value: &apos;&apos;, </span><br><span class="line"></span><br><span class="line">    //value的订阅器用来收集订阅者 </span><br><span class="line">    valueWatchers:[] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历其data上的属性 进行改造 这里我们还是只举一个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 利用 Object.defineProperty 定义一个属性 (eg：value) 描述符为存取描述符的属性</span><br><span class="line">Object.defineProperty(vm._data, &apos;value&apos;, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    set: function (newValue) &#123; //set 派发watchers</span><br><span class="line">      vm.data.value = newValue; </span><br><span class="line">      vm.valueWatchers.map(fn =&gt; fn(newValue));</span><br><span class="line">    &#125;,</span><br><span class="line">    get: function () &#123; </span><br><span class="line">        </span><br><span class="line">        // 收集wachter vue中会在compile解析器中通过 显示调用 (this.xxx) 来触发get进行收集</span><br><span class="line">        vm.valueWatchers.length = 0; </span><br><span class="line">        vm.valueWatchers.push(watcher); </span><br><span class="line">        return vm.data.value; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">  &lt;!--直接通过显示调用来触发get进行绑定 vue中是在compile解析器中来进行这一步--&gt;</span><br><span class="line">  vm._data.value</span><br></pre></td></tr></table></figure><p>进行到这儿也已经实现了绑定，但是我们平时使用vue ，都是可以直接通过 this.xxx来获取和定义数据</p><p>那么我们还需要进行一步Proxy 代理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Object.defineProperty(vm, &apos;value&apos;, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    set: function (newValue) &#123;</span><br><span class="line">        this._data.value = newValue; //借助</span><br><span class="line">    &#125;,</span><br><span class="line">    get: function () &#123;</span><br><span class="line">        return this._data.value; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样我们就把vm._data.value 代理到vm.value上了，可以通过其直接操作了。</p><p>那么按照官方的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function proxy (target, sourceKey, key) &#123;</span><br><span class="line">    Object.defineProperty(target, key, &#123;</span><br><span class="line">        enumerable: true,</span><br><span class="line">        configurable: true,</span><br><span class="line">        get() &#123;</span><br><span class="line">            return this[sourceKey][key];</span><br><span class="line">        &#125;,</span><br><span class="line">        set(val) &#123;</span><br><span class="line">            this[sourceKey][key] = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">proxy(vm, &apos;_data&apos;, &apos;value&apos;);</span><br></pre></td></tr></table></figure><h4 id="完善后的完整代码"><a href="#完善后的完整代码" class="headerlink" title="完善后的完整代码"></a>完善后的完整代码</h4><p>以下为整个页面，可以直接运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;双向绑定简单实现&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; id=&quot;inp&quot; oninput=&quot;inputFn(this.value)&quot;&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; id=&quot;inp2&quot; oninput=&quot;inputFn(this.value)&quot;&gt;</span><br><span class="line">&lt;div id=&apos;div&apos;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var inp = document.getElementById(&apos;inp&apos;);</span><br><span class="line">    var inp2 = document.getElementById(&apos;inp2&apos;);</span><br><span class="line">    var div = document.getElementById(&apos;div&apos;);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    function inputFn(value) &#123;</span><br><span class="line">        div.innerText = vm.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function watcher(params) &#123;</span><br><span class="line">        console.log(1)</span><br><span class="line">        div.innerText = inp.value = params; // 派发watcher</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function watcher2(params) &#123;</span><br><span class="line">        console.log(2)</span><br><span class="line"></span><br><span class="line">        div.innerText = inp2.value = params; // 派发watcher</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function proxy (target, sourceKey, key) &#123;</span><br><span class="line">        Object.defineProperty(target, key, &#123;</span><br><span class="line">            enumerable: true,</span><br><span class="line">            configurable: true,</span><br><span class="line">            get() &#123;</span><br><span class="line">                return this[sourceKey][key];</span><br><span class="line">            &#125;,</span><br><span class="line">            set(val) &#123;</span><br><span class="line">                this[sourceKey][key] = val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var vm = &#123;</span><br><span class="line">        data: &#123;&#125;,</span><br><span class="line">        _data: &#123;&#125;,</span><br><span class="line">        value: &apos;&apos;, </span><br><span class="line">        valueWatchers: [] </span><br><span class="line">    &#125;</span><br><span class="line">    Object.defineProperty(vm._data, &apos;value&apos;, &#123;</span><br><span class="line">        enumerable: true,</span><br><span class="line">        configurable: true,</span><br><span class="line">        set: function (newValue) &#123;</span><br><span class="line">            vm.data.value = newValue; </span><br><span class="line">            vm.valueWatchers.map(fn =&gt; fn(newValue));</span><br><span class="line">        &#125;,</span><br><span class="line">        get: function () &#123;</span><br><span class="line">            vm.valueWatchers = []; //防止重复添加, </span><br><span class="line">            vm.valueWatchers.push(watcher); </span><br><span class="line">            vm.valueWatchers.push(watcher2); </span><br><span class="line">            return vm.data.value; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    proxy(vm, &apos;_data&apos;, &apos;value&apos;);</span><br><span class="line"></span><br><span class="line">    vm.value;  //显示调用绑定</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>再多讲一点。实际上vue在初始化的时候是用解析器解析过程中将wathcer进行绑定的。</p><p>它会利用一个全局的Dep.target = watcher </p><p>然后在get收集中，只收集全局上Dep.target, 添加完毕后会重新初始化全局Dep.target = null;</p><p>类似如下操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Dep.target = watcher;</span><br><span class="line">vm.value;    // 触发get =&gt; Dep.target &amp;&amp; valueWatchers.push(Dep.target);</span><br><span class="line">Dep.target = null;</span><br></pre></td></tr></table></figure><p>这样也会防止我们在调用时触发get重复去添加watcher。</p><p>而我们的例子中只是每次都初始化为[]. 实际订阅器也不只是一个watcher数组。 </p><p>此例跟官方实现还是有很多差距，只是简单模拟。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h4&gt;&lt;p&gt;vue实现双向绑定原理，主要是利用Object.defineProperty 来给实例data的属性添加 setter和getter.&lt;br&gt;并通过发布订阅模式（一对多的依赖关系，当状态发生改变，它的所有依赖都将被通知）来实现响应。&lt;/p&gt;
&lt;p&gt;这个环节中包含了三个部分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Observer 用来监听拦截data的属性为监察者。 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Dep用来添加订阅者，为订阅器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Watcher 就是订阅者&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;监察者通过 Dep 向 Watcher发布更新消息&lt;/p&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://www.zsfmyz.top/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://www.zsfmyz.top/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>定时器中的异步请求堆积如何解决？</title>
    <link href="http://www.zsfmyz.top/JavaScript/%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E5%A0%86%E7%A7%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F/"/>
    <id>http://www.zsfmyz.top/JavaScript/定时器中的异步请求堆积如何解决？/</id>
    <published>2020-03-14T04:50:34.000Z</published>
    <updated>2020-03-27T09:38:49.859Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>有时候我们需要用setinterval来执行一些异步操作来刷新页面的信息。但是如果一旦异步函数的请求时间过长，就会造成事件操作堆积。</p><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">this.interval = setInterval(async () =# &#123;</span><br><span class="line">      const resp = await ajax();</span><br><span class="line">      this.rows = resp.rows;</span><br><span class="line">    &#125;, 5000);</span><br></pre></td></tr></table></figure><p>假设ajax()请求的时间因为网络或者其他原因超过了5秒，定时器并不会等待其返回结果，而是依旧会进行下一次循环，这样的话，其实定时器和异步请求之间的时序并没有联系顺序也毫无规律，那么我们如何实现等本次ajax请求完毕之后等待一段时间之后再进行下一次循环呢？</p><a id="more"></a><h3 id="1-简单代码实现"><a href="#1-简单代码实现" class="headerlink" title="1.简单代码实现"></a>1.简单代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function setIntervalWaitable(callback,ms)&#123;</span><br><span class="line">    this._self = &#123;</span><br><span class="line">        fn: callback,</span><br><span class="line">        timeout: ms,</span><br><span class="line">        timeoutHandler: null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">setIntervalWaitable.prototype.request = function() &#123;</span><br><span class="line">    if (this._self.timeoutHandler) &#123;</span><br><span class="line">        clearTimeout(this._self.timeoutHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this._self.timeoutHandler = setTimeout(() =&gt; &#123;</span><br><span class="line">        this._self.fn();</span><br><span class="line">    &#125;, this._self.timeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 模拟执行 --&gt;</span><br><span class="line">&lt;!-- let ms = 2000;</span><br><span class="line">let asyncMs = 1000;</span><br><span class="line">var set = new setIntervalWaitable(()=&gt;&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        set.request()</span><br><span class="line">    &#125;, asyncMs)</span><br><span class="line">&#125;, ms)</span><br><span class="line">set.request() --&gt;</span><br></pre></td></tr></table></figure><p>达到如下效果的异步刷新时序图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rfn########----------------rfn##----------------rfn########################----------------rfn####</span><br><span class="line">-----------5000ms##########-----5000ms##########---------------------------5000ms##########</span><br></pre></td></tr></table></figure><h3 id="2-改造："><a href="#2-改造：" class="headerlink" title="2. 改造："></a>2. 改造：</h3><ul><li>等待传入的ms时间，如果此时callback已经完成，重新执行callback</li><li>否则，等待callback完成，再重新执行callback</li></ul><p>例如500ms周期时序图:<br>rpc########—-rpc############rpc########################rpc####——–rpc######——rpc####<br>500ms##########500ms##########500ms##########————500ms##########500ms##########</p><h4 id="实现思路："><a href="#实现思路：" class="headerlink" title="实现思路："></a>实现思路：</h4><p>在第一题的基础上，在异步函数调用settimeout之前判断异步函数用时和settimeout的时间大小，计算差值，以差值作为下次定时器执行的时间。 如果异步函数用时大于定时器设定时间，直接执行下次异步函数即可</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function setIntervalWaitable2(callback,ms)&#123;</span><br><span class="line">    this._self = &#123;</span><br><span class="line">        fn: callback,</span><br><span class="line">        timeout: ms,</span><br><span class="line">        timeoutHandler: null,</span><br><span class="line">        start: null,</span><br><span class="line">        duration: null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">setIntervalWaitable2.prototype.request = function() &#123;</span><br><span class="line">    let that = this;</span><br><span class="line">    let timeout = 0; //首次直接执行事件</span><br><span class="line"></span><br><span class="line">    if (that._self.timeoutHandler) &#123;</span><br><span class="line">        clearTimeout(that._self.timeoutHandler);</span><br><span class="line">    &#125;</span><br><span class="line">    // 判断</span><br><span class="line">    if (that._self.start) &#123; //计算更新timeout值</span><br><span class="line">        that._self.duration = new Date().getTime() - that._self.start;</span><br><span class="line">        if (that._self.duration &lt; that._self.timeout) &#123;</span><br><span class="line">            timeout = that._self.timeout - that._self.duration;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    that._self.timeoutHandler = setTimeout(() =&gt; &#123;</span><br><span class="line">        that._self.start = new Date().getTime();</span><br><span class="line">        that._self.fn();</span><br><span class="line">    &#125;, timeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 模拟执行</span><br><span class="line">let ms = 2000;</span><br><span class="line">let asyncMs = 1000; //假设异步操作时间</span><br><span class="line"></span><br><span class="line">var set = new setIntervalWaitable2(()=&gt;&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(&apos;函数执行&apos; + new Date().getSeconds())</span><br><span class="line">        set.request()</span><br><span class="line">    &#125;, asyncMs)</span><br><span class="line">&#125;, ms)</span><br><span class="line">set.request()  --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 实际执行 --&gt;</span><br><span class="line"></span><br><span class="line"> &lt;!-- 实际执行 --&gt;</span><br><span class="line">created() &#123;</span><br><span class="line">      this.interval = new setIntervalWaitable2(()=&gt;&#123;</span><br><span class="line">          const resp = await getNewStatistics();</span><br><span class="line">          this.rows = resp.rows;</span><br><span class="line">          this.interval.request()</span><br><span class="line">      &#125;, 500)</span><br><span class="line">      this.interval.request() //执行</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="3-实现暂停和重启"><a href="#3-实现暂停和重启" class="headerlink" title="3. 实现暂停和重启"></a>3. 实现暂停和重启</h3><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路:"></a>实现思路:</h4><p>增加flag判断即可。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">  function setIntervalWaitable3(callback,ms)&#123;</span><br><span class="line">      this._self = &#123;</span><br><span class="line">          fn: callback,</span><br><span class="line">          timeout: ms,</span><br><span class="line">          timeoutHandler: null,</span><br><span class="line">          timeoutEnabled: true,</span><br><span class="line">          start: null,</span><br><span class="line">          duration: null</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  setIntervalWaitable3.prototype.request = function() &#123;</span><br><span class="line">      let that = this;</span><br><span class="line">      let timeout = 0;</span><br><span class="line"></span><br><span class="line">      if (!that._self.timeoutEnabled) &#123;</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (that._self.timeoutHandler) &#123;</span><br><span class="line">          clearTimeout(that._self.timeoutHandler);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      that._self.duration = new Date().getTime() - that._self.start;</span><br><span class="line"></span><br><span class="line">      if (that._self.duration &lt; that._self.timeout) &#123;</span><br><span class="line">          timeout = that._self.timeout - that._self.duration;</span><br><span class="line">      &#125;</span><br><span class="line">      that._self.timeoutHandler = setTimeout(() =&gt; &#123;</span><br><span class="line">          that._self.start = new Date().getTime();</span><br><span class="line">          that._self.fn();</span><br><span class="line">      &#125;, timeout);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setIntervalWaitable3.prototype.stop = function() &#123;</span><br><span class="line">      this._self.timeoutEnabled = false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  setIntervalWaitable3.prototype.restart = function() &#123;</span><br><span class="line">      this._self.timeoutEnabled = true;</span><br><span class="line">this.request()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 模拟执行 --&gt;</span><br><span class="line">  &lt;!-- let ms = 2000;</span><br><span class="line">  let asyncMs = 1000; //假设异步操作时间</span><br><span class="line"></span><br><span class="line">  var set = new setIntervalWaitable3(()=&gt;&#123;</span><br><span class="line">      setTimeout(function()&#123;</span><br><span class="line">          console.log(&apos;函数执行&apos; + new Date().getSeconds())</span><br><span class="line">          set.request()</span><br><span class="line">      &#125;, asyncMs)</span><br><span class="line">  &#125;, ms)</span><br><span class="line">  set.request() //执行 --&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;!-- 实际执行 --&gt;</span><br><span class="line"></span><br><span class="line">  created() &#123;</span><br><span class="line">      this.interval = new setIntervalWaitable3(()=&gt;&#123;</span><br><span class="line">          const resp = await getNewStatistics();</span><br><span class="line">          this.rows = resp.rows;</span><br><span class="line">          this.interval.request()</span><br><span class="line">      &#125;, 500)</span><br><span class="line">      this.interval.request() //执行</span><br><span class="line">  &#125;</span><br><span class="line">  destroyed() &#123;</span><br><span class="line">      this.interval.stop();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如上实现过程，思路很简单，就是在异步请求结束后手动调起下次循环，这样才能保证时序性。（当然我现在也只能想到这种办法，无论怎么考虑，第二次循环始终需要异步请求结尾处调用。）</p><p>目前我已经将该功能进行了封装，对其功能进行了一部分添加和完善。包括两种循环模式。</p><blockquote><p>详情  <a href="&quot;https://github.com/lunhui1994/async-loop-timer&quot;">Github 项目</a></p></blockquote><blockquote><p>npm 使用</p></blockquote><blockquote><p>npm i async-loop-timer</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;有时候我们需要用setinterval来执行一些异步操作来刷新页面的信息。但是如果一旦异步函数的请求时间过长，就会造成事件操作堆积。&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;this.interval = setInterval(async () =# &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      const resp = await ajax();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      this.rows = resp.rows;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;, 5000);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;假设ajax()请求的时间因为网络或者其他原因超过了5秒，定时器并不会等待其返回结果，而是依旧会进行下一次循环，这样的话，其实定时器和异步请求之间的时序并没有联系顺序也毫无规律，那么我们如何实现等本次ajax请求完毕之后等待一段时间之后再进行下一次循环呢？&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.zsfmyz.top/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.zsfmyz.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Vue性能优化方案</title>
    <link href="http://www.zsfmyz.top/Vue/Vue%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"/>
    <id>http://www.zsfmyz.top/Vue/Vue性能优化方案/</id>
    <published>2020-03-10T09:05:27.000Z</published>
    <updated>2020-03-20T03:25:21.945Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote><p>总结一下使用Vue涉及到的性能优化方法，从我实践和查阅资源总结出来的集合。</p></blockquote><p>目录：</p><ol><li><strong>v-if 和 v-show</strong><ol><li><strong>v-if</strong></li><li><strong>v-show</strong></li></ol></li><li><strong>computed 和 watch</strong></li><li><strong>v-for加key，避免使用v-if</strong></li><li><strong>keepalive</strong></li><li><strong>Object.freeze长列表优化</strong></li></ol><a id="more"></a><h3 id="一、-v-if-和-v-show"><a href="#一、-v-if-和-v-show" class="headerlink" title="一、 v-if 和 v-show"></a>一、 v-if 和 v-show</h3><ul><li>一般使用过vue或者angular及其相同框架的人都会知道他们的区别。</li></ul><h5 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h5><p>它是真正的条件判断语句，会根据条件对条件内的组件进行重建和销毁。<br>它是惰性的，在第一次判断条件为true时，才会去创建相应的组件。即初始化为false时，该条件内组件不会加载。</p><h5 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h5><p>它仅仅是通过控制css的display属性来控制组件的显示和隐藏。<br>所以，无论是否为false，该组件都会在页面构建时加载。</p><h4 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h4><p>我们可以在需要<em>频繁切换</em>显示隐藏的组件上使用v-show，在只需要<em>一次或少数判断</em>的时候使用v-if。</p><h3 id="二、-computed-和-watch"><a href="#二、-computed-和-watch" class="headerlink" title="二、 computed 和 watch"></a>二、 computed 和 watch</h3><ul><li>computed 和 watch 都可以对个变量进行监听依赖，但是用法上还是有很大区别的。</li></ul><p>如 name = ‘xiaoming’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123; name.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>如上我们想把name反转，如此写在html中略显混乱，并对阅读不友好。</p><h5 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h5><p>它表示计算属性，目的是用来方便控制需要计算之后再进行展示的数据。<br>computed属性会被缓存，只有computed所依赖的属性发生变化之后，才会触发computed重新计算。</p><p>使用computed</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123; nameReverse &#125;&#125;&lt;/div&gt;</span><br><span class="line">// ...</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            name: &apos;xiaoming&apos;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        nameReverse: &#123;</span><br><span class="line">            get: function () &#123;</span><br><span class="line">                    return this.name.split(&apos;&apos;).reverse().join(&apos;&apos;);</span><br><span class="line">                &#125;,</span><br><span class="line">            set: function (newValue) &#123;</span><br><span class="line">                    //同时computed也有set函数，可以在计算变量赋值时触发。</span><br><span class="line">                    //this.name = ...</span><br><span class="line">                &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><h5 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h5><p>watch事实上就是一个监听函数，通过监听该变量来执行一些更加复杂的操作。它是比computed更耗费性能的。</p><p>注意watch在进入页面之后是不会立即触发的。</p><p>使用watch</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123; nameReverse &#125;&#125;&lt;/div&gt;</span><br><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        name: &apos;xiaoming&apos;,</span><br><span class="line">        nameReverse: &apos;&apos; //定义</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;,</span><br><span class="line">method: &#123;</span><br><span class="line">    nameHandler: function (newQuestion, oldQuestion) &#123;</span><br><span class="line">            this.nameReverse = newQuestion.split(&apos;&apos;).reverse().join(&apos;&apos;);</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;</span><br><span class="line">watch: &#123;</span><br><span class="line">    // &apos;obj.name&apos;: &apos;xxxhandler&apos; 也可以监听深层属性  </span><br><span class="line">    name:&#123; </span><br><span class="line">        handler: &quot;nameHandler&quot;,</span><br><span class="line">        immediate: true //该属性设置之后watch会以当前值立即触发回调函数。</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化：-1"><a href="#优化：-1" class="headerlink" title="优化："></a>优化：</h4><p>所以我们可以根据computed和watch的不同用法，来区分使用场景。<br>当我们仅仅需要获取一个通过一系列操作后的计算结果，我们应该使用computed。<br>当我们需要在属性变化时进行更加复杂的操作，比如异步操作，设置中间状态进行节流等，这些都需要使用watch实现。</p><h3 id="三、-v-for-和-key-避免使用v-if"><a href="#三、-v-for-和-key-避免使用v-if" class="headerlink" title="三、 v-for 和 key 避免使用v-if"></a>三、 v-for 和 key 避免使用v-if</h3><ul><li>我们都知道使用v-for的时候要在每个节点加上唯一的key值，否则即采用就地复用的原则，同时避免使用v-if使用computed来代替。</li></ul><h5 id="不加key"><a href="#不加key" class="headerlink" title="不加key"></a>不加key</h5><p>官方文档对key的解释很清楚，key的用途主要用于虚拟DOM对比时对vnode进行辨别。</p><p>那么不加key的就地复用是什么意思呢?<br>即当节点被删除或者位置被移动，节点不会被删除或者替换。<br>虚拟DOM将会遍历vnode，直接更改其内容。（该操作是高效的）<br>但是其只适用于渲染列表Dom结构极其简单的情况。</p><h5 id="加key"><a href="#加key" class="headerlink" title="加key"></a>加key</h5><p>加上key之后，对vnode增加了独特的标记，虚拟DOM的对比将不会再遍历vnodes，而是直接采用key的映射进行对比。<br>将会基于key冲i性能排序元素顺序，删除key不存在的节点，替换和删除节点。<br>它也能触发完整的生命周期函数。</p><h5 id="v-if-和-computed"><a href="#v-if-和-computed" class="headerlink" title="v-if 和 computed"></a>v-if 和 computed</h5><p>如果我们的列表只需要渲染其中的一部分，我们可以使用computed，即通过computed对最终显示数据进行过滤，而非在html中进行if判断过滤。</p><h4 id="优化：-2"><a href="#优化：-2" class="headerlink" title="优化："></a>优化：</h4><p>官方建议：建议尽可能在使用 v-for 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。<br>注意： key值需使用使用string和数值型基础类型，不要使用对象数组等复杂类型。同时key值需要独特性。可以使用列如id属性作为key。</p><h3 id="四、-keepalive"><a href="#四、-keepalive" class="headerlink" title="四、 keepalive"></a>四、 keepalive</h3><p>使用keep-alive包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们；<br>keep-alive是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中；</p><h4 id="使用keepalive"><a href="#使用keepalive" class="headerlink" title="使用keepalive"></a>使用keepalive</h4><p>当组件在 <keep-alive> 内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行。<br>可以保存组件的状态，比如一个下拉框，选择了第二项，切换其他组件再返回时依旧是第二个组件。<br>防止组件重复的销毁和重建。</keep-alive></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- include表示匹配要缓存的组件名称，exclude表示不缓存的组件名称，exclude优先级更高。 max表示最大缓存数 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;keep-alive :include=&quot;&quot; :exclude=&quot;&quot; :max=&quot;&quot;&gt;</span><br><span class="line">  &lt;comp-a v-if=&quot;a &gt; 1&quot;&gt;&lt;/comp-a&gt;</span><br><span class="line">  &lt;comp-b v-else&gt;&lt;/comp-b&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><h4 id="keepalive-多了解一点"><a href="#keepalive-多了解一点" class="headerlink" title="keepalive 多了解一点"></a>keepalive 多了解一点</h4><p>keepalive是vue的一个组件，它自己的生命周期有created和destoryed,。</p><p><strong>created</strong>用来创建一个cache用来保存需要缓存的Vnode节点，和一个keys数组用来保存cache中对应的key值。<br><strong>destoryed</strong>用来遍历缓存节点并逐个调用$destory()进行销毁。</p><p><strong>rander</strong>首先会获取第一个子组件，获取到名称，然后进行include和exclude过滤，判断是否匹配缓存。<br>如果不符合缓存条件，直接返回vnode，如果符合，则以名称为key值去keys中查找。<br>若命中，则返回cache中的缓存，并将cache中key位置的缓存删除，并添加到cache的末尾。<br>若没命中，则进行缓存并返回vnode，并将其添加至cache尾部。</p><p>返回前会将它们的keepAlive属性设置为true用于后面调用activated与deactivated函数。 </p><p><strong>watch</strong>同时keepalive会监听include和exclude的变化，不存在的key将进行销毁并以出cache列表。</p><p>keepalive 组件本身并不会生成节点，在keep-alive中，设置了 abstract: true ，该属性表示此组件为抽象组件意思就是不会生成实际节点。</p><p><a href="&quot;https://www.cnblogs.com/wangjiachen666/p/11497200.html&quot;">相关荐文</a></p><h4 id="优化：-3"><a href="#优化：-3" class="headerlink" title="优化："></a>优化：</h4><p>如果你的组件需要保持切换前的状态就需要加上keepalive，或者对于频繁切换的组件也需要加上，以保证它避免被销毁，保存渲染状态，提高性能。</p><h3 id="五、-Object-freeze-冻结对象，长列表优化"><a href="#五、-Object-freeze-冻结对象，长列表优化" class="headerlink" title="五、 Object.freeze 冻结对象，长列表优化"></a>五、 Object.freeze 冻结对象，长列表优化</h3><p>有时候我们会有一些比较长的列表要进行展示，而且这些数据展示完之后并不会发生变化。<br>但是vue对数据都是使用了Object.defineProperty进行了数据劫持，所以初始化时就会造成大量的无用劫持。<br>这时候我们就可以使用Object.freeze进行冻结，冻结之后数据就不会再被修改了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.list = Object.freeze(list);</span><br></pre></td></tr></table></figure><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>对一些不需要双向绑定的列表进行Object.freeze()进行冻结，提高性能。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;总结一下使用Vue涉及到的性能优化方法，从我实践和查阅资源总结出来的集合。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目录：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;v-if 和 v-show&lt;/strong&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;v-if&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;v-show&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;computed 和 watch&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;v-for加key，避免使用v-if&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;keepalive&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Object.freeze长列表优化&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://www.zsfmyz.top/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://www.zsfmyz.top/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode_112. 路径总和</title>
    <link href="http://www.zsfmyz.top/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/leetcode_112.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/"/>
    <id>http://www.zsfmyz.top/Algorithm/每日一题/leetcode_112. 路径总和/</id>
    <published>2019-12-12T03:59:13.000Z</published>
    <updated>2019-12-13T01:43:29.223Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目解析："><a href="#题目解析：" class="headerlink" title="题目解析："></a>题目解析：</h3><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给定如下二叉树，以及目标和 sum = 22</span><br><span class="line">              5</span><br><span class="line">             / \</span><br><span class="line">            4   8</span><br><span class="line">           /   / \</span><br><span class="line">          11  13  4</span><br><span class="line">         /  \      \</span><br><span class="line">        7    2      1</span><br><span class="line"></span><br><span class="line">返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</span><br></pre></td></tr></table></figure></p><p>说明&amp;&amp;进阶:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">说明: 叶子节点是指没有子节点的节点。</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>递归，递归判断条件1. 左右对称的节点是否相同。2. 递归判断直至叶节点。</code></pre><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @param &#123;number&#125; sum</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">var hasPathSum = function(root, sum) &#123;</span><br><span class="line">    if (root === null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return fun(root, 0, sum);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var fun = function(root, mysum, sum) &#123;</span><br><span class="line">    root.mysum = root.val + mysum;</span><br><span class="line">    if (root.left === null &amp;&amp; root.right === null)&#123;</span><br><span class="line">       return root.mysum === sum;</span><br><span class="line">    &#125;</span><br><span class="line">    return (root.left &amp;&amp; fun(root.left, root.mysum, sum)) || (root.right &amp;&amp; fun(root.right, root.mysum, sum)) || false; </span><br><span class="line">    // 或（||）会取最后一个转义为false的值。 即可能会出现0，null，undefined等结果</span><br><span class="line">    // 为避免不必要的错误，增加 || false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目解析：&quot;&gt;&lt;a href=&quot;#题目解析：&quot; class=&quot;headerlink&quot; title=&quot;题目解析：&quot;&gt;&lt;/a&gt;题目解析：&lt;/h3&gt;&lt;p&gt;给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;p&gt;示例 1:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给定如下二叉树，以及目标和 sum = 22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            4   8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           /   / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          11  13  4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         /  \      \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        7    2      1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&amp;gt;4-&amp;gt;11-&amp;gt;2。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;说明&amp;amp;&amp;amp;进阶:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;说明: 叶子节点是指没有子节点的节点。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/categories/Algorithm/"/>
    
      <category term="每日一题" scheme="http://www.zsfmyz.top/categories/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode_101. 对称二叉树</title>
    <link href="http://www.zsfmyz.top/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/leetcode_101.%20%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://www.zsfmyz.top/Algorithm/每日一题/leetcode_101. 对称二叉树/</id>
    <published>2019-12-12T03:59:13.000Z</published>
    <updated>2019-12-12T09:19:03.303Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目解析："><a href="#题目解析：" class="headerlink" title="题目解析："></a>题目解析：</h3><p>给定一个二叉树，检查它是否是镜像对称的。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,2,3,4,4,3]  对称</span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br><span class="line"></span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,2,null,3,null,3] 非对称</span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line">   \   \</span><br><span class="line">   3    3</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p><p>说明&amp;&amp;进阶:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果你可以运用递归和迭代两种方法解决这个问题，会很加分。</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>递归，递归判断条件1. 左右对称的节点是否相同。2. 递归判断直至叶节点。</code></pre><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">var isSymmetric = function(root) &#123;</span><br><span class="line">    if (root === null) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return fun(root.left, root.right);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var fun = function(left, right) &#123;</span><br><span class="line">    if (left === null &amp;&amp; right === null) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (left === null || right === null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return (left.val === right.val) &amp;&amp; fun(left.left, right.right) &amp;&amp; fun(left.right, right.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目解析：&quot;&gt;&lt;a href=&quot;#题目解析：&quot; class=&quot;headerlink&quot; title=&quot;题目解析：&quot;&gt;&lt;/a&gt;题目解析：&lt;/h3&gt;&lt;p&gt;给定一个二叉树，检查它是否是镜像对称的。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;p&gt;示例 1:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,2,2,3,4,4,3]  对称&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  2   2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; / \ / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3  4 4  3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;示例 2:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,2,2,null,3,null,3] 非对称&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  2   2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   \   \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   3    3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;说明&amp;amp;&amp;amp;进阶:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;如果你可以运用递归和迭代两种方法解决这个问题，会很加分。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/categories/Algorithm/"/>
    
      <category term="每日一题" scheme="http://www.zsfmyz.top/categories/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>QQ音乐api(持续更新)</title>
    <link href="http://www.zsfmyz.top/api/QQ%E9%9F%B3%E4%B9%90api(%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0)/"/>
    <id>http://www.zsfmyz.top/api/QQ音乐api(持续更新)/</id>
    <published>2019-12-05T07:10:03.000Z</published>
    <updated>2020-02-26T07:10:24.798Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><h4 id="2019-12-26-更新"><a href="#2019-12-26-更新" class="headerlink" title="2019/12/26 更新"></a>2019/12/26 更新</h4><ol><li>获取歌曲播放地址接口 增加 lyric参数代表是否获取歌词。</li><li>增加获取歌词接口</li></ol><h4 id="2019-12-24-更新"><a href="#2019-12-24-更新" class="headerlink" title="2019/12/24 更新"></a>2019/12/24 更新</h4><ol><li>所有音乐接口更改，增加一层music/ ，获取地址改为 music/song</li><li>增加福利图片接口</li><li>示例接口更改为https</li></ol><blockquote><p>接口仅供交流学习使用</p></blockquote><p><a href="https://github.com/lunhui1994/node-music-api" target="_blank" rel="noopener">github 项目地址</a> 欢迎star</p><p>因为之前使用网络上别人封装的音乐api现在无法使用，或者一些需要付费使用，当然这也无可厚非。</p><p>但对我而言，只需要简单的一些音乐api做一些东西。 感觉给钱有点亏。 就自己搞一个简单的符合我的需求的吧。</p><h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><a id="more"></a><h2 id="所支持的Api"><a href="#所支持的Api" class="headerlink" title="所支持的Api"></a>所支持的Api</h2><ol><li>音乐搜索</li><li>音乐top100列表</li><li>音乐播放地址</li><li>福利图片 (新增 2019/12/24).</li><li>音乐歌词 (新增 2019/12/26).</li></ol><p>很简单的三个基本的功能。</p><p>所有方法都是GET</p><p>本项目所支持的Api</p><h2 id="音乐-music"><a href="#音乐-music" class="headerlink" title="音乐 music"></a>音乐 music</h2><h3 id="音乐列表"><a href="#音乐列表" class="headerlink" title="音乐列表"></a>音乐列表</h3><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><table><thead><tr><th>参数</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>p</td><td>string</td><td>页码</td></tr><tr><td>n</td><td>string</td><td>数目</td></tr><tr><td>w</td><td>string</td><td>关键词</td></tr></tbody></table><p>返回参数</p><table><thead><tr><th>参数</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>curpage</td><td>int</td><td>页码</td></tr><tr><td>curnum</td><td>int</td><td>数目</td></tr><tr><td>list</td><td>—</td><td>音乐列表</td></tr></tbody></table><p>eg：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://api.zsfmyz.top/music/list?p=1&amp;n=30&amp;w=简单爱</span><br></pre></td></tr></table></figure><p>返回参数举例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    &#123;</span><br><span class="line">    &quot;curnum&quot;: 41,</span><br><span class="line">    &quot;curpage&quot;: 1,</span><br><span class="line">    &quot;list&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;songname&quot;: &quot;简单爱&quot;,</span><br><span class="line">            &quot;singer&quot;: &#123;</span><br><span class="line">                &quot;id&quot;: 4558,</span><br><span class="line">                &quot;mid&quot;: &quot;0025NhlN2yWrP4&quot;,</span><br><span class="line">                &quot;name&quot;: &quot;周杰伦&quot;,</span><br><span class="line">                &quot;name_hilight&quot;: &quot;周杰伦&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;albumname&quot;: &quot;范特西&quot;,</span><br><span class="line">            &quot;songmid&quot;: &quot;0009BCJK1nRaad&quot;,</span><br><span class="line">            &quot;albumimg&quot;: &quot;http://imgcache.qq.com/music/photo/album_300/17300_albumpic_8217_0.jpg&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;songname&quot;: &quot;简单爱 (Live)&quot;,</span><br><span class="line">            &quot;singer&quot;: &#123;</span><br><span class="line">                &quot;id&quot;: 4558,</span><br><span class="line">                &quot;mid&quot;: &quot;0025NhlN2yWrP4&quot;,</span><br><span class="line">                &quot;name&quot;: &quot;周杰伦&quot;,</span><br><span class="line">                &quot;name_hilight&quot;: &quot;周杰伦&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;albumname&quot;: &quot;周杰伦 2004 无与伦比 演唱会 Live CD&quot;,</span><br><span class="line">            &quot;songmid&quot;: &quot;0022nw6P1dcHgp&quot;,</span><br><span class="line">            &quot;albumimg&quot;: &quot;http://imgcache.qq.com/music/photo/album_300/23300_albumpic_14323_0.jpg&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;songname&quot;: &quot;简单爱 (Live)&quot;,</span><br><span class="line">            &quot;singer&quot;: &#123;</span><br><span class="line">                &quot;id&quot;: 143,</span><br><span class="line">                &quot;mid&quot;: &quot;003Nz2So3XXYek&quot;,</span><br><span class="line">                &quot;name&quot;: &quot;陈奕迅&quot;,</span><br><span class="line">                &quot;name_hilight&quot;: &quot;陈奕迅&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;albumname&quot;: &quot;2015江苏卫视新年演唱会&quot;,</span><br><span class="line">            &quot;songmid&quot;: &quot;001IcyF42TKTf1&quot;,</span><br><span class="line">            &quot;albumimg&quot;: &quot;http://imgcache.qq.com/music/photo/album_300/53300_albumpic_929853_0.jpg&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="音乐top100列表"><a href="#音乐top100列表" class="headerlink" title="音乐top100列表"></a>音乐top100列表</h3><h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>参数</p><p>无</p><p>返回参数</p><table><thead><tr><th>参数</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>date</td><td>string</td><td>日期</td></tr><tr><td>curpage</td><td>int</td><td>页码</td></tr><tr><td>curnum</td><td>int</td><td>数目</td></tr><tr><td>list</td><td>—</td><td>音乐列表</td></tr><tr><td>topinfo</td><td>—</td><td>音乐top100信息</td></tr></tbody></table><p>list中歌曲信息比普通列表多了排名: cur_count</p><p>eg：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://api.zsfmyz.top/music/top</span><br></pre></td></tr></table></figure><p>返回参数举例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">    &#123;</span><br><span class="line">    &quot;code&quot;: &quot;0&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;code&quot;: 0,</span><br><span class="line">        &quot;date&quot;: &quot;2019-12-05&quot;,</span><br><span class="line">        &quot;curnum&quot;: 100,</span><br><span class="line">        &quot;curpage&quot;: 1,</span><br><span class="line">        &quot;list&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;cur_count&quot;: &quot;1&quot;,</span><br><span class="line">                &quot;songname&quot;: &quot;像极了&quot;,</span><br><span class="line">                &quot;singer&quot;: &#123;</span><br><span class="line">                    &quot;id&quot;: 1441799,</span><br><span class="line">                    &quot;mid&quot;: &quot;0023dQD40to8NP&quot;,</span><br><span class="line">                    &quot;name&quot;: &quot;永彬Ryan.B&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;albumname&quot;: &quot;像极了&quot;,</span><br><span class="line">                &quot;songmid&quot;: &quot;000V8En93R3Dvd&quot;,</span><br><span class="line">                &quot;albumimg&quot;: &quot;http://imgcache.qq.com/music/photo/album_300/36300_albumpic_9218636_0.jpg&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;cur_count&quot;: &quot;2&quot;,</span><br><span class="line">                &quot;songname&quot;: &quot;拱手相让&quot;,</span><br><span class="line">                &quot;singer&quot;: &#123;</span><br><span class="line">                    &quot;id&quot;: 22529,</span><br><span class="line">                    &quot;mid&quot;: &quot;001z6uGh1j5qBh&quot;,</span><br><span class="line">                    &quot;name&quot;: &quot;胜屿&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;albumname&quot;: &quot;拱手相让&quot;,</span><br><span class="line">                &quot;songmid&quot;: &quot;002DIlMZ48qB1F&quot;,</span><br><span class="line">                &quot;albumimg&quot;: &quot;http://imgcache.qq.com/music/photo/album_300/66300_albumpic_9414066_0.jpg&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;cur_count&quot;: &quot;3&quot;,</span><br><span class="line">                &quot;songname&quot;: &quot;余年&quot;,</span><br><span class="line">                &quot;singer&quot;: &#123;</span><br><span class="line">                    &quot;id&quot;: 1060985,</span><br><span class="line">                    &quot;mid&quot;: &quot;0022eAG537I1bg&quot;,</span><br><span class="line">                    &quot;name&quot;: &quot;肖战&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;albumname&quot;: &quot;余年&quot;,</span><br><span class="line">                &quot;songmid&quot;: &quot;000bFWrY2VrdVp&quot;,</span><br><span class="line">                &quot;albumimg&quot;: &quot;http://imgcache.qq.com/music/photo/album_300/92300_albumpic_9423892_0.jpg&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;cur_count&quot;: &quot;4&quot;,</span><br><span class="line">                &quot;songname&quot;: &quot;触不可及&quot;,</span><br><span class="line">                &quot;singer&quot;: &#123;</span><br><span class="line">                    &quot;id&quot;: 199509,</span><br><span class="line">                    &quot;mid&quot;: &quot;003fA5G40k6hKc&quot;,</span><br><span class="line">                    &quot;name&quot;: &quot;周深&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;albumname&quot;: &quot;触不可及&quot;,</span><br><span class="line">                &quot;songmid&quot;: &quot;002EFRnf3ekI9S&quot;,</span><br><span class="line">                &quot;albumimg&quot;: &quot;http://imgcache.qq.com/music/photo/album_300/4300_albumpic_9320604_0.jpg&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;cur_count&quot;: &quot;5&quot;,</span><br><span class="line">                &quot;songname&quot;: &quot;冷静和热情之间&quot;,</span><br><span class="line">                &quot;singer&quot;: &#123;</span><br><span class="line">                    &quot;id&quot;: 198135,</span><br><span class="line">                    &quot;mid&quot;: &quot;001IoTZp19YMDG&quot;,</span><br><span class="line">                    &quot;name&quot;: &quot;易烊千玺&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;albumname&quot;: &quot;冷静和热情之间&quot;,</span><br><span class="line">                &quot;songmid&quot;: &quot;0014YYnw3vadJJ&quot;,</span><br><span class="line">                &quot;albumimg&quot;: &quot;http://imgcache.qq.com/music/photo/album_300/59300_albumpic_9415259_0.jpg&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;cur_count&quot;: &quot;6&quot;,</span><br><span class="line">                &quot;songname&quot;: &quot;美丽谎言&quot;,</span><br><span class="line">                &quot;singer&quot;: &#123;</span><br><span class="line">                    &quot;id&quot;: 71976,</span><br><span class="line">                    &quot;mid&quot;: &quot;001gthIA2JeIV1&quot;,</span><br><span class="line">                    &quot;name&quot;: &quot;都智文&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;albumname&quot;: &quot;美丽谎言&quot;,</span><br><span class="line">                &quot;songmid&quot;: &quot;003sJCeZ1iK9mZ&quot;,</span><br><span class="line">                &quot;albumimg&quot;: &quot;http://imgcache.qq.com/music/photo/album_300/88300_albumpic_9353488_0.jpg&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;cur_count&quot;: &quot;7&quot;,</span><br><span class="line">                &quot;songname&quot;: &quot;那男孩还好吗&quot;,</span><br><span class="line">                &quot;singer&quot;: &#123;</span><br><span class="line">                    &quot;id&quot;: 3298773,</span><br><span class="line">                    &quot;mid&quot;: &quot;003yGiqM2qF7Gm&quot;,</span><br><span class="line">                    &quot;name&quot;: &quot;Uu&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;albumname&quot;: &quot;那男孩还好吗&quot;,</span><br><span class="line">                &quot;songmid&quot;: &quot;002COmzJ0SPZMl&quot;,</span><br><span class="line">                &quot;albumimg&quot;: &quot;http://imgcache.qq.com/music/photo/album_300/36300_albumpic_9132036_0.jpg&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;cur_count&quot;: &quot;8&quot;,</span><br><span class="line">                &quot;songname&quot;: &quot;星辰大海&quot;,</span><br><span class="line">                &quot;singer&quot;: &#123;</span><br><span class="line">                    &quot;id&quot;: 25724,</span><br><span class="line">                    &quot;mid&quot;: &quot;0044vhyY2lfSB8&quot;,</span><br><span class="line">                    &quot;name&quot;: &quot;周冬雨&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;albumname&quot;: &quot;星辰大海&quot;,</span><br><span class="line">                &quot;songmid&quot;: &quot;003enTsq4M1J59&quot;,</span><br><span class="line">                &quot;albumimg&quot;: &quot;http://imgcache.qq.com/music/photo/album_300/63300_albumpic_9305663_0.jpg&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;cur_count&quot;: &quot;9&quot;,</span><br><span class="line">                &quot;songname&quot;: &quot;Lover (Remix)&quot;,</span><br><span class="line">                &quot;singer&quot;: &#123;</span><br><span class="line">                    &quot;id&quot;: 11921,</span><br><span class="line">                    &quot;mid&quot;: &quot;000qrPik2w6lDr&quot;,</span><br><span class="line">                    &quot;name&quot;: &quot;Taylor Swift&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;albumname&quot;: &quot;Lover (Remix)&quot;,</span><br><span class="line">                &quot;songmid&quot;: &quot;000H6p9p0V4MXi&quot;,</span><br><span class="line">                &quot;albumimg&quot;: &quot;http://imgcache.qq.com/music/photo/album_300/58300_albumpic_9207358_0.jpg&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">        &quot;topinfo&quot;: &#123;</span><br><span class="line">            &quot;ListName&quot;: &quot;巅峰榜·新歌&quot;,</span><br><span class="line">            &quot;MacDetailPicUrl&quot;: &quot;http://y.gtimg.cn/music/common/upload/iphone_order_channel/20150820172435.jpg&quot;,</span><br><span class="line">            &quot;MacListPicUrl&quot;: &quot;http://y.gtimg.cn/music/common/upload/iphone_order_channel/20150820172427.jpg&quot;,</span><br><span class="line">            &quot;UpdateType&quot;: &quot;1&quot;,</span><br><span class="line">            &quot;albuminfo&quot;: &quot;&quot;,</span><br><span class="line">            &quot;headPic_v12&quot;: &quot;http://y.gtimg.cn/music/common/upload/iphone_order_channel/20150820174934.jpg&quot;,</span><br><span class="line">            &quot;info&quot;: &quot;集结30天内发行的优质歌曲，鼓励原创、着眼未来的乐坛风向标。根据每日综合数据进行排序，体现QQ音乐用户追新潮流，致力于打造最权威最有公信力的专业健康的新歌排行榜。&lt;br&gt;&lt;br&gt;歌曲数量：100首&lt;br&gt;综合数据：登录用户在QQ音乐收听/分享/下载数据&quot;,</span><br><span class="line">            &quot;listennum&quot;: 1497166,</span><br><span class="line">            &quot;pic&quot;: &quot;http://y.gtimg.cn/music/common/upload/iphone_order_channel/20150820172421.jpg&quot;,</span><br><span class="line">            &quot;picDetail&quot;: &quot;http://y.gtimg.cn/music/common/upload/iphone_order_channel/20150820172414.jpg&quot;,</span><br><span class="line">            &quot;pic_album&quot;: &quot;http://imgcache.qq.com/music/photo_new/T002R300x300M000000tSk703NJAVD.jpg&quot;,</span><br><span class="line">            &quot;pic_h5&quot;: &quot;http://y.gtimg.cn/music/common/upload/iphone_order_channel/20150820172242.jpg&quot;,</span><br><span class="line">            &quot;pic_v11&quot;: &quot;http://y.gtimg.cn/music/common/upload/iphone_order_channel/20150820172421.jpg&quot;,</span><br><span class="line">            &quot;pic_v12&quot;: &quot;http://y.gtimg.cn/music/photo_new/T003R300x300M000003zALCN1hkB6y.jpg&quot;,</span><br><span class="line">            &quot;topID&quot;: &quot;27&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;0&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="音乐播放地址"><a href="#音乐播放地址" class="headerlink" title="音乐播放地址"></a>音乐播放地址</h3><h4 id="song"><a href="#song" class="headerlink" title="song"></a>song</h4><table><thead><tr><th>参数</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>songmid</td><td>string</td><td>用于获取token</td></tr><tr><td>guid</td><td>string</td><td>用于获取token</td></tr><tr><td>lyric</td><td>string</td><td>默认为0不获取歌词，1获取歌词</td></tr></tbody></table><p>其他参数固定</p><p>返回参数</p><table><thead><tr><th>参数</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>musicUrl</td><td>string</td><td>音乐播放地址</td></tr></tbody></table><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://api.zsfmyz.top/music/song?songmid=003lghpv0jfFXG&amp;guid=126548448</span><br></pre></td></tr></table></figure><p>返回参数举例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    &#123;</span><br><span class="line">    &quot;code&quot;: &quot;0&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;musicUrl&quot;: &quot;http://ws.stream.qqmusic.qq.com/C400003lghpv0jfFXG.m4a?fromtag=0&amp;guid=126548448&amp;vkey=7888A32FC10168AAD914CA484401762D7F060E7337C0B9187D8B907681BB177669ADB3DFBF398E0FC4D6ED1E0EC7574716872D7B5FE14322&quot;,</span><br><span class="line">        &quot;lyric&quot;: &quot;无&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="音乐歌词"><a href="#音乐歌词" class="headerlink" title="音乐歌词"></a>音乐歌词</h3><h4 id="lyric"><a href="#lyric" class="headerlink" title="lyric"></a>lyric</h4><table><thead><tr><th>参数</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>songmid</td><td>string</td><td>用于获取歌词</td></tr></tbody></table><p>其他参数固定</p><p>返回参数</p><table><thead><tr><th>参数</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>lyric</td><td>string</td><td>歌词内容</td></tr></tbody></table><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://api.zsfmyz.top/music/lyric?songmid=000wocYU11tSzS</span><br></pre></td></tr></table></figure><p>返回参数举例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    &#123;</span><br><span class="line">    &quot;code&quot;: &quot;0&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;lyric&quot;: &quot;[ti:差不多姑娘]\n[ar:G.E.M. 邓紫棋]\n[al:差不多姑娘]\n[by:]\n[offset:0]\n[00:00.00]差不多姑娘 - G.E.M. 邓紫棋\n[00:00.17]\n[00:02.67]差不多的姑娘\n[00:06.27]追逐差不多的漂亮\n[00:11.88]她们差不多的愿望\n[00:17.18]牵着她们鼻子方向\n[00:23.05]我回到差不多的家\n[00:24.38]躺在差不多的沙发\n[00:25.68]微博差不多的刷\n[00:26.99]都吃着差不多的瓜\n[00:28.48]那标题差不多的炸\n[00:29.78]...&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="福利图片-welfare"><a href="#福利图片-welfare" class="headerlink" title="福利图片 welfare"></a>福利图片 welfare</h2><blockquote><p>根据每日福利社的接口进行了封装，因为他们的https失效了，所以自己反向代理了。</p></blockquote><h3 id="图片列表"><a href="#图片列表" class="headerlink" title="图片列表"></a>图片列表</h3><h4 id="list-1"><a href="#list-1" class="headerlink" title="list"></a>list</h4><table><thead><tr><th>参数</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>per_page</td><td>string</td><td>每页数据量</td></tr><tr><td>page</td><td>string</td><td>第几页</td></tr></tbody></table><p>其他参数固定</p><p>返回参数</p><p>如下：</p><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://api.zsfmyz.top/welfare/list?per_page=20&amp;page=2</span><br></pre></td></tr></table></figure><p>返回参数举例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 0,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;error&quot;: false,</span><br><span class="line">        &quot;results&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;_id&quot;: &quot;5b63cd4e9d21225e0d3f58c9&quot;,</span><br><span class="line">                &quot;createdAt&quot;: &quot;2018-08-03T11:34:38.672Z&quot;,</span><br><span class="line">                &quot;desc&quot;: &quot;2018-08-03&quot;, //描述 </span><br><span class="line">                &quot;publishedAt&quot;: &quot;2018-08-03T00:00:00.0Z&quot;,</span><br><span class="line">                &quot;source&quot;: &quot;api&quot;,</span><br><span class="line">                &quot;type&quot;: &quot;福利&quot;, // 类型</span><br><span class="line">                &quot;url&quot;: &quot;https://ww1.sinaimg.cn/large/0065oQSqgy1ftwcw4f4a5j30sg10j1g9.jpg&quot;, //图片地址</span><br><span class="line">                &quot;used&quot;: true,</span><br><span class="line">                &quot;who&quot;: &quot;lijinshan&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;_id&quot;: &quot;5b6151509d21225206860f08&quot;,</span><br><span class="line">                &quot;createdAt&quot;: &quot;2018-08-01T14:21:04.556Z&quot;,</span><br><span class="line">                &quot;desc&quot;: &quot;2018-08-01&quot;,</span><br><span class="line">                &quot;publishedAt&quot;: &quot;2018-08-01T00:00:00.0Z&quot;,</span><br><span class="line">                &quot;source&quot;: &quot;api&quot;,</span><br><span class="line">                &quot;type&quot;: &quot;福利&quot;,</span><br><span class="line">                &quot;url&quot;: &quot;https://ww1.sinaimg.cn/large/0065oQSqly1ftu6gl83ewj30k80tites.jpg&quot;,</span><br><span class="line">                &quot;used&quot;: true,</span><br><span class="line">                &quot;who&quot;: &quot;lijinshan&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            // ...</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>over 暂时只有这 ~~ 三 ~~ 四个，不过做一个音乐demo足够了，有兴趣的话可以试试。</p><p>~~ <a href="http://api.zsfmyz.top/" target="_blank" rel="noopener">http://api.zsfmyz.top/</a> ~~ <a href="https://api.zsfmyz.top/" target="_blank" rel="noopener">https://api.zsfmyz.top/</a> 是目前开放的api接口地址，可直接食用。</p><h1 id="原接口说明"><a href="#原接口说明" class="headerlink" title="原接口说明"></a>原接口说明</h1><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><ul><li><a href="https://c.y.qq.com/soso/fcgi-bin/client_search_cp?aggr=1&amp;cr=1&amp;flag_qc=0&amp;p=1&amp;n=30&amp;w=简单爱" target="_blank" rel="noopener">https://c.y.qq.com/soso/fcgi-bin/client_search_cp?aggr=1&amp;cr=1&amp;flag_qc=0&amp;p=1&amp;n=30&amp;w=简单爱</a></li></ul><h3 id="封面"><a href="#封面" class="headerlink" title="封面"></a>封面</h3><ul><li><a href="http://imgcache.qq.com/music/photo/album_300/[albumid%100]/300_albumpic_[albumid]_0.jpg" target="_blank" rel="noopener">http://imgcache.qq.com/music/photo/album_300/[albumid%100]/300_albumpic_[albumid]_0.jpg</a>, albumid%100, albumid</li><li>比如albumid=8217，封面地址就是</li><li><a href="http://imgcache.qq.com/music/photo/album_300/17/300_albumpic_8217_0.jpg。" target="_blank" rel="noopener">http://imgcache.qq.com/music/photo/album_300/17/300_albumpic_8217_0.jpg。</a></li></ul><h3 id="歌曲token"><a href="#歌曲token" class="headerlink" title="歌曲token"></a>歌曲token</h3><ul><li><a href="https://c.y.qq.com/base/fcgi-bin/fcg_music_express_mobile3.fcg?format=json205361747&amp;platform=yqq&amp;cid=205361747&amp;songmid=003lghpv0jfFXG&amp;filename=C400003lghpv0jfFXG.m4a&amp;guid=126548448" target="_blank" rel="noopener">https://c.y.qq.com/base/fcgi-bin/fcg_music_express_mobile3.fcg?format=json205361747&amp;platform=yqq&amp;cid=205361747&amp;songmid=003lghpv0jfFXG&amp;filename=C400003lghpv0jfFXG.m4a&amp;guid=126548448</a></li></ul><ol><li>songmid可以从歌曲信息中取到，filename根据songmid生成。</li><li>比如，songmid是003lghpv0jfFXG，则filename就是前缀加上C400，后缀加上.m4a，即C400003lghpv0jfFXG.m4a。</li><li>其他字段format、platform、cid、guid可以写死，但都是必须的。</li></ol><h3 id="拼接播放地址"><a href="#拼接播放地址" class="headerlink" title="拼接播放地址"></a>拼接播放地址</h3><ul><li><a href="http://ws.stream.qqmusic.qq.com/C400003lghpv0jfFXG.m4a?fromtag=0&amp;guid=126548448&amp;vkey=D661E5DF19B8FEB2FBFC554276746AC608AE98B0F30595B3B3BAD5C1C89ECCDD7BE599E306F786621856D22D6BD6B96F5DD344CF3814DB71" target="_blank" rel="noopener">http://ws.stream.qqmusic.qq.com/C400003lghpv0jfFXG.m4a?fromtag=0&amp;guid=126548448&amp;vkey=D661E5DF19B8FEB2FBFC554276746AC608AE98B0F30595B3B3BAD5C1C89ECCDD7BE599E306F786621856D22D6BD6B96F5DD344CF3814DB71</a></li></ul><p><a href="https://www.jianshu.com/p/67e4bd47d981" target="_blank" rel="noopener">原文依据</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h1&gt;&lt;h4 id=&quot;2019-12-26-更新&quot;&gt;&lt;a href=&quot;#2019-12-26-更新&quot; class=&quot;headerlink&quot; title=&quot;2019/12/26 更新&quot;&gt;&lt;/a&gt;2019/12/26 更新&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;获取歌曲播放地址接口 增加 lyric参数代表是否获取歌词。&lt;/li&gt;
&lt;li&gt;增加获取歌词接口&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;2019-12-24-更新&quot;&gt;&lt;a href=&quot;#2019-12-24-更新&quot; class=&quot;headerlink&quot; title=&quot;2019/12/24 更新&quot;&gt;&lt;/a&gt;2019/12/24 更新&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;所有音乐接口更改，增加一层music/ ，获取地址改为 music/song&lt;/li&gt;
&lt;li&gt;增加福利图片接口&lt;/li&gt;
&lt;li&gt;示例接口更改为https&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;接口仅供交流学习使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lunhui1994/node-music-api&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github 项目地址&lt;/a&gt; 欢迎star&lt;/p&gt;
&lt;p&gt;因为之前使用网络上别人封装的音乐api现在无法使用，或者一些需要付费使用，当然这也无可厚非。&lt;/p&gt;
&lt;p&gt;但对我而言，只需要简单的一些音乐api做一些东西。 感觉给钱有点亏。 就自己搞一个简单的符合我的需求的吧。&lt;/p&gt;
&lt;h1 id=&quot;文档&quot;&gt;&lt;a href=&quot;#文档&quot; class=&quot;headerlink&quot; title=&quot;文档&quot;&gt;&lt;/a&gt;文档&lt;/h1&gt;
    
    </summary>
    
      <category term="api" scheme="http://www.zsfmyz.top/categories/api/"/>
    
    
      <category term="api" scheme="http://www.zsfmyz.top/tags/api/"/>
    
  </entry>
  
  <entry>
    <title>Git入门篇</title>
    <link href="http://www.zsfmyz.top/Git/Git%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    <id>http://www.zsfmyz.top/Git/Git入门篇/</id>
    <published>2019-11-28T07:14:27.000Z</published>
    <updated>2020-03-02T06:03:37.407Z</updated>
    
    <content type="html"><![CDATA[<h5 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h5><ul><li>首先我们需要去github官网申请git账号。<a href="https://github.com/" target="_blank" rel="noopener">git官网</a></li><li><p>申请之后，我们进入自己的linux服务器</p></li><li><p>安装git</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y git</span><br><span class="line"></span><br><span class="line">git --version</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li>配置 ssh-keygen</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 生成key</span><br><span class="line">ssh-keygen</span><br><span class="line">//查看公钥  </span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><ul><li>然后在GitHub上加入这个公钥 <a href="https://github.com/settings/keys" target="_blank" rel="noopener">配置公钥</a> </li></ul><p><img src="/img/github-key.jpg" alt="github-key"></p><ul><li>设置git命令的简写模式（alias）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.st status</span><br></pre></td></tr></table></figure><ul><li>设置自己的名字和邮箱</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;your name&quot;</span><br><span class="line">git config --global user.email &quot;your email @.com&quot;</span><br></pre></td></tr></table></figure><ul><li><h5 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h5></li></ul><p>如果你想使用别人的项目，就需要fork。<br><img src="/img/github-fork.jpg" alt="github-fork"></p><ul><li>一般我们参与公司项目，都会先fork公司的仓库。</li></ul><ul><li><h5 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h5></li></ul><p>进入一个你想存放项目的文件夹。<br><img src="/img/github-clone.jpg" alt="github-clone"></p><p>如图复制ssh地址。</p><ul><li>一般我们复制的这个ssh地址，是先fork了公司的仓库，然后回到自己的仓库下面复制自己的ssh。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:xxx/xxx.git</span><br></pre></td></tr></table></figure><p>然后就可以对代码进行修改和提交了。</p><ul><li><h5 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h5></li></ul><p>项目有不同的分支。<br>一般本地主分支为master。<br>自己的远程仓库为 origin<br>如果是公司的项目，可能还会添加一个公司仓库 gongsi</p><p>可以用以下命令查看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git br -va</span><br></pre></td></tr></table></figure></p><p>一般我们都master分支上。</p><p>那么当我们修改了master分支的文件，但是又想恢复它到我们修改之前的状态，就需要checkout</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git co xxx.html</span><br></pre></td></tr></table></figure><p>checkout也可以创建本地分支: </p><p>origin/develop为远程仓库origin里面的一条分支，</p><p>我们要在本地创建一条和它一样的分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git co -b develop origin/develop</span><br></pre></td></tr></table></figure><p>另一种情况 本地和远程都只有master分支，</p><p>我们要在master的基础上添加订制功能，</p><p>需要独立出来一条和master一样的分支，然后再修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git co -b develop origin/master</span><br><span class="line"></span><br><span class="line"># 增加完新功能之后</span><br><span class="line"></span><br><span class="line">git push origin develop</span><br></pre></td></tr></table></figure><p>这样就会在本地和远程origin都创建了一条develop分支完成定制功能的添加又不影响原来的master分支。</p><ul><li><h5 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h5></li></ul><p>当我们修改某个文件，使用git st就可以看到哪些文件被修改了。<br>然后使用 git add 可以将我们修改过的文件添加进暂存区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git st</span><br><span class="line"></span><br><span class="line">git add xxx.html</span><br></pre></td></tr></table></figure></p><p>commit为某次修改的描述，是阶段性的。<br>我们每完成一个功能，或者每修复一个bug，最好都进行一次提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ci -m &apos;描述&apos;</span><br></pre></td></tr></table></figure><p>最后将代码push到我们的远程分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master(分支名)</span><br></pre></td></tr></table></figure><ul><li><h5 id="show"><a href="#show" class="headerlink" title="show"></a>show</h5>提交了之后，下一次我们想看看我们以前某次提交的东西是什么。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br><span class="line">git show 版本号</span><br></pre></td></tr></table></figure><p>这样可以查看该版本提交的东西，当然我们也可以上git去查看。</p><ul><li><h5 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h5>有时候我们会后悔添加了文件。那么可以用reset 返回</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset xxx.html</span><br></pre></td></tr></table></figure><p>这样就可以返回add之前的文件状态。</p><p>同样的我们如果已经push到远程分支了</p><p>想要回到我们push之前的状态，或者再之前的某个版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br><span class="line">git reset --hard 版本号</span><br></pre></td></tr></table></figure><p>以上两个步骤，第一步是查看我们这个分支的所有版本号。</p><p>复制你想要回退的版本号，然后执行第二步，就会回退到目标版本了。</p><p>然后再次执行你想要add，ci，push等命令，将你想要提交的文件push到远程。</p><ul><li><h5 id="fetch-merge"><a href="#fetch-merge" class="headerlink" title="fetch/merge"></a>fetch/merge</h5></li></ul><p>push之后我们的远程分支就会和本地分支的内容一样了。</p><p>但是如果我们是一个公共项目，那就需要并入公共仓库（gongsi）。</p><p>这个就需要管理员来操作了。</p><p><img src="/img/github-pull1.jpg" alt="github-pull1"></p><p><img src="/img/github-pull2.jpg" alt="github-pull2"></p><p>等管理员合并了之后，别人就需要fetch并且merge你的代码，以此来使大家的代码都是同步的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all</span><br><span class="line"></span><br><span class="line">git merge gongsi/master</span><br></pre></td></tr></table></figure><p>每次push之前我们都应该先merge一下公共仓库的代码。<br>以免我们在旧代码上修改提交导致冲突。</p><ul><li><h5 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h5></li></ul><p>那么我们如何删除自己的本地分支和远程分支呢，拿new_master举例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git br -d new_master</span><br><span class="line">git push origin -d new_master</span><br></pre></td></tr></table></figure><ul><li><h5 id="remote"><a href="#remote" class="headerlink" title="remote"></a>remote</h5></li></ul><p>当我们从某个git地址clone下来仓库后，仓库的远程地址就是你所clone的地址。</p><p>此时如果我们想修改我们的远程仓库怎么办呢（也就是修改origin的远程地址）</p><p>那就用到remote了</p><p>首先查看远程地址：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure></p><p>然后修改远程地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url [仓库名称] [url]</span><br><span class="line"></span><br><span class="line"># 例如：修改origin这个仓库的远程地址。</span><br><span class="line"># git remote set-url origin git@github.com:xiaoming/project.git</span><br></pre></td></tr></table></figure><p>那么如果要新添加一个远程地址呢？比如我们添加公司的（或者其他任何）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git remote add [自定义远程仓库名] [url]</span><br><span class="line"></span><br><span class="line"># 例如：</span><br><span class="line"># git remote add gongsi git@github.com:gongsi/project.git</span><br></pre></td></tr></table></figure><p>添加完公司的仓库之后，我们远程公司的仓库有了，但是本地还没有，怎么办呢，就用到前面的checkout了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git co -b [创建本地分支名] [远程仓库名/远程仓库分支名]</span><br><span class="line"></span><br><span class="line"># 例如：创建一个本地分支 develop 该分支的内容和gongsi/develop分支的内容一致。</span><br><span class="line"># git co -b develop gongsi/develop</span><br></pre></td></tr></table></figure><p>推送到自己的远程分支。<br>如果我们的origin上没有 develop 分支，那就会自动创建一个。</p><p>这样就保持三个分支一致了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin develop</span><br></pre></td></tr></table></figure><ul><li><h5 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h5></li></ul><p>有的时候，我们正在修改master分支。突然有一个紧急需求需要在develop上修改。</p><p>但是master还没有修改完，我们不能切换分支。</p><p>那怎么办呢？我们可以使用stash。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br><span class="line"></span><br><span class="line">git co develop</span><br><span class="line"></span><br><span class="line">git co master</span><br><span class="line"></span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p>以上三个步骤</p><p>第一步 将我们修改的内容缓存起来</p><p>第二步 切换到develop 分支,然后修改提交之后</p><p>第三步 切换到master分支</p><p>第四步 恢复切换到develop之前的master分支的修改内容。</p><p>以上就是常用的git命令，当然还有更多的和更深的命令，可以扩展了解一下。</p><p>另外我们装完git如果颜色都是白色的，会感觉不太容易区分。可以配置下颜色</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global color.status auto</span><br><span class="line">git config --global color.diff auto</span><br><span class="line">git config --global color.branch auto</span><br><span class="line">git config --global color.interactive auto</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;首先我们需要去github官网申请git账号。&lt;a href=&quot;https://github.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;git官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;申请之后，我们进入自己的linux服务器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装git&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;yum install -y git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git --version&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Git" scheme="http://www.zsfmyz.top/categories/Git/"/>
    
    
      <category term="Git" scheme="http://www.zsfmyz.top/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>linux文件共享服务(Samba安装配置)</title>
    <link href="http://www.zsfmyz.top/Linux/linux%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E6%9C%8D%E5%8A%A1(samba%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE)/"/>
    <id>http://www.zsfmyz.top/Linux/linux文件共享服务(samba安装配置)/</id>
    <published>2019-11-27T10:14:27.000Z</published>
    <updated>2019-11-27T07:16:12.293Z</updated>
    
    <content type="html"><![CDATA[<p>我们的服务器基本都是linux系统的，但是我们需要在windows下开发。</p><p>解决方案有两种：</p><ol><li>通过git同步linux和windows下的代码。</li><li>通过文件共享使windows连接linux下的共享文件夹</li></ol><p>现在说第二种方式如何实现：</p><p>Samba的介绍我就不多说了，总结一下就是可以在windows下操作编辑linux里面共享的内容。</p><a id="more"></a><p>#####（一）samba 安装</p><p>安装之前用rpm确定一下自己的服务器是否已经安装过了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep samba</span><br></pre></td></tr></table></figure><p>如果没有，我们就通过yum来下载rpm包来安装它</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y samba</span><br></pre></td></tr></table></figure><p>安装完成之后可以再通过第一条命令查看是否安装成功。</p><p>安装成功之后，我们就需要修改samba的配置文件了。</p><p>#####（二）samba 配置</p><p>一般都在etc中<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/samba/smb.conf</span><br></pre></td></tr></table></figure></p><p> 打开之后其他的不用管，在该配置文件的末尾增加一段</p><p> 例如我们要共享根目录下的opt文件夹</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[opt]</span><br><span class="line">        comment = OPT</span><br><span class="line">        path = /opt/</span><br><span class="line">        public = yes</span><br><span class="line">        writable = yes</span><br><span class="line">        printable = no</span><br><span class="line">        guest ok = yes</span><br></pre></td></tr></table></figure><p>path 是你要共享的路径。</p><p>保存之后重启服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl start smb</span><br><span class="line"></span><br><span class="line">systemctl restart smb</span><br><span class="line"></span><br><span class="line">systemctl stop smb</span><br></pre></td></tr></table></figure><p>重启完之后基本samba就算安装配置完成。</p><p>想要使用还需要配置samba所需要的端口。</p><p>#####（三）配置 samba 端口</p><p>在这里使用阿里云服务器举例。</p><p><img src="/img/anquanzu.jpg" alt="github-key"><br><img src="/img/anquanzu1.jpg" alt="github-key"><br><img src="/img/anquanzu2.jpg" alt="github-key"></p><p>如图添加安全组规则</p><p>分别添加 136/138和445端口。</p><p>至此linux系统的问题都ok了。</p><p>#####（四）映射网络驱动器</p><p>然后到你的windows系统中</p><ol><li>右键我的电脑，映射网络驱动器。</li><li>输入\ip\xxx   以opt为例：\ip\opt ,ip为你的linux服务器ip</li><li>点击完成输入你的用户和密码。</li></ol><p>我们也可以创建一个用来使用samba的用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smbpasswd -a xiaoming  #添加用户xiaoming到Samba用户中</span><br></pre></td></tr></table></figure><p>然后接着会让你设置密码，设置完之后。重启samba就可以了。</p><p>#####（五）配置 samba 防火墙</p><p>如果连接不上，请关闭windows的防火墙试试。</p><p>如果还不行就设置下linux的防火墙</p><p>iptables</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iptables -I RH-Firewall-1-INPUT 5 -m state --state NEW -m tcp -p tcp --dport 139 -j ACCEPT</span><br><span class="line">iptables -I RH-Firewall-1-INPUT 5 -m state --state NEW -m tcp -p tcp --dport 445 -j ACCEPT</span><br><span class="line">iptables -I RH-Firewall-1-INPUT 5 -p udp -m udp --dport 137 -j ACCEPT</span><br><span class="line">iptables -I RH-Firewall-1-INPUT 5 -p udp -m udp --dport 138-j ACCEPT</span><br><span class="line">iptables-save</span><br><span class="line">systemctl restart iptables</span><br></pre></td></tr></table></figure><p>selinux</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setsebool -P samba_enable_home_dirs on</span><br><span class="line">setsebool -P samba_export_all_rw on</span><br></pre></td></tr></table></figure><p>然后重新映射网络位置。</p><p>#####（六）放弃</p><p>如果还不可以，那放弃就好了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们的服务器基本都是linux系统的，但是我们需要在windows下开发。&lt;/p&gt;
&lt;p&gt;解决方案有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过git同步linux和windows下的代码。&lt;/li&gt;
&lt;li&gt;通过文件共享使windows连接linux下的共享文件夹&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;现在说第二种方式如何实现：&lt;/p&gt;
&lt;p&gt;Samba的介绍我就不多说了，总结一下就是可以在windows下操作编辑linux里面共享的内容。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://www.zsfmyz.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://www.zsfmyz.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode_145. 二叉树的后序遍历</title>
    <link href="http://www.zsfmyz.top/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/leetcode_145.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://www.zsfmyz.top/Algorithm/每日一题/leetcode_145. 二叉树的后序遍历/</id>
    <published>2019-11-17T03:59:13.000Z</published>
    <updated>2019-11-20T10:07:14.865Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目解析："><a href="#题目解析：" class="headerlink" title="题目解析："></a>题目解析：</h3><p>给定一个二叉树，返回它的 后序 遍历。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [3,2,1]</span><br></pre></td></tr></table></figure></p><p>说明&amp;&amp;进阶:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 递归算法很简单，你可以通过迭代算法完成吗？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">前序排列的顺序是左，右，父。</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>递归，递归判断条件，该节点左右节点是否为null，递归时先左后右。跟前序遍历唯一的差别是最后再push。</code></pre><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> */</span><br><span class="line"> let postorderArr = [];</span><br><span class="line"> let addNode = (root) =&gt; &#123;</span><br><span class="line">     root.left &amp;&amp; addNode(root.left);</span><br><span class="line">     root.right &amp;&amp; addNode(root.right);</span><br><span class="line">     postorderArr.push(root.val) // 唯一的差别</span><br><span class="line"> &#125;</span><br><span class="line"> let postorderTraversal  = (root) =&gt; &#123;</span><br><span class="line">     postorderArr = [];</span><br><span class="line">     if (!root) &#123;</span><br><span class="line">         return postorderArr;</span><br><span class="line">    &#125;</span><br><span class="line">     addNode(root);</span><br><span class="line">     return postorderArr;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><h3 id="解题思路二"><a href="#解题思路二" class="headerlink" title="解题思路二"></a>解题思路二</h3><p>   迭代法，基于栈的特性将递推出来的节点压进栈中。然后遵循先进后出的原则，直至将栈排空。</p><p>   后序遍历的迭代法比较前序遍历要复杂一些。</p><p>   我的思路是打表，已经遍历过的节点需要标记（截断）。</p><h3 id="解答二"><a href="#解答二" class="headerlink" title="解答二"></a>解答二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">let postorderArr = [], nodeList = [], nowNode;</span><br><span class="line">let postorderTraversal  = (root) =&gt; &#123;</span><br><span class="line">    postorderArr = [];</span><br><span class="line">    if (!root) &#123;</span><br><span class="line">        return postorderArr;</span><br><span class="line">    &#125;</span><br><span class="line">    nodeList = [], nowNode = root;</span><br><span class="line">     while(nodeList.length &gt; 0 || nowNode) &#123;</span><br><span class="line">        while (nowNode) &#123;</span><br><span class="line">            nowNode.flag = true; // 标记该节点已经进入过数组</span><br><span class="line">            nodeList.push(nowNode);</span><br><span class="line">            </span><br><span class="line">            //如果该节点的左节点已经遍历过了就不需要遍历了  先左</span><br><span class="line">            </span><br><span class="line">            if (nowNode.left &amp;&amp; !nowNode.left.flag) &#123; </span><br><span class="line">                nowNode = nowNode.left;</span><br><span class="line">            </span><br><span class="line">            //如果该节点的右节点已经遍历过了就不需要遍历了  后右</span><br><span class="line"></span><br><span class="line">            &#125; else if (nowNode.right &amp;&amp; !nowNode.right.flag) &#123; </span><br><span class="line">                nowNode = nowNode.right;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            </span><br><span class="line">                //左右节点都遍历过的相当于叶节点（度为0，没有子节点）</span><br><span class="line">            </span><br><span class="line">                nowNode = null; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 从栈中取值</span><br><span class="line">        nowNode = nodeList.pop(); </span><br><span class="line"></span><br><span class="line">        // 用来区分是否为叶节点 若为叶则赋值null，遍历下一轮。</span><br><span class="line">        </span><br><span class="line">        if (!nowNode.right || nowNode.right.flag) &#123;</span><br><span class="line">            postorderArr.push(nowNode.val);</span><br><span class="line">            nowNode = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return postorderArr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目解析：&quot;&gt;&lt;a href=&quot;#题目解析：&quot; class=&quot;headerlink&quot; title=&quot;题目解析：&quot;&gt;&lt;/a&gt;题目解析：&lt;/h3&gt;&lt;p&gt;给定一个二叉树，返回它的 后序 遍历。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;p&gt;示例 1:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,null,2,3]  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   3 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [3,2,1]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;说明&amp;amp;&amp;amp;进阶:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; 递归算法很简单，你可以通过迭代算法完成吗？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;前序排列的顺序是左，右，父。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/categories/Algorithm/"/>
    
      <category term="每日一题" scheme="http://www.zsfmyz.top/categories/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode_94. 二叉树的中序遍历</title>
    <link href="http://www.zsfmyz.top/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/leetcode_94.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://www.zsfmyz.top/Algorithm/每日一题/leetcode_94. 二叉树的中序遍历/</id>
    <published>2019-10-17T03:59:13.000Z</published>
    <updated>2019-11-20T10:18:04.324Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目解析："><a href="#题目解析：" class="headerlink" title="题目解析："></a>题目解析：</h3><p>给定一个二叉树，返回它的 中序 遍历。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [1,3,2]</span><br></pre></td></tr></table></figure></p><p>说明&amp;&amp;进阶:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 递归算法很简单，你可以通过迭代算法完成吗？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">前序排列的顺序是左，父，右。</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>递归，递归判断条件，该节点左右节点是否为null，递归时先左后右。</code></pre><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> */</span><br><span class="line">var addNode = function (root) &#123;</span><br><span class="line">    root.left &amp;&amp; addNode(root.left);</span><br><span class="line">    inorderArr.push(root.val); // 前，中序遍历唯一区别 </span><br><span class="line">    root.right &amp;&amp; addNode(root.right);</span><br><span class="line">&#125;</span><br><span class="line">let inorderArr = [];</span><br><span class="line">var inorderTraversal = function(root) &#123;</span><br><span class="line">    inorderArr = [];</span><br><span class="line">    if (!root) &#123;</span><br><span class="line">        return inorderArr;</span><br><span class="line">    &#125;</span><br><span class="line">    addNode(root);</span><br><span class="line">    return inorderArr</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解题思路二"><a href="#解题思路二" class="headerlink" title="解题思路二"></a>解题思路二</h3><p>   迭代法，基于栈的特性将递推出来的节点压进栈中。然后遵循先进后出的原则，直至将栈排空。</p><h3 id="解答二"><a href="#解答二" class="headerlink" title="解答二"></a>解答二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> */</span><br><span class="line">let inorderArr = [], nodeList = [], nowNode;</span><br><span class="line">var inorderTraversal = function(root) &#123;</span><br><span class="line">    inorderArr = [], nodeList = [], nowNode = root;</span><br><span class="line">    if (!root) &#123;</span><br><span class="line">        return inorderArr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while(nodeList.length &gt; 0 || nowNode) &#123;</span><br><span class="line">        while (nowNode) &#123;</span><br><span class="line">            nodeList.push(nowNode);</span><br><span class="line">            nowNode = nowNode.left;</span><br><span class="line">        &#125;</span><br><span class="line">        nowNode = nodeList.pop();</span><br><span class="line">        inorderArr.push(nowNode.val);</span><br><span class="line">        nowNode = nowNode.right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return inorderArr</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目解析：&quot;&gt;&lt;a href=&quot;#题目解析：&quot; class=&quot;headerlink&quot; title=&quot;题目解析：&quot;&gt;&lt;/a&gt;题目解析：&lt;/h3&gt;&lt;p&gt;给定一个二叉树，返回它的 中序 遍历。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;p&gt;示例 1:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,null,2,3]  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   3 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [1,3,2]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;说明&amp;amp;&amp;amp;进阶:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; 递归算法很简单，你可以通过迭代算法完成吗？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;前序排列的顺序是左，父，右。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/categories/Algorithm/"/>
    
      <category term="每日一题" scheme="http://www.zsfmyz.top/categories/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode_144. 二叉树的前序遍历</title>
    <link href="http://www.zsfmyz.top/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/leetcode_144.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://www.zsfmyz.top/Algorithm/每日一题/leetcode_144. 二叉树的前序遍历/</id>
    <published>2019-10-17T03:59:13.000Z</published>
    <updated>2019-10-17T10:08:30.354Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目解析："><a href="#题目解析：" class="headerlink" title="题目解析："></a>题目解析：</h3><p>给定一个二叉树，返回它的 前序 遍历。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [1,2,3]</span><br></pre></td></tr></table></figure></p><p>说明&amp;&amp;进阶:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 递归算法很简单，你可以通过迭代算法完成吗？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">前序排列的顺序是父节点在前，然后遍历左树，然后遍历右树。</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>递归，递归判断条件，该节点左右节点是否为null，递归时先左后右。</code></pre><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> */</span><br><span class="line">let frontArr = [];</span><br><span class="line">let addNode = (root) =&gt; &#123;</span><br><span class="line">    frontArr.push(root.val)</span><br><span class="line">    root.left &amp;&amp; addNode(root.left);</span><br><span class="line">    root.right &amp;&amp; addNode(root.right);</span><br><span class="line">&#125;</span><br><span class="line">let preorderTraversal = (root) =&gt; &#123;</span><br><span class="line">    frontArr = [];</span><br><span class="line">    if (!root) &#123;</span><br><span class="line">        return frontArr;</span><br><span class="line">    &#125;</span><br><span class="line">    addNode(root);</span><br><span class="line">    return frontArr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解题思路二"><a href="#解题思路二" class="headerlink" title="解题思路二"></a>解题思路二</h3><p>   迭代法，基于栈的特性将递推出来的节点压进栈中。然后遵循先进后出的原则，直至将栈排空。</p><h3 id="解答二"><a href="#解答二" class="headerlink" title="解答二"></a>解答二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">let frontArr = [], nodeList = [], nowNode;</span><br><span class="line">let preorderTraversal = (root) =&gt; &#123;</span><br><span class="line">    frontArr = [];</span><br><span class="line">    if (!root) &#123;</span><br><span class="line">        return frontArr;</span><br><span class="line">    &#125;</span><br><span class="line">    nodeList = [root];</span><br><span class="line">    while(nodeList.length &gt; 0) &#123;</span><br><span class="line">        nowNode = nodeList.pop();</span><br><span class="line">        frontArr.push(nowNode.val);</span><br><span class="line">        nowNode.right &amp;&amp; nodeList.push(nowNode.right);</span><br><span class="line">        nowNode.left &amp;&amp; nodeList.push(nowNode.left);        </span><br><span class="line">    &#125;</span><br><span class="line">    return frontArr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目解析：&quot;&gt;&lt;a href=&quot;#题目解析：&quot; class=&quot;headerlink&quot; title=&quot;题目解析：&quot;&gt;&lt;/a&gt;题目解析：&lt;/h3&gt;&lt;p&gt;给定一个二叉树，返回它的 前序 遍历。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;p&gt;示例 1:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,null,2,3]  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   3 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [1,2,3]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;说明&amp;amp;&amp;amp;进阶:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; 递归算法很简单，你可以通过迭代算法完成吗？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;前序排列的顺序是父节点在前，然后遍历左树，然后遍历右树。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/categories/Algorithm/"/>
    
      <category term="每日一题" scheme="http://www.zsfmyz.top/categories/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode_264. 丑数 II</title>
    <link href="http://www.zsfmyz.top/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/leetcode_264.%20%E4%B8%91%E6%95%B0%20II/"/>
    <id>http://www.zsfmyz.top/Algorithm/每日一题/leetcode_264. 丑数 II/</id>
    <published>2019-10-12T03:59:13.000Z</published>
    <updated>2019-10-12T02:43:59.379Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目解析："><a href="#题目解析：" class="headerlink" title="题目解析："></a>题目解析：</h3><p>编写一个程序，找出第 n 个丑数。</p><p>丑数就是只包含质因数 2, 3, 5 的正整数。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 10</span><br><span class="line">输出: 12</span><br><span class="line">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span><br></pre></td></tr></table></figure></p><p>提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 是丑数。</span><br><span class="line">n 不超过1690。</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>方法一暴力循环（毫无疑问超时了）</code></pre><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var isUgly = function(num) &#123;</span><br><span class="line">    if (num &lt; 1) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">     while(num % 2 == 0) &#123;</span><br><span class="line">             num/=2</span><br><span class="line">         &#125; </span><br><span class="line">     while(num % 3 == 0) &#123;</span><br><span class="line">             num/=3</span><br><span class="line">         &#125; </span><br><span class="line">     while(num % 5 == 0) &#123;</span><br><span class="line">             num/=5</span><br><span class="line">         &#125;</span><br><span class="line">    </span><br><span class="line">    return (num == 1) ? true : false;</span><br><span class="line">&#125;;</span><br><span class="line">    var nthUglyNumber = function(n) &#123;</span><br><span class="line">    var ugly = 1;</span><br><span class="line">    for (var i = 0; i &lt; n; ugly++) &#123;</span><br><span class="line">        if (isUgly(ugly)) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ugly;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解题思路二"><a href="#解题思路二" class="headerlink" title="解题思路二"></a>解题思路二</h3><pre><code>1. 根据题目的意思，我们首先知道丑数的因子只能是(2, 3, 5).当我们要从[1],推算出[1,2,3,4,5,6,8,9...]丑数序列时,过程如下var arr = [1]; 推算第二个数：比较arr[0]*2 和 arr[0]*3 和arr[0]*5 中取最小的一个arr[0]*2放进数组中： [1, arr[0]*2]。依次类推下次比较：arr[1]*2 和 arr[0]*3 和 arr[0]*5 中取最小arr[0]*3放进数组中： [1, arr[0]*2, arr[0]*3]依次类推下次比较：arr[1]*2 和 arr[1]*3 和 arr[0]*5 中取最小arr[1]*2放进数组中： [1, arr[0]*2, arr[0]*3, arr[1]*2]等等。。2. 由上可以看出，我们需要丑数组arr, 还有2,3,5三个质因数分别乘到了arr的第几个数。拿2作例子：我们需要知道数组的前多少个已经乘过2了。当arr[0]*2 之后，下次就该arr[1]*2跟其他的作比较了。即这2，3，5需要三个标记。在上面举例中第三次之后的下标为：[2, 1, 0].即下次比较应该用arr[2]*2 和 arr[1]*3 和arr[0]*5 来比较哪个小。3. 中间会遇到比如 arr[2]*2 == arr[1]*3 这样的情况。此时把2，3 的下标都+1即可.最后依次求到目标数组arr的第n个数即为答案。</code></pre><h3 id="解答二"><a href="#解答二" class="headerlink" title="解答二"></a>解答二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var nthUglyNumber = function(n) &#123;</span><br><span class="line">    var arr = [1], indexArr = [0, 0, 0],v2,v3,v5,temp;</span><br><span class="line">    for(var i = 0; i &lt;= n; i++) &#123;</span><br><span class="line">        v2 = arr[indexArr[0]] * 2;        </span><br><span class="line">        v3 = arr[indexArr[1]] * 3;</span><br><span class="line">        v5 = arr[indexArr[2]] * 5;</span><br><span class="line">        temp = Math.min(v2,Math.min(v3,v5)); // 判断最小</span><br><span class="line">        if (temp == v2) &#123;</span><br><span class="line">            indexArr[0]++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (temp == v3) &#123;</span><br><span class="line">            indexArr[1]++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (temp == v5) &#123;</span><br><span class="line">            indexArr[2]++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr.push(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr[n-1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目解析：&quot;&gt;&lt;a href=&quot;#题目解析：&quot; class=&quot;headerlink&quot; title=&quot;题目解析：&quot;&gt;&lt;/a&gt;题目解析：&lt;/h3&gt;&lt;p&gt;编写一个程序，找出第 n 个丑数。&lt;/p&gt;
&lt;p&gt;丑数就是只包含质因数 2, 3, 5 的正整数。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;p&gt;示例 1:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: n = 10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;提示：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1 是丑数。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;n 不超过1690。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/categories/Algorithm/"/>
    
      <category term="每日一题" scheme="http://www.zsfmyz.top/categories/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode_26. 删除排序数组中的重复项</title>
    <link href="http://www.zsfmyz.top/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/leetcode_26.%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <id>http://www.zsfmyz.top/Algorithm/每日一题/leetcode_26. 删除排序数组中的重复项/</id>
    <published>2019-09-27T03:59:13.000Z</published>
    <updated>2019-09-27T07:12:55.017Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目解析："><a href="#题目解析：" class="headerlink" title="题目解析："></a>题目解析：</h3><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [1,1,2], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></p><p>提示：</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>题目中原地的意思大概就是要在原数组中操作不能开辟新的数组空间。题目简单，就是去除数组中的重复元素。首先想到的是删除数组中的重复元素，用到了splice。</code></pre><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var removeDuplicates = function(nums) &#123;</span><br><span class="line">    for (var i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        if (nums.includes(nums[i], i + 1)) &#123;</span><br><span class="line">            nums.splice(i, 1);</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解题思路二"><a href="#解题思路二" class="headerlink" title="解题思路二"></a>解题思路二</h3><pre><code>由于第一种方法用到了splice，所以其实时空间复杂度还是比较高的。所以，根据题目要求我们其实只需要保证数组的前面排列的是我们需要的就可以了。超过的部分我可以忽略不计。那其实就是依次从头填充数组就可以了！直到遍历完数组的最后一位。双指针就解决了。一个用来遍历数组，一个用来从头修改数组。由于题目告诉为排序数组，所以我们可以用i，i+1判断。</code></pre><h3 id="解答二"><a href="#解答二" class="headerlink" title="解答二"></a>解答二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var removeDuplicates = function(nums) &#123;</span><br><span class="line">    var next = 0;</span><br><span class="line">    for (var i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        if (nums[i] != nums[i+1]) &#123;</span><br><span class="line">            nums[next] = nums[i];</span><br><span class="line">            next++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解题思路三"><a href="#解题思路三" class="headerlink" title="解题思路三"></a>解题思路三</h3><pre><code>了解一下ES6的array.includes(searchEle, fromIndex);判断数组种是否含有searchEle。(true / false);searchEle为搜索的元素（必填），fromIndex为从数组的哪一位开始搜索。使用includes同时可以判断非排序的数组</code></pre><h3 id="解答三"><a href="#解答三" class="headerlink" title="解答三"></a>解答三</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var removeDuplicates = function(nums) &#123;</span><br><span class="line">    var j = 0;</span><br><span class="line">    for (var i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        if (!nums.includes(nums[i], i + 1)) &#123;</span><br><span class="line">            nums[j] = nums[i];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return j;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目解析：&quot;&gt;&lt;a href=&quot;#题目解析：&quot; class=&quot;headerlink&quot; title=&quot;题目解析：&quot;&gt;&lt;/a&gt;题目解析：&lt;/h3&gt;&lt;p&gt;给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。&lt;/p&gt;
&lt;p&gt;不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;p&gt;示例 1:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给定数组 nums = [1,1,2], &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;你不需要考虑数组中超出新长度后面的元素。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;示例 2:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给定 nums = [0,0,1,1,1,2,2,3,3,4],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;你不需要考虑数组中超出新长度后面的元素。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;p&gt;为什么返回数值是整数，但输出的答案是数组呢?&lt;/p&gt;
&lt;p&gt;请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。&lt;/p&gt;
&lt;p&gt;你可以想象内部操作如下:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int len = removeDuplicates(nums);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 在函数里修改输入数组对于调用者是可见的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for (int i = 0; i &amp;lt; len; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(nums[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/categories/Algorithm/"/>
    
      <category term="每日一题" scheme="http://www.zsfmyz.top/categories/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode_5198. 丑数 III</title>
    <link href="http://www.zsfmyz.top/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/leetcode_5198.%20%E4%B8%91%E6%95%B0%20III/"/>
    <id>http://www.zsfmyz.top/Algorithm/每日一题/leetcode_5198. 丑数 III/</id>
    <published>2019-09-26T03:59:13.000Z</published>
    <updated>2019-09-27T02:05:07.686Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目解析："><a href="#题目解析：" class="headerlink" title="题目解析："></a>题目解析：</h3><p>请你帮忙设计一个程序，用来找出第 n 个丑数。</p><p>丑数是可以被 a 或 b 或 c 整除的 正整数。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3, a = 2, b = 3, c = 5</span><br><span class="line">输出：4</span><br><span class="line">解释：丑数序列为 2, 3, 4, 5, 6, 8, 9, 10... 其中第 3 个是 4。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, a = 2, b = 3, c = 4</span><br><span class="line">输出：6</span><br><span class="line">解释：丑数序列为 2, 3, 4, 6, 8, 9, 12... 其中第 4 个是 6。</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5, a = 2, b = 11, c = 13</span><br><span class="line">输出：10</span><br><span class="line">解释：丑数序列为 2, 4, 6, 8, 10, 11, 12, 13... 其中第 5 个是 10。</span><br></pre></td></tr></table></figure></p><p>示例 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1000000000, a = 2, b = 217983653, c = 336916467</span><br><span class="line">输出：1999999984</span><br></pre></td></tr></table></figure></p><p>提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= n, a, b, c &lt;= 10^9</span><br><span class="line">1 &lt;= a * b * c &lt;= 10^18</span><br><span class="line">本题结果在 [1, 2 * 10^9] 的范围内</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>方法一暴力循环（毫无疑问超时了）</code></pre><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    var nthUglyNumber = function(n, a, b, c) &#123;</span><br><span class="line">    var num = 1;</span><br><span class="line">    for (var i = 1; i &lt;= n; num++) &#123;</span><br><span class="line">        if (num % a == 0 || num % b == 0 || num % c == 0) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return num - 1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解题思路二"><a href="#解题思路二" class="headerlink" title="解题思路二"></a>解题思路二</h3><pre><code>1.找出该数可能存在的范围，首先可以思考判断得出最小的值为n ，最大为min(a,b,c) * n2.假设最终结果为finalValue，求出该值的序列长度nums。例如：下面的例子中finalValue为6，而其序列就为[2, 3, 4, 6],长度为4===n。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, a = 2, b = 3, c = 4</span><br><span class="line">输出：6</span><br><span class="line">解释：丑数序列为 2, 3, 4, 6, 8, 9, 12... 其中第 4 个是 6。</span><br></pre></td></tr></table></figure>3.通过二分法查找finalValue4.判断条件为: nums.length === n ? ，如果相等即为该值。** 注意：finalValue必须符合是a，b，c的倍数，且是所有符合条件的值中最小的一个。 **</code></pre><h3 id="解答二"><a href="#解答二" class="headerlink" title="解答二"></a>解答二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//最大公约数 ：a和 a%b 的最大公约数 和 a 和 b 的最大公约数一致</span><br><span class="line">var maxComFn = function(a, b) &#123;</span><br><span class="line">    if (a % b === 0) &#123;</span><br><span class="line">        return b;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return maxComFn(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//最小公倍数  公式法： a*b === a和b的最大公约数 * a和b的最小公倍数</span><br><span class="line">var minComFn = function(a, b) &#123;</span><br><span class="line">    var maxC = maxComFn(a, b)</span><br><span class="line">    return a * b / maxC;</span><br><span class="line">&#125;</span><br><span class="line">//值的序列长度  容斥定理， 含有a，b，c的个数 - ab，ac，bc的公倍数的个数 + abc公倍数的个数</span><br><span class="line">var inNumsFn = function(a, b, c, num) &#123;</span><br><span class="line">    return Math.floor(num / a) + </span><br><span class="line">        Math.floor(num / b) +</span><br><span class="line">        Math.floor(num / c) -</span><br><span class="line">        Math.floor(num / minComFn(a, b)) -</span><br><span class="line">        Math.floor(num / minComFn(a, c)) -</span><br><span class="line">        Math.floor(num / minComFn(c, b)) +</span><br><span class="line">        Math.floor(num / minComFn(c, minComFn(a, b)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var nthUglyNumber = function(n, a, b, c) &#123;</span><br><span class="line">    var maxCom = maxComFn(a, maxComFn(b, c));</span><br><span class="line">    let mid,</span><br><span class="line">        left = n,</span><br><span class="line">        right = n * Math.min(a, b, c);</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        mid = Math.floor((left + right) / 2);</span><br><span class="line">        if (inNumsFn(a, b, c, mid) &lt; n) &#123;</span><br><span class="line">            left = mid + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            right = mid; //一直求到最小。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目解析：&quot;&gt;&lt;a href=&quot;#题目解析：&quot; class=&quot;headerlink&quot; title=&quot;题目解析：&quot;&gt;&lt;/a&gt;题目解析：&lt;/h3&gt;&lt;p&gt;请你帮忙设计一个程序，用来找出第 n 个丑数。&lt;/p&gt;
&lt;p&gt;丑数是可以被 a 或 b 或 c 整除的 正整数。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;p&gt;示例 1:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：n = 3, a = 2, b = 3, c = 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：丑数序列为 2, 3, 4, 5, 6, 8, 9, 10... 其中第 3 个是 4。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;示例 2:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：n = 4, a = 2, b = 3, c = 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：丑数序列为 2, 3, 4, 6, 8, 9, 12... 其中第 4 个是 6。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;示例 3:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：n = 5, a = 2, b = 11, c = 13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：丑数序列为 2, 4, 6, 8, 10, 11, 12, 13... 其中第 5 个是 10。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;示例 4:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：n = 1000000000, a = 2, b = 217983653, c = 336916467&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：1999999984&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;提示：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1 &amp;lt;= n, a, b, c &amp;lt;= 10^9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 &amp;lt;= a * b * c &amp;lt;= 10^18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;本题结果在 [1, 2 * 10^9] 的范围内&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/categories/Algorithm/"/>
    
      <category term="每日一题" scheme="http://www.zsfmyz.top/categories/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode_1189. “气球” 的最大数量</title>
    <link href="http://www.zsfmyz.top/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/leetcode_1189.%20%E2%80%9C%E6%B0%94%E7%90%83%E2%80%9D%20%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F/"/>
    <id>http://www.zsfmyz.top/Algorithm/每日一题/leetcode_1189. “气球” 的最大数量/</id>
    <published>2019-09-25T03:59:13.000Z</published>
    <updated>2019-09-25T07:45:45.639Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目解析："><a href="#题目解析：" class="headerlink" title="题目解析："></a>题目解析：</h3><p>给你一个字符串 text，你需要使用 text 中的字母来拼凑尽可能多的单词 “balloon”（气球）。</p><p>字符串 text 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 “balloon”。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：text = &quot;nlaebolko&quot;</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：text = &quot;loonbalxballpoon&quot;</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure></p><p>提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= text.length &lt;= 10^4</span><br><span class="line">text 全部由小写英文字母组成</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>先找出各个字母的个数，然后找出其中的最小值(o,l数量除以2)。用match正则检测字符串中符合条件的字母，其长度即为该字母在字符串中的个数。</code></pre><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var maxNumberOfBalloons = function(text) &#123;</span><br><span class="line">    let regexp, singleNum, min = text.length;</span><br><span class="line">    for (let i in &quot;balon&quot;) &#123;</span><br><span class="line">        regexp = new RegExp(&quot;balon&quot;[i], &apos;g&apos;);</span><br><span class="line">        singleNum = text.match(regexp).length;</span><br><span class="line">        if (&quot;balon&quot;[i]) == &apos;o&apos; || &quot;balon&quot;[i]) == &apos;l&apos;) &#123;</span><br><span class="line">            singleNum = Math.floor(singleNum / 2)</span><br><span class="line">        &#125;</span><br><span class="line">        min = (min &lt;= singleNum) ? min : singleNum;</span><br><span class="line">    &#125;</span><br><span class="line">    return min;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解题思路二"><a href="#解题思路二" class="headerlink" title="解题思路二"></a>解题思路二</h3><pre><code>用split分割字符串，分割之后的数组长度-1 就是该字符(分隔符)在该字符串中的个数。</code></pre><h3 id="解答二"><a href="#解答二" class="headerlink" title="解答二"></a>解答二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var maxNumberOfBalloons = function(text) &#123;</span><br><span class="line">    let singleNum, min = text.length;</span><br><span class="line">    for (let i in &quot;balon&quot;) &#123;</span><br><span class="line">        singleNum = text.split(&quot;balon&quot;[i]).length - 1;</span><br><span class="line">        if (&quot;balon&quot;[i]) == &apos;o&apos; || &quot;balon&quot;[i]) == &apos;l&apos;) &#123;</span><br><span class="line">            singleNum = Math.floor(singleNum / 2)</span><br><span class="line">        &#125;</span><br><span class="line">        min = (min &lt;= singleNum) ? min : singleNum;</span><br><span class="line">    &#125;</span><br><span class="line">    return min;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目解析：&quot;&gt;&lt;a href=&quot;#题目解析：&quot; class=&quot;headerlink&quot; title=&quot;题目解析：&quot;&gt;&lt;/a&gt;题目解析：&lt;/h3&gt;&lt;p&gt;给你一个字符串 text，你需要使用 text 中的字母来拼凑尽可能多的单词 “balloon”（气球）。&lt;/p&gt;
&lt;p&gt;字符串 text 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 “balloon”。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;p&gt;示例 1:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：text = &amp;quot;nlaebolko&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;示例 2:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：text = &amp;quot;loonbalxballpoon&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;提示：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1 &amp;lt;= text.length &amp;lt;= 10^4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;text 全部由小写英文字母组成&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/categories/Algorithm/"/>
    
      <category term="每日一题" scheme="http://www.zsfmyz.top/categories/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode_35. 搜索插入位置</title>
    <link href="http://www.zsfmyz.top/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/leetcode_35.%20%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
    <id>http://www.zsfmyz.top/Algorithm/每日一题/leetcode_35. 搜索插入位置/</id>
    <published>2019-09-20T03:59:13.000Z</published>
    <updated>2019-09-25T07:45:45.455Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目解析："><a href="#题目解析：" class="headerlink" title="题目解析："></a>题目解析：</h3><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>利用findIndex函数遍历数组。</code></pre><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var findFuc = function(el, index, arr) &#123;</span><br><span class="line">    return el &gt;= this</span><br><span class="line">&#125;</span><br><span class="line">var searchInsert = function(nums, target) &#123;</span><br><span class="line">    return nums.findIndex(findFuc, target) == -1 ? nums.length : nums.findIndex(findFuc, target)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解题思路二"><a href="#解题思路二" class="headerlink" title="解题思路二"></a>解题思路二</h3><pre><code>利用二分法遍历数组。</code></pre><h3 id="解答二"><a href="#解答二" class="headerlink" title="解答二"></a>解答二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var searchInsert = function(nums, target) &#123;</span><br><span class="line">    if (nums[0] &gt;= target) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; </span><br><span class="line">    if (nums[nums.length - 1] &lt; target) &#123;</span><br><span class="line">        return nums.length;</span><br><span class="line">    &#125; </span><br><span class="line">    let left = 0, right = nums.length - 1, mid = parseInt((nums.length - 1)/2);</span><br><span class="line">    while(left &lt; (right-1)) &#123;</span><br><span class="line">        if (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;</span><br><span class="line">        mid = parseInt((left + right) / 2);</span><br><span class="line">    &#125;</span><br><span class="line">    return right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目解析：&quot;&gt;&lt;a href=&quot;#题目解析：&quot; class=&quot;headerlink&quot; title=&quot;题目解析：&quot;&gt;&lt;/a&gt;题目解析：&lt;/h3&gt;&lt;p&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。&lt;/p&gt;
&lt;p&gt;你可以假设数组中无重复元素。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;p&gt;示例 1:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,3,5,6], 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;示例 2:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,3,5,6], 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/categories/Algorithm/"/>
    
      <category term="每日一题" scheme="http://www.zsfmyz.top/categories/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode_14. 最长公共前缀</title>
    <link href="http://www.zsfmyz.top/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/leetcode_14.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <id>http://www.zsfmyz.top/Algorithm/每日一题/leetcode_14. 最长公共前缀/</id>
    <published>2019-09-20T03:59:13.000Z</published>
    <updated>2019-09-25T07:45:45.577Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目解析："><a href="#题目解析：" class="headerlink" title="题目解析："></a>题目解析：</h3><pre><code>编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 &quot;&quot;。</code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>依序判断所有字符串的第N位字符是否一致。一致就加入共同前缀，不一致就跳出返回之前的前缀。</code></pre><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var longestCommonPrefix = function(strs) &#123;</span><br><span class="line">    // 首先判断一下边界情况：</span><br><span class="line">    // 1. 当长度为0时，结果必然为&quot;&quot;;</span><br><span class="line">    // 2. 当长度为1时，结果必然为&quot;strs[0]&quot;;</span><br><span class="line">    if (!strs.length) &#123;return &quot;&quot;;&#125;;</span><br><span class="line">    if (strs.length == 1) &#123;return strs[0]&#125;;</span><br><span class="line">    // 定义公共前缀</span><br><span class="line">    let comStr = &quot;&quot;;</span><br><span class="line">    // 循环每个字符串的每个字母,以第一个字符串的长度为准</span><br><span class="line">    for (let i = 0; i &lt; strs[0].length; i++) &#123;</span><br><span class="line">        // 定义每次循环的第一个字符串的字母 当其字符串长度不够时，取值为undefined,所以会判断为不相等跳出循环。</span><br><span class="line">        let item = strs[0][i];</span><br><span class="line">        // 循环数组</span><br><span class="line">        for (let j = 0; j &lt; strs.length; j++) &#123;</span><br><span class="line">            //判断所有字符串的第i个字母是否一致，不一致返回原来的共同前缀。</span><br><span class="line">            if (strs[j][i] != item) &#123;  </span><br><span class="line">                return comStr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //一致的话将该字母加入共同前缀</span><br><span class="line">        comStr += item;</span><br><span class="line">    &#125;</span><br><span class="line">    // 回共同前缀 当所有字符串都一致的情况下才会在此处返回。</span><br><span class="line">    return comStr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解题思路二"><a href="#解题思路二" class="headerlink" title="解题思路二"></a>解题思路二</h3><pre><code>对数组中的字符串排序，然后比较最大和最小的字符串的公共前缀。即为数组的公共前缀</code></pre><h3 id="解答二"><a href="#解答二" class="headerlink" title="解答二"></a>解答二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var longestCommonPrefix = function(strs) &#123;</span><br><span class="line">    if (!strs.length) &#123;return &quot;&quot;;&#125;;</span><br><span class="line">    if (strs.length == 1) &#123;return strs[0]&#125;;</span><br><span class="line">    let comStr = &quot;&quot;;</span><br><span class="line">    strs.sort();</span><br><span class="line">    for (let i = 0; i &lt; strs[0].length; i++) &#123;</span><br><span class="line">        if (strs[0][i] != strs[strs.length - 1][i]) &#123;</span><br><span class="line">            return strs[0].slice(0, (i + 1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return strs[0];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目解析：&quot;&gt;&lt;a href=&quot;#题目解析：&quot; class=&quot;headerlink&quot; title=&quot;题目解析：&quot;&gt;&lt;/a&gt;题目解析：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 &amp;quot;&amp;quot;。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;p&gt;示例 1:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [&amp;quot;flower&amp;quot;,&amp;quot;flow&amp;quot;,&amp;quot;flight&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &amp;quot;fl&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;示例 2:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [&amp;quot;dog&amp;quot;,&amp;quot;racecar&amp;quot;,&amp;quot;car&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &amp;quot;&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 输入不存在公共前缀。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/categories/Algorithm/"/>
    
      <category term="每日一题" scheme="http://www.zsfmyz.top/categories/Algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="Algorithm" scheme="http://www.zsfmyz.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>HTML5 Drag &amp; Drop 拖拽与拖放</title>
    <link href="http://www.zsfmyz.top/JavaScript/HTML5%20drag%20&amp;%20drop%20%E6%8B%96%E6%8B%BD%E4%B8%8E%E6%8B%96%E6%94%BE/"/>
    <id>http://www.zsfmyz.top/JavaScript/HTML5 drag &amp; drop 拖拽与拖放/</id>
    <published>2019-09-07T03:09:34.000Z</published>
    <updated>2020-03-31T02:33:41.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="拖拽与拖放"><a href="#拖拽与拖放" class="headerlink" title="拖拽与拖放"></a>拖拽与拖放</h2><blockquote><p>drop &amp; drag 是html5自带的拖拽与拖放的api</p></blockquote><h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h3><p>所有需要被拖动的元素都要加上draggable属性，默认除了a，img等标签外不可拖动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// html 行内绑定</span><br><span class="line">&lt;element ondrag=&quot;myScript&quot;&gt;</span><br><span class="line">// js 绑定元素</span><br><span class="line">object.ondrag=function()&#123;&#125;;</span><br><span class="line">// 全局监听</span><br><span class="line">object.addEventListener(&quot;drag&quot;, myScript);</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="相关重点api"><a href="#相关重点api" class="headerlink" title="相关重点api"></a>相关重点api</h3><ul><li>拖拽元素上触发的事件（事件target是拖拽元素）</li></ul><ol><li>dragstart  被拖拽元素开始被拖拽时触发。</li><li>drag  被拖拽元素拖拽中触发</li><li>dragend  完成拖动时触发。</li></ol><ul><li>拖拽目标容器上的事件（事件target是目标容器）</li></ul><ol start="4"><li>dragenter  被拖拽元素在进入其原始容器内的时候触发。</li><li>dragleave  跟enter相对应。</li><li>dragover  在另一容器内时触发（实测，只要我开始拖动之后就一直触发，且该事件需要阻止浏览器默认事件，因为在其他容器内都是默认不能拖动的。）</li><li>drop 释放鼠标时候触发</li></ol><h3 id="DataTransfer-是拖拽元素的一个媒介对象，可以设置一些功能"><a href="#DataTransfer-是拖拽元素的一个媒介对象，可以设置一些功能" class="headerlink" title="DataTransfer 是拖拽元素的一个媒介对象，可以设置一些功能"></a>DataTransfer 是拖拽元素的一个媒介对象，可以设置一些功能</h3><ul><li><p>dataTransfer.dropEffect：设置或返回拖放目标上允许发生的拖放行为。如果此设置的拖放行为不在effectAllowed属性设置的多种拖放行为之内，拖放操作将会失败。该属性值只允许none、copy、link、move值之一。</p></li><li><p>dataTransfer.effectAllowed：设置或返回被拖动元素允许发生的拖动行为。该属性值可设置为none、copy、copyLink、copyMove、link、linkMove、move、all、uninitialized。</p></li><li><p>dataTransfer.items：该属性返回DataTransferItems对象，该对象代表了拖动数据。</p></li><li><p>dataTransfer.setDragImage(element x,y)：设置拖放操作的自定义图标。其中element设置自定义图标，x设置图标与鼠标在水平方向的距离；y设置图标与鼠标在垂直方向的距离。</p></li><li><p>dataTransfer.addElement(element)：添加自定义图标。</p></li><li><p>dataTransfer.types：该属性返回一个DOMStringList对象，该对象包括了存入dataTransfer中数据的所有类型。</p></li><li><p>dataTransfer.getData(format)：获取DataTransfer对象中设置format格式的数据。其中format代表数据格式，data代表数据。</p></li><li><p>dataTransfer.clearData([format])：清除DataTransfer对象中format格式的数据，如果省略format格式，则意味着清除DataTransfer对象中的全部数据。</p></li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;span  draggable=&quot;true&quot; &gt;&lt;/span&gt;  // 所有需要被拖动的元素都要加上draggable属性，默认除了a，img等标签外不可拖动。</span><br><span class="line"></span><br><span class="line">//start drag end 中 event都是被拖拽的元素</span><br><span class="line"></span><br><span class="line">document.addEventListener(&quot;dragstart&quot;, function (event) &#123; </span><br><span class="line">    var id = $(event.target).prop(&apos;id&apos;); </span><br><span class="line">    event.dataTransfer.dropEffect = &apos;move&apos; //设置拖动样式</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//dragover dragleave   dragenter drop 中event都代表拖放的容器元素  </span><br><span class="line"></span><br><span class="line">document.addEventListener(&quot;dragover&quot;, function(event) &#123;  </span><br><span class="line">    // drop 阻止浏览器默认事件</span><br><span class="line">    event.preventDefault();</span><br><span class="line">    console.log(&quot;容器内&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;拖拽与拖放&quot;&gt;&lt;a href=&quot;#拖拽与拖放&quot; class=&quot;headerlink&quot; title=&quot;拖拽与拖放&quot;&gt;&lt;/a&gt;拖拽与拖放&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;drop &amp;amp; drag 是html5自带的拖拽与拖放的api&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;语法：&quot;&gt;&lt;a href=&quot;#语法：&quot; class=&quot;headerlink&quot; title=&quot;语法：&quot;&gt;&lt;/a&gt;语法：&lt;/h3&gt;&lt;p&gt;所有需要被拖动的元素都要加上draggable属性，默认除了a，img等标签外不可拖动。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// html 行内绑定&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;element ondrag=&amp;quot;myScript&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// js 绑定元素&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;object.ondrag=function()&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 全局监听&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;object.addEventListener(&amp;quot;drag&amp;quot;, myScript);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.zsfmyz.top/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.zsfmyz.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Font-Family字体对照表及效果展示</title>
    <link href="http://www.zsfmyz.top/Css/font-family%E5%AD%97%E4%BD%93%E5%AF%B9%E7%85%A7%E8%A1%A8%E5%8F%8A%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA/"/>
    <id>http://www.zsfmyz.top/Css/font-family字体对照表及效果展示/</id>
    <published>2019-08-30T07:37:09.000Z</published>
    <updated>2020-03-31T02:28:11.266Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>直接进demo演示页面查看吧。</p><p><a href="https://www.zsfmyz.top/demo/font/">demo演示地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Demo&quot;&gt;&lt;a href=&quot;#Demo&quot; class=&quot;headerlink&quot; title=&quot;Demo&quot;&gt;&lt;/a&gt;Demo&lt;/h3&gt;&lt;p&gt;直接进demo演示页面查看吧。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zsfmyz.top/demo/fo
      
    
    </summary>
    
      <category term="Css" scheme="http://www.zsfmyz.top/categories/Css/"/>
    
    
      <category term="Css" scheme="http://www.zsfmyz.top/tags/Css/"/>
    
  </entry>
  
</feed>
